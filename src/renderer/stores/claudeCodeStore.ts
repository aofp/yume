/**
 * Zustand store specifically for Claude Code SDK integration
 * Handles sessions, streaming messages, and all SDK features
 */

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { claudeCodeClient } from '../services/claudeCodeClient';

export type SDKMessage = any; // Type from Claude Code SDK

export interface FileSnapshot {
  path: string;
  content: string;
  operation: 'edit' | 'write' | 'create' | 'delete' | 'multiedit';
  timestamp: number;
  messageIndex: number;
  oldContent?: string; // For diffs
}

export interface RestorePoint {
  messageIndex: number;
  timestamp: number;
  fileSnapshots: FileSnapshot[];
  description: string; // e.g., "edited 3 files", "created new file"
}

export interface SessionAnalytics {
  totalMessages: number;
  userMessages: number;
  assistantMessages: number;
  toolUses: number;
  tokens: {
    input: number;
    output: number;
    total: number;
    byModel: {
      opus: { input: number; output: number; total: number; };
      sonnet: { input: number; output: number; total: number; };
    };
  };
  cost?: {
    total: number;
    byModel: {
      opus: number;
      sonnet: number;
    };
  };
  duration: number; // in milliseconds
  lastActivity: Date;
  thinkingTime: number; // total thinking time in seconds
}

export interface Session {
  id: string;
  name: string;
  status: 'pending' | 'active' | 'paused' | 'completed' | 'error';
  messages: SDKMessage[];
  workingDirectory?: string;
  createdAt: Date;
  updatedAt: Date;
  claudeSessionId?: string; // Track the Claude SDK session ID
  claudeTitle?: string; // Title generated by Claude for the task
  userRenamed?: boolean; // Track if user manually renamed the tab (skip auto title)
  analytics?: SessionAnalytics; // Per-session analytics
  draftInput?: string; // Store draft input text
  draftAttachments?: any[]; // Store draft attachments
  streaming?: boolean; // Track if this session is currently streaming
  restorePoints?: RestorePoint[]; // Track file changes at each message
  modifiedFiles?: Set<string>; // Track all files touched in this session
  runningBash?: boolean; // Track if bash command is currently running
  userBashRunning?: boolean; // Track if user's bash command (!) is running
  bashProcessId?: string; // Current bash process ID for cancellation
  watermarkImage?: string; // Base64 or URL for watermark image
  pendingToolIds?: Set<string>; // Track pending tool operations by ID
  thinkingStartTime?: number; // Track when thinking started for this session
  readOnly?: boolean; // Mark sessions loaded from projects as read-only
}

interface ClaudeCodeStore {
  // Sessions
  sessions: Session[];
  currentSessionId: string | null;
  persistedSessionId: string | null; // Track the sessionId for persistence
  sessionMappings: Record<string, any>; // Map yurucode sessionIds to Claude sessionIds
  
  // Model
  selectedModel: string;
  
  // Watermark
  globalWatermarkImage: string | null; // Global watermark for all sessions
  
  // Streaming (deprecated - now per-session)
  streamingMessage: string;
  
  // Session management
  isLoadingHistory: boolean;
  availableSessions: any[]; // List of available persisted sessions
  
  // Actions
  setSelectedModel: (modelId: string) => void;
  createSession: (name?: string, directory?: string, existingSessionId?: string) => Promise<string>;
  setCurrentSession: (sessionId: string) => void;
  sendMessage: (content: string, bashMode?: boolean) => Promise<void>;
  resumeSession: (sessionId: string) => Promise<void>;
  reconnectSession: (sessionId: string, claudeSessionId: string) => void;
  pauseSession: (sessionId: string) => void;
  deleteSession: (sessionId: string) => void;
  deleteAllSessions: () => void;
  reorderSessions: (fromIndex: number, toIndex: number) => void;
  renameSession: (sessionId: string, newTitle: string) => void;
  interruptSession: () => Promise<void>;
  clearContext: (sessionId: string) => void;
  updateSessionDraft: (sessionId: string, input: string, attachments: any[]) => void;
  restoreToMessage: (sessionId: string, messageIndex: number) => void;
  addMessageToSession: (sessionId: string, message: SDKMessage) => void;
  
  // Session persistence
  loadSessionHistory: (sessionId: string) => Promise<void>;
  listAvailableSessions: () => Promise<void>;
  loadPersistedSession: (sessionId: string) => Promise<void>;
  updateSessionMapping: (sessionId: string, claudeSessionId: string, metadata?: any) => void;
  loadSessionMappings: () => void;
  saveSessionMappings: () => void;
  
  // Model management
  toggleModel: () => void;
  
  // MCP & Tools
  configureMcpServers: (servers: any) => Promise<void>;
  setPermissionMode: (mode: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan') => void;
  updateAllowedTools: (tools: string[]) => void;
  
  // Watermark
  setGlobalWatermark: (image: string | null) => void;
}

// Helper function to track file changes from tool operations
const trackFileChange = (session: Session, message: any, messageIndex: number): RestorePoint | null => {
  if (!message || message.type !== 'assistant') return null;
  
  const content = message.message?.content;
  if (!content || !Array.isArray(content)) return null;
  
  const fileSnapshots: FileSnapshot[] = [];
  const modifiedFiles = new Set(session.modifiedFiles || []);
  
  // Look for tool_use blocks in the content
  content.forEach((block: any) => {
    if (block.type === 'tool_use') {
      const toolName = block.name;
      const input = block.input;
      
      if (!input) return;
      
      // Track file operations
      switch (toolName) {
        case 'Edit':
        case 'MultiEdit':
          if (input.file_path) {
            const snapshot: FileSnapshot = {
              path: input.file_path,
              content: input.new_string || '',
              oldContent: input.old_string || '',
              operation: toolName === 'MultiEdit' ? 'multiedit' : 'edit',
              timestamp: Date.now(),
              messageIndex
            };
            fileSnapshots.push(snapshot);
            modifiedFiles.add(input.file_path);
          }
          break;
          
        case 'Write':
          if (input.file_path) {
            const snapshot: FileSnapshot = {
              path: input.file_path,
              content: input.content || '',
              operation: 'write',
              timestamp: Date.now(),
              messageIndex
            };
            fileSnapshots.push(snapshot);
            modifiedFiles.add(input.file_path);
          }
          break;
      }
    }
  });
  
  if (fileSnapshots.length > 0) {
    // Create description
    const fileCount = fileSnapshots.length;
    const operations = fileSnapshots.map(s => s.operation);
    const uniqueOps = [...new Set(operations)];
    const description = uniqueOps.length === 1 
      ? `${uniqueOps[0]} ${fileCount} file${fileCount !== 1 ? 's' : ''}`
      : `modified ${fileCount} file${fileCount !== 1 ? 's' : ''}`;
    
    return {
      messageIndex,
      timestamp: Date.now(),
      fileSnapshots,
      description
    };
  }
  
  return null;
};

// Helper to persist sessions to localStorage
const persistSessions = (sessions: Session[]) => {
  try {
    // Store essential session data for recovery
    const sessionData = sessions.map(s => ({
      id: s.id,
      name: s.name,
      claudeTitle: s.claudeTitle,
      claudeSessionId: s.claudeSessionId,
      workingDirectory: s.workingDirectory,
      messages: s.messages, // Keep messages for context
      analytics: s.analytics,
      createdAt: s.createdAt,
      updatedAt: s.updatedAt,
      userRenamed: s.userRenamed,
      draftInput: s.draftInput, // Preserve draft input
      draftAttachments: s.draftAttachments, // Preserve draft attachments
      restorePoints: s.restorePoints,
      modifiedFiles: s.modifiedFiles ? Array.from(s.modifiedFiles) : [] // Convert Set to Array for storage
    }));
    localStorage.setItem('yurucode-sessions', JSON.stringify(sessionData));
    localStorage.setItem('yurucode-sessions-timestamp', Date.now().toString()); // Add timestamp for validation
    console.log('[Store] Persisted', sessions.length, 'sessions to localStorage with', 
      sessionData.reduce((acc, s) => acc + s.messages.length, 0), 'total messages');
  } catch (err) {
    console.error('[Store] Failed to persist sessions:', err);
  }
};

// Helper to restore sessions from localStorage
const restoreSessions = (): Session[] => {
  try {
    const stored = localStorage.getItem('yurucode-sessions');
    const timestamp = localStorage.getItem('yurucode-sessions-timestamp');
    
    if (stored) {
      // Check if sessions are stale (older than 24 hours)
      if (timestamp) {
        const age = Date.now() - parseInt(timestamp);
        if (age > 24 * 60 * 60 * 1000) {
          console.log('[Store] Sessions are older than 24 hours, clearing');
          localStorage.removeItem('yurucode-sessions');
          localStorage.removeItem('yurucode-sessions-timestamp');
          return [];
        }
      }
      
      const sessionData = JSON.parse(stored);
      const sessions = sessionData.map((s: any) => ({
        ...s,
        status: 'paused' as const, // Mark as paused until reconnected
        streaming: false,
        pendingToolIds: new Set(),
        modifiedFiles: new Set(s.modifiedFiles || []),
        createdAt: new Date(s.createdAt),
        updatedAt: new Date(s.updatedAt),
        // Preserve claudeSessionId for session resumption with --resume flag
        claudeSessionId: s.claudeSessionId, // KEEP this for --resume
        workingDirectory: s.workingDirectory,
        messages: s.messages || [],
        analytics: s.analytics || {
          totalMessages: 0,
          userMessages: 0,
          assistantMessages: 0,
          toolUses: 0,
          tokens: { 
            input: 0, 
            output: 0, 
            total: 0,
            byModel: {
              opus: { input: 0, output: 0, total: 0 },
              sonnet: { input: 0, output: 0, total: 0 }
            }
          },
          duration: 0,
          lastActivity: new Date(),
          thinkingTime: 0
        },
        claudeTitle: s.claudeTitle,
        userRenamed: s.userRenamed,
        draftInput: s.draftInput,
        draftAttachments: s.draftAttachments,
        restorePoints: s.restorePoints || [],
        // Mark that we need to reconnect this session
        needsReconnect: !!s.claudeSessionId
      }));
      
      console.log('[Store] Restored', sessions.length, 'sessions from localStorage with',
        sessions.reduce((acc, s) => acc + s.messages.length, 0), 'total messages');
      
      // Sessions with claudeSessionId will be reconnected from main.tsx after socket is ready
      sessions.forEach(s => {
        if (s.claudeSessionId) {
          console.log(`[Store] Session ${s.id} has claudeSessionId ${s.claudeSessionId} - will reconnect with --resume`);
        } else {
          console.log(`[Store] Session ${s.id} has no claudeSessionId - will create fresh on first message`);
        }
      });
      
      return sessions;
    }
  } catch (err) {
    console.error('[Store] Failed to restore sessions:', err);
  }
  return [];
};

export const useClaudeCodeStore = create<ClaudeCodeStore>()(
  persist(
    (set, get) => ({
  sessions: [], // Don't restore sessions on startup - start fresh
  currentSessionId: null, // No current session on startup
  persistedSessionId: null,
  sessionMappings: {},
  selectedModel: 'claude-opus-4-1-20250805',
  globalWatermarkImage: null,
  streamingMessage: '',
  isLoadingHistory: false,
  availableSessions: [],
  
  setSelectedModel: (modelId: string) => {
    set({ selectedModel: modelId });
    // Could notify the server about model change here if needed
    console.log('Model changed to:', modelId);
  },
  
  createSession: async (name?: string, directory?: string, existingSessionId?: string) => {
    console.log('[Store] createSession called:', { name, directory, existingSessionId });
    console.trace('[Store] Stack trace for createSession');
    
    try {
      // Generate more entropic session ID with timestamp and random components
      const timestamp = Date.now().toString(36);
      const random1 = Math.random().toString(36).substring(2, 8);
      const random2 = Math.random().toString(36).substring(2, 8);
      const hexId = `${timestamp}-${random1}-${random2}`;
      // ALWAYS use unique session name to prevent duplicate sessions
      const sessionName = `session-${hexId}`;
      // Use the provided directory, or get home directory from Tauri
      let workingDirectory = directory;
      
      if (!workingDirectory && window.__TAURI__) {
        try {
          const { invoke } = await import('@tauri-apps/api/core');
          // Try to get home directory from Tauri
          workingDirectory = await invoke<string>('get_home_directory');
          console.log('[Store] Using home directory from Tauri:', workingDirectory);
        } catch (err) {
          console.error('[Store] Failed to get home directory:', err);
          // Platform-specific fallbacks
          const isWindows = navigator.platform.toLowerCase().includes('win');
          workingDirectory = isWindows ? 'C:\\Users\\' : '/Users';
        }
      } else if (!workingDirectory) {
        // Fallback for non-Tauri environments
        const isWindows = navigator.platform.toLowerCase().includes('win');
        workingDirectory = isWindows ? 'C:\\Users\\' : '/Users';
      }
      
      // Check if we're resuming an existing session (reconnecting after app restart)
      const currentState = get();
      const existingSession = existingSessionId ? 
        currentState.sessions.find(s => s.id === existingSessionId) : 
        null;
      
      // STEP 1: Create tab immediately with pending status (or update existing)
      const tempSessionId = existingSessionId || `temp-${hexId}`;
      // Get the current number of sessions to determine tab number
      const tabNumber = existingSession ? 
        currentState.sessions.findIndex(s => s.id === existingSessionId) + 1 :
        currentState.sessions.length + 1;
      
      const pendingSession: Session = existingSession || {
        id: tempSessionId,
        name: sessionName,
        status: 'pending' as const,
        messages: [],
        workingDirectory,
        createdAt: new Date(),
        updatedAt: new Date(),
        claudeTitle: `tab ${tabNumber}`, // Default title as 'tab x'
        pendingToolIds: new Set(),
        analytics: {
          totalMessages: 0,
          userMessages: 0,
          assistantMessages: 0,
          toolUses: 0,
          tokens: { 
            input: 0, 
            output: 0, 
            total: 0,
            byModel: {
              opus: { input: 0, output: 0, total: 0 },
              sonnet: { input: 0, output: 0, total: 0 }
            }
          },
          cost: { total: 0, byModel: { opus: 0, sonnet: 0 } },
          duration: 0,
          lastActivity: new Date(),
          thinkingTime: 0
        }
      };
      
      // Add pending session to store immediately so tab appears (or update existing)
      console.log('[Store] Adding/updating session:', tempSessionId);
      if (existingSession) {
        // Update existing session to pending while reconnecting
        set(state => ({
          sessions: state.sessions.map(s => 
            s.id === existingSessionId ? { ...s, status: 'pending' as const } : s
          ),
          currentSessionId: existingSessionId
        }));
      } else {
        // Add new pending session
        set(state => ({
          sessions: [...state.sessions, pendingSession],
          currentSessionId: tempSessionId
        }));
      }
      
      // STEP 2: Initialize Claude SDK session in background
      try {
        // Map our model IDs to Claude Code SDK model names
        const { selectedModel } = get();
        const modelMap: Record<string, string> = {
          'opus': 'claude-opus-4-1-20250805',
          'sonnet': 'claude-sonnet-4-20250514'
        };
        
        // Create or resume session using Claude Code Client
        // Get the claudeSessionId from existing session if reconnecting
        const claudeSessionIdToResume = existingSession?.claudeSessionId;
        
        const result = await claudeCodeClient.createSession(sessionName, workingDirectory, {
          allowedTools: [
            'Read', 'Write', 'Edit', 'MultiEdit',
            'LS', 'Glob', 'Grep',
            'Bash',
            'WebFetch', 'WebSearch',
            'TodoWrite'
          ],
          permissionMode: 'default',
          maxTurns: 30,
          model: modelMap[selectedModel] || 'claude-opus-4-1-20250805',
          sessionId: existingSessionId || tempSessionId, // Pass the sessionId for consistency
          claudeSessionId: claudeSessionIdToResume, // Pass claudeSessionId if resuming
          messages: existingSession?.messages || [] // Pass existing messages if resuming
        });
        
        const sessionId = result.sessionId || tempSessionId;
        const existingMessages = result.messages || [];
        // Store claudeSessionId from server response - server decides if this is a resume
        // The server returns claudeSessionId when resuming, undefined when starting fresh
        const claudeSessionId = result.claudeSessionId;
        
        console.log(`[Store] Session ${sessionId}:`);
        console.log(`  - Existing messages: ${existingMessages.length}`);
        console.log(`  - Working directory: ${result.workingDirectory || workingDirectory}`);
        console.log(`  - Claude session ID: ${claudeSessionId || 'none (new session)'}`);
        const existingResultsWithUsage = existingMessages.filter(m => m.type === 'result' && m.usage);
        console.log(`  - Result messages with usage: ${existingResultsWithUsage.length}`);
        
        // STEP 3: Update tab to active status with real session ID
        const activeSession: Session = {
          id: sessionId,
          name: sessionName,
          status: 'active' as const,
          messages: existingMessages,
          workingDirectory: result.workingDirectory || workingDirectory,
          createdAt: pendingSession.createdAt,
          updatedAt: new Date(),
          claudeSessionId,
          claudeTitle: pendingSession.claudeTitle, // Keep the 'tab x' title
          pendingToolIds: new Set(),
          // Initialize fresh analytics for new session (even if resuming)
          analytics: {
            totalMessages: 0,
            userMessages: 0,
            assistantMessages: 0,
            toolUses: 0,
            tokens: { 
              input: 0, 
              output: 0, 
              total: 0,
              byModel: {
                opus: { input: 0, output: 0, total: 0 },
                sonnet: { input: 0, output: 0, total: 0 }
              }
            },
            cost: { total: 0, byModel: { opus: 0, sonnet: 0 } },
            duration: 0,
            lastActivity: new Date(),
            thinkingTime: 0
          }
        };
        
        // Replace pending session with active one (handle both new and reconnected sessions)
        console.log('[Store] Updating session to active:', { 
          tempSessionId, 
          sessionId, 
          existingSessionId,
          isReconnecting: !!existingSession 
        });
        set(state => {
          const newSessions = existingSession ?
            // If reconnecting, update the existing session
            state.sessions.map(s => 
              s.id === existingSessionId ? activeSession : s
            ) :
            // If new session, replace the temp session
            state.sessions.map(s => 
              s.id === tempSessionId ? activeSession : s
            );
          persistSessions(newSessions); // Persist after update
          localStorage.setItem('yurucode-current-session', sessionId);
          return {
            sessions: newSessions,
            currentSessionId: sessionId
          };
        });
      
      // Don't add initial system message here - Claude Code SDK sends it automatically
      
      // Set up message listener for REAL responses
      console.log('[Store] Setting up message listener for session:', sessionId);
      
      // Listen for title updates
      const titleCleanup = claudeCodeClient.onTitle(sessionId, (title: string) => {
        console.log('[Store] Received title for session:', sessionId, title);
        set(state => ({
          sessions: state.sessions.map(s => 
            // Only update title if user hasn't manually renamed
            s.id === sessionId && !s.userRenamed
              ? { ...s, claudeTitle: title } 
              : s
          )
        }));
      });
      
      // Set up error handler for this session
      const errorCleanup = claudeCodeClient.onError(sessionId, (error) => {
        console.error('[Store] Error received for session:', sessionId, error);
        
        // Add error message to the session
        set(state => ({
          ...state,
          sessions: state.sessions.map(s => 
            s.id === sessionId 
              ? {
                  ...s,
                  messages: [...s.messages, {
                    id: `error-${Date.now()}`,
                    type: 'error',
                    content: error.message,
                    timestamp: error.timestamp || Date.now(),
                    errorType: error.type
                  }],
                  streaming: false
                }
              : s
          )
        }));
      });
      
      const messageCleanup = claudeCodeClient.onMessage(sessionId, (message) => {
          // CRITICAL: Check if this session is still the current one
          const currentState = get();
          const isCurrentSession = currentState.currentSessionId === sessionId;
          
          // ALWAYS process ALL messages for ALL sessions to maintain correct state
          // This ensures that when you switch tabs, all messages are already there
          // We're not filtering any messages - all sessions get all their messages
          console.log('[Store] Message received for session:', {
            sessionId,
            isCurrentSession,
            messageType: message.type,
            messageSubtype: message.subtype,
            streaming: message.streaming,
            id: message.id
          });
          
          console.log('[Store] Processing message:', {
            sessionId,
            type: message.type,
            id: message.id,
            streaming: message.streaming,
            name: message.message?.name,
            hasContent: !!message.message?.content,
            hasInput: !!message.message?.input
          });
          
          // CRITICAL LOG FOR TOOL MESSAGES
          if (message.type === 'tool_use' || message.type === 'tool_result') {
            console.log('ðŸ”§ðŸ”§ðŸ”§ TOOL MESSAGE RECEIVED:', {
              type: message.type,
              name: message.message?.name,
              id: message.id,
              fullMessage: message
            });
          }
          
          // Handle streaming messages by updating existing message or adding new
          set(state => {
            // ALWAYS process ALL messages for ALL sessions
            // This ensures that when you switch tabs, all messages are already there
            // We're not skipping any messages anymore - all sessions get all their messages
            console.log('[Store] Processing message in set state:', {
              sessionId,
              messageType: message.type,
              isCurrentSession: state.currentSessionId === sessionId
            });
            
            let sessions = state.sessions.map(s => {
              if (s.id !== sessionId) return s;
              
              // Update claudeSessionId if present in message
              if (message.session_id && !s.claudeSessionId) {
                console.log(`[Store] Updating claudeSessionId for session ${sessionId}: ${message.session_id}`);
                s = { ...s, claudeSessionId: message.session_id };
                
                // Also update the session mapping
                get().updateSessionMapping(sessionId, message.session_id, {
                  name: s.claudeTitle || s.name,
                  projectPath: s.workingDirectory
                });
              }
              
              const existingMessages = [...s.messages];
              
              // CRITICAL: Never accept user messages from server - they should only come from sendMessage
              if (message.type === 'user') {
                console.warn('[Store] Ignoring user message from server - user messages should only be created locally');
                return s;
              }
              
              // Handle messages with proper deduplication
              if (message.id) {
                const existingIndex = existingMessages.findIndex(m => m.id === message.id);
                if (existingIndex >= 0) {
                  // Update existing message (for streaming updates)
                  // IMPORTANT: Merge content to avoid erasing messages
                  console.log(`[Store] Updating message ${message.id} at index ${existingIndex}, streaming: ${message.streaming}`);
                  const existingMessage = existingMessages[existingIndex];
                  
                  // Special handling for result messages - ensure we don't lose final assistant messages
                  if (message.type === 'result' && (message.subtype === 'error_max_turns' || message.is_error)) {
                    console.log('[Store] Processing error result - ensuring final assistant message is preserved');
                    // Look for recent assistant messages that should be preserved
                    const recentAssistantMessages = existingMessages.filter(m => 
                      m.type === 'assistant' && 
                      m.timestamp && 
                      Date.now() - m.timestamp < 5000 // Within last 5 seconds
                    );
                    if (recentAssistantMessages.length > 0) {
                      console.log(`[CLIENT] Found ${recentAssistantMessages.length} recent assistant messages to preserve`);
                    }
                  }
                  
                  // Never update tool_use or tool_result messages - they should be immutable
                  if (existingMessage.type === 'tool_use' || existingMessage.type === 'tool_result') {
                    console.log(`Skipping update for ${existingMessage.type} message - preserving original`);
                  } else if (message.type === 'assistant') {
                    // For assistant messages during streaming, handle array or string content
                    const existingContent = existingMessage.message?.content || '';
                    const newContent = message.message?.content || '';
                    
                    // Convert to string if needed for comparison
                    const existingStr = typeof existingContent === 'string' ? existingContent : JSON.stringify(existingContent);
                    const newStr = typeof newContent === 'string' ? newContent : JSON.stringify(newContent);
                    
                    // Just use the new content directly - Claude Code SDK sends full updates
                    let finalContent = message.message?.content || existingMessage.message?.content;
                    
                    console.log(`[CLIENT] Assistant message update - streaming: ${message.streaming}, content length: ${typeof finalContent === 'string' ? finalContent.length : JSON.stringify(finalContent).length}`);
                    
                    existingMessages[existingIndex] = {
                      ...message,
                      message: {
                        ...message.message,
                        content: finalContent
                      },
                      streaming: message.streaming // Explicitly preserve streaming flag
                    };
                  } else {
                    existingMessages[existingIndex] = message;
                  }
                } else {
                  // Add new message only if it doesn't exist
                  console.log(`[CLIENT] Adding new message ${message.id} (type: ${message.type}, streaming: ${message.streaming}, model: ${message.model})`);
                  
                  // Special handling for result messages with error_max_turns
                  if (message.type === 'result' && message.subtype === 'error_max_turns') {
                    console.log('[CLIENT] Adding error_max_turns result - verifying final assistant message exists');
                    // Check if we have a recent assistant message, if not, there might be a timing issue
                    const hasRecentAssistant = existingMessages.some(m => 
                      m.type === 'assistant' && 
                      m.timestamp && 
                      Date.now() - m.timestamp < 10000 && // Within last 10 seconds
                      !m.streaming // Non-streaming (finalized)
                    );
                    if (!hasRecentAssistant) {
                      console.warn('[CLIENT] No recent finalized assistant message found before error_max_turns result');
                    }
                  }
                  
                  existingMessages.push(message);
                }
              } else {
                // Messages without ID - check for duplicate content
                const isDuplicate = existingMessages.some(m => 
                  m.type === message.type && 
                  JSON.stringify(m.message) === JSON.stringify(message.message)
                );
                if (!isDuplicate) {
                  console.log(`Adding message without ID (type: ${message.type})`);
                  existingMessages.push(message);
                } else {
                  console.log(`Skipping duplicate message without ID (type: ${message.type})`);
                }
              }
              
              // Update analytics - preserve existing data
              const analytics = s.analytics || {
                totalMessages: 0,
                userMessages: 0,
                assistantMessages: 0,
                toolUses: 0,
                tokens: { 
                  input: 0, 
                  output: 0, 
                  total: 0,
                  byModel: {
                    opus: { input: 0, output: 0, total: 0 },
                    sonnet: { input: 0, output: 0, total: 0 }
                  }
                },
                duration: 0,
                lastActivity: new Date(),
                thinkingTime: 0
              };
              
              console.log(`ðŸ” [ANALYTICS DEBUG] Session ${s.id}: Before processing, analytics tokens: ${analytics.tokens.total}`);
              
              // Update message counts
              analytics.totalMessages = existingMessages.length;
              analytics.userMessages = existingMessages.filter(m => m.type === 'user').length;
              analytics.assistantMessages = existingMessages.filter(m => m.type === 'assistant').length;
              analytics.toolUses = existingMessages.filter(m => m.type === 'tool_use').length;
              
              // Initialize byModel if it doesn't exist (for backward compatibility)
              if (!analytics.tokens.byModel) {
                analytics.tokens.byModel = {
                  opus: { input: 0, output: 0, total: 0 },
                  sonnet: { input: 0, output: 0, total: 0 }
                };
              }
              
              // Update tokens if result message - Claude CLI sends cumulative values for this conversation
              if (message.type === 'result') {
                console.log('ðŸ“Š [TOKEN DEBUG] Received result message:', {
                  id: message.id,
                  type: message.type,
                  subtype: message.subtype,
                  hasUsage: !!message.usage,
                  usage: message.usage,
                  hasCost: !!message.total_cost_usd,
                  cost: message.total_cost_usd,
                  claudeSessionId: s.claudeSessionId,
                  isCompactResult: message.usage?.input_tokens === 0 && message.usage?.output_tokens === 0,
                  fullMessage: message
                });
                
                if (message.usage) {
                  // Check if this is a /compact result (all zeros)
                  const isCompactResult = message.usage.input_tokens === 0 && 
                                         message.usage.output_tokens === 0 && 
                                         message.usage.cache_creation_input_tokens === 0 && 
                                         message.usage.cache_read_input_tokens === 0;
                  
                  if (isCompactResult) {
                    console.log('ðŸ—œï¸ [COMPACT DETECTED] /compact command completed - need to fetch new token count');
                    console.log('ðŸ—œï¸ [COMPACT] Current analytics before compact:', analytics.tokens);
                    console.log('ðŸ—œï¸ [COMPACT] Session claudeSessionId:', s.claudeSessionId);
                    
                    // After a compact, we need to query Claude for the new context size
                    // For now, log that we detected it - the next message will have the updated counts
                    console.log('ðŸ—œï¸ [COMPACT] Next message from Claude should have updated token counts');
                    
                    // Don't update tokens for compact result (all zeros)
                    return { ...s, messages: existingMessages, analytics, updatedAt: new Date() };
                  }
                  
                  // Only update tokens if this is a new result message (avoid duplicates)
                  const isNewResult = !s.messages.find(m => m.id === message.id && m.type === 'result');
                  const existingResultMessages = s.messages.filter(m => m.type === 'result').map(m => ({ id: m.id, usage: m.usage }));
                  console.log(`ðŸ” [TOKEN DEBUG] Processing result message ${message.id}, isNewResult: ${isNewResult}, current analytics tokens: ${analytics.tokens.total}`);
                  console.log(`ðŸ” [TOKEN DEBUG] Session ${s.id} claudeSessionId: ${s.claudeSessionId}`);
                  console.log(`ðŸ” [TOKEN DEBUG] Existing result messages in session:`, existingResultMessages);
                  console.log(`ðŸ” [TOKEN DEBUG] Is compact result: ${isCompactResult}`);
                  
                  if (isNewResult) {
                    console.log('ðŸ“Š Result message with usage:', message.usage);
                    if (message.cost) {
                      console.log('ðŸ’° Result message with cost:', message.cost);
                    }
                  
                  // Include all input token types
                  // IMPORTANT: Don't count cache tokens against context window!
                  // Cache tokens allow Claude to work beyond 200k limit
                  const regularInputTokens = message.usage.input_tokens || 0;
                  const cacheCreationTokens = message.usage.cache_creation_input_tokens || 0;
                  const cacheReadTokens = message.usage.cache_read_input_tokens || 0;
                  const outputTokens = message.usage.output_tokens || 0;
                  
                  // Only count regular tokens for context window calculation
                  const inputTokens = regularInputTokens; // Exclude cache tokens!
                  const totalTokens = inputTokens + outputTokens;
                  
                  console.log(`ðŸ” [TOKEN DEBUG] Token breakdown:`);
                  console.log(`   Regular input: ${regularInputTokens}`);
                  console.log(`   Cache creation: ${cacheCreationTokens} (not counted)`);
                  console.log(`   Cache read: ${cacheReadTokens} (not counted)`);
                  console.log(`   Output: ${outputTokens}`);
                  console.log(`   TOTAL for context: ${totalTokens} (cache excluded)`);
                  
                  // Check if previous message was a compact - if so, reset tokens
                  const previousMessages = s.messages.filter(m => m.type === 'result' && m.usage);
                  const lastResultMessage = previousMessages[previousMessages.length - 1];
                  const wasCompact = lastResultMessage?.usage && 
                                    lastResultMessage.usage.input_tokens === 0 && 
                                    lastResultMessage.usage.output_tokens === 0;
                  
                  if (wasCompact) {
                    console.log('ðŸ—œï¸ [COMPACT RECOVERY] Previous message was compact, resetting token count');
                    console.log('ðŸ—œï¸ [COMPACT RECOVERY] Old total:', analytics.tokens.total);
                    // Reset tokens after compact
                    analytics.tokens.input = inputTokens;
                    analytics.tokens.output = outputTokens;
                    analytics.tokens.total = totalTokens;
                    console.log('ðŸ—œï¸ [COMPACT RECOVERY] New total after compact:', analytics.tokens.total);
                  } else {
                    // CRITICAL: Use accumulation (+=) not assignment (=)
                    // Claude CLI sends per-message values, not cumulative
                    const previousTotal = analytics.tokens.total;
                    analytics.tokens.input += inputTokens;
                    analytics.tokens.output += outputTokens;
                    analytics.tokens.total += totalTokens;
                    console.log(`ðŸ“Š [TOKEN UPDATE] Normal accumulation - Previous: ${previousTotal}, Added: ${totalTokens}, New: ${analytics.tokens.total}`);
                  }
                  
                  console.log(`ðŸ“Š [TOKEN UPDATE] Session ${s.id}:`);
                  console.log(`   Input: ${analytics.tokens.input}`);
                  console.log(`   Output: ${analytics.tokens.output}`);
                  console.log(`   Total: ${analytics.tokens.total}`);
                  console.log(`   Context usage: ${(analytics.tokens.total / 200000 * 100).toFixed(1)}%`);
                  
                  // Determine which model was used (check message.model or use current selectedModel)
                  const modelUsed = message.model || get().selectedModel;
                  const isOpus = modelUsed.includes('opus');
                  const modelKey = isOpus ? 'opus' : 'sonnet';
                  
                  // Update model-specific tokens (accumulate per message)
                  // Both models can be used in the same conversation if user switches
                  if (isOpus) {
                    analytics.tokens.byModel.opus.input += inputTokens;
                    analytics.tokens.byModel.opus.output += outputTokens;
                    analytics.tokens.byModel.opus.total += inputTokens + outputTokens;
                  } else {
                    analytics.tokens.byModel.sonnet.input += inputTokens;
                    analytics.tokens.byModel.sonnet.output += outputTokens;
                    analytics.tokens.byModel.sonnet.total += inputTokens + outputTokens;
                  }
                  
                  // Store cost information (accumulate per message)
                  if (message.total_cost_usd !== undefined) {
                    if (!analytics.cost) {
                      analytics.cost = { total: 0, byModel: { opus: 0, sonnet: 0 } };
                    }
                    // Accumulate cost for each message
                    analytics.cost.total += message.total_cost_usd;
                    if (isOpus) {
                      analytics.cost.byModel.opus += message.total_cost_usd;
                    } else {
                      analytics.cost.byModel.sonnet += message.total_cost_usd;
                    }
                    console.log('ðŸ’µ Updated cost:', analytics.cost);
                  }
                  }
                } else {
                  // No usage data in result message - estimate based on messages
                  console.log('âš ï¸ [TOKEN DEBUG] No usage data in result message, estimating from messages');
                  
                  // Count tokens from all messages in this conversation
                  let estimatedInput = 0;
                  let estimatedOutput = 0;
                  
                  s.messages.forEach(msg => {
                    if (msg.type === 'user' && msg.message?.content) {
                      // Rough estimate: 1 token per 4 characters for input
                      const content = typeof msg.message.content === 'string' 
                        ? msg.message.content 
                        : JSON.stringify(msg.message.content);
                      estimatedInput += Math.ceil(content.length / 4);
                    } else if (msg.type === 'assistant' && msg.message?.content) {
                      // Count assistant message tokens
                      const content = typeof msg.message.content === 'string'
                        ? msg.message.content
                        : JSON.stringify(msg.message.content);
                      estimatedOutput += Math.ceil(content.length / 4);
                    }
                  });
                  
                  // Update analytics with estimates
                  analytics.tokens.input = estimatedInput;
                  analytics.tokens.output = estimatedOutput;
                  analytics.tokens.total = estimatedInput + estimatedOutput;
                  
                  // Update model-specific tokens
                  const modelUsed = message.model || get().selectedModel;
                  const isOpus = modelUsed.includes('opus');
                  
                  if (isOpus) {
                    analytics.tokens.byModel.opus = {
                      input: estimatedInput,
                      output: estimatedOutput,
                      total: estimatedInput + estimatedOutput
                    };
                    analytics.tokens.byModel.sonnet = { input: 0, output: 0, total: 0 };
                  } else {
                    analytics.tokens.byModel.sonnet = {
                      input: estimatedInput,
                      output: estimatedOutput,
                      total: estimatedInput + estimatedOutput
                    };
                    analytics.tokens.byModel.opus = { input: 0, output: 0, total: 0 };
                  }
                  
                  // Estimate cost (rough pricing)
                  const costPerMillionInput = isOpus ? 15 : 3;  // $15/$3 per million
                  const costPerMillionOutput = isOpus ? 75 : 15; // $75/$15 per million
                  const estimatedCost = (estimatedInput * costPerMillionInput / 1000000) + 
                                       (estimatedOutput * costPerMillionOutput / 1000000);
                  
                  if (!analytics.cost) {
                    analytics.cost = { total: 0, byModel: { opus: 0, sonnet: 0 } };
                  }
                  analytics.cost.total = estimatedCost;
                  analytics.cost.byModel.opus = isOpus ? estimatedCost : 0;
                  analytics.cost.byModel.sonnet = !isOpus ? estimatedCost : 0;
                  
                  console.log('ðŸ“Š [TOKEN DEBUG] Estimated tokens:', {
                    input: estimatedInput,
                    output: estimatedOutput,
                    total: estimatedInput + estimatedOutput,
                    cost: estimatedCost
                  });
                }
              }
              
              // Update duration and last activity
              analytics.duration = new Date().getTime() - s.createdAt.getTime();
              analytics.lastActivity = new Date();
              
              // Track file changes for assistant messages with tool_use blocks
              let restorePoints = [...(s.restorePoints || [])];
              let modifiedFiles = new Set(s.modifiedFiles || []);
              
              if (message.type === 'assistant' && !message.streaming) {
                const restorePoint = trackFileChange(s, message, existingMessages.length - 1);
                if (restorePoint) {
                  restorePoints.push(restorePoint);
                  // Update modified files set
                  restorePoint.fileSnapshots.forEach(snapshot => {
                    modifiedFiles.add(snapshot.path);
                  });
                }
              }
              
              return { 
                ...s, 
                messages: existingMessages, 
                updatedAt: new Date(), 
                analytics,
                restorePoints,
                modifiedFiles
              };
            });
            
            // Update streaming state based on message type
            if (message.type === 'assistant') {
              // Update streaming state based on the message's streaming flag
              console.log(`[THINKING TIME DEBUG] Assistant message - streaming: ${message.streaming}, sessionId: ${sessionId}`);
              if (message.streaming === true) {
                // Don't reset thinkingStartTime here - it's already set when user sends message
                console.log(`[THINKING TIME DEBUG] Assistant streaming started, keeping existing thinkingStartTime`);
                sessions = sessions.map(s => 
                  s.id === sessionId ? { ...s, streaming: true } : s
                );
              } else if (message.streaming === false) {
                // When explicitly marked as streaming=false, always clear streaming
                // The server marks assistant messages as streaming=false when complete
                console.log(`ðŸ”´ [STREAMING] Assistant message ${message.id} marked as streaming=false, clearing streaming state for session ${sessionId}`);
                sessions = sessions.map(s => {
                  if (s.id === sessionId) {
                    // Calculate thinking time if we have a start time
                    let updatedAnalytics = s.analytics;
                    if (s.thinkingStartTime && updatedAnalytics) {
                      const thinkingDuration = Math.floor((Date.now() - s.thinkingStartTime) / 1000);
                      updatedAnalytics = {
                        ...updatedAnalytics,
                        thinkingTime: (updatedAnalytics.thinkingTime || 0) + thinkingDuration
                      };
                      console.log(`ðŸ“Š [THINKING TIME] Added ${thinkingDuration}s, total: ${updatedAnalytics.thinkingTime}s`);
                    }
                    console.log(`ðŸ”´ [STREAMING] Session ${sessionId} streaming state changed: ${s.streaming} -> false`);
                    return { ...s, streaming: false, thinkingStartTime: undefined, analytics: updatedAnalytics };
                  }
                  return s;
                });
                console.log(`ðŸ”´ [STREAMING] Successfully cleared streaming state for session ${sessionId}`);
              }
            }
            // If streaming is undefined, don't change the state
          
        if (message.type === 'error') {
              // Handle error messages - ALWAYS clear streaming and show to user
              console.log('[Store] Error message received:', message.error);
              sessions = sessions.map(s => {
                if (s.id === sessionId) {
                  // Calculate thinking time on error
                  let updatedAnalytics = s.analytics;
                  if (s.thinkingStartTime && updatedAnalytics) {
                    const thinkingDuration = Math.floor((Date.now() - s.thinkingStartTime) / 1000);
                    updatedAnalytics = {
                      ...updatedAnalytics,
                      thinkingTime: (updatedAnalytics.thinkingTime || 0) + thinkingDuration
                    };
                  }
                  // Add error as a system message so user sees it
                  const errorMessage = {
                    id: `error-${Date.now()}`,
                    type: 'system' as const,
                    subtype: 'error' as const,
                    message: { content: message.error || 'an error occurred' },
                    timestamp: Date.now()
                  };
                  return { 
                    ...s, 
                    streaming: false,
                    thinkingStartTime: undefined,
                    pendingToolIds: new Set(), // Clear pending tools on error
                    messages: [...s.messages, errorMessage],
                    analytics: updatedAnalytics
                  };
                }
                return s;
              });
              return { sessions };
            } else if (message.type === 'result') {
              // CRITICAL: Check for error result FIRST - handle session resume failures
              if (message.is_error || message.requiresCheckpointRestore) {
                console.log('[Store] âŒ ERROR RESULT - Session resume failed, clearing streaming state', {
                  is_error: message.is_error,
                  requiresCheckpointRestore: message.requiresCheckpointRestore,
                  error: message.error
                });
                
                sessions = sessions.map(s => {
                  if (s.id === sessionId) {
                    return {
                      ...s,
                      streaming: false,
                      thinkingStartTime: undefined,
                      runningBash: false,
                      userBashRunning: false,
                      claudeSessionId: undefined // Clear invalid session ID so next message creates new session
                    };
                  }
                  return s;
                });
                
                // Add info message about the error
                if (message.error) {
                  const infoMessage = {
                    id: `info-${Date.now()}`,
                    type: 'system' as const,
                    subtype: 'info' as const,
                    message: { content: 'session not found - will create new session' },
                    timestamp: Date.now()
                  };
                  sessions = sessions.map(s => 
                    s.id === sessionId 
                      ? { ...s, messages: [...s.messages, infoMessage] }
                      : s
                  );
                }
                
                return { sessions };
              }
              
              // Check if we have a recent user message (within last 3 seconds)
              // If so, this is likely a followup during streaming, so keep streaming state
              const session = sessions.find(s => s.id === sessionId);
              const recentUserMessage = session?.messages.findLast(m => 
                m.type === 'user' && 
                m.timestamp && 
                Date.now() - m.timestamp < 3000
              );
              
              if (recentUserMessage) {
                // This is a result from killing the process for a followup
                // Keep streaming state active
                console.log('Result message received but recent user message found - keeping streaming state for followup');
                sessions = sessions.map(s => 
                  s.id === sessionId 
                    ? { 
                        ...s, 
                        // Keep streaming true for followup
                        runningBash: false,
                        userBashRunning: false
                        // Keep claudeSessionId for resumption
                      } 
                    : s
                );
              } else if (session?.pendingToolIds && session.pendingToolIds.size > 0) {
                // Still have pending tools - keep streaming active
                console.log(`Result message received but ${session.pendingToolIds.size} tools still pending - keeping streaming state`);
                sessions = sessions.map(s => 
                  s.id === sessionId 
                    ? { 
                        ...s, 
                        // Keep streaming true while tools pending
                        runningBash: false,
                        userBashRunning: false
                      } 
                    : s
                );
              } else {
                // Normal result - clear streaming
                console.log('Received result message, clearing streaming state. Result details:', {
                  subtype: message.subtype,
                  is_error: message.is_error,
                  result: message.result,
                  sessionMessages: session?.messages.length || 0
                });
                
                // Never clear claudeSessionId - keep it for session resumption
                // Claude CLI handles session management, we just track the ID
                sessions = sessions.map(s => {
                  if (s.id === sessionId) {
                    // Calculate thinking time on result
                    let updatedAnalytics = s.analytics;
                    if (s.thinkingStartTime && updatedAnalytics) {
                      const thinkingDuration = Math.floor((Date.now() - s.thinkingStartTime) / 1000);
                      updatedAnalytics = {
                        ...updatedAnalytics,
                        thinkingTime: (updatedAnalytics.thinkingTime || 0) + thinkingDuration
                      };
                      console.log(`ðŸ“Š [THINKING TIME] Result - Added ${thinkingDuration}s, total: ${updatedAnalytics.thinkingTime}s`);
                    }
                    return { 
                      ...s, 
                      streaming: false,
                      thinkingStartTime: undefined,
                      runningBash: false,
                      userBashRunning: false,
                      analytics: updatedAnalytics
                      // Keep claudeSessionId for resumption
                    };
                  }
                  return s;
                });
              }
              
              return { sessions };
            } else if (message.type === 'system' && (message.subtype === 'interrupted' || message.subtype === 'error' || message.subtype === 'stream_end')) {
              // Check if we have a recent user message (within last 3 seconds)
              // If so, this is likely a followup during streaming, so keep streaming state
              const session = sessions.find(s => s.id === sessionId);
              const recentUserMessage = session?.messages.findLast(m => 
                m.type === 'user' && 
                m.timestamp && 
                Date.now() - m.timestamp < 3000
              );
              
              if (recentUserMessage && message.subtype === 'stream_end') {
                // This is a stream_end from killing the process for a followup
                // Keep streaming state active
                console.log('Stream end detected but recent user message found - keeping streaming state for followup');
                sessions = sessions.map(s => 
                  s.id === sessionId ? { ...s, runningBash: false, userBashRunning: false } : s
                );
              } else if (session?.pendingToolIds && session.pendingToolIds.size > 0) {
                // Still have pending tools - keep streaming active
                console.log(`Stream end but ${session.pendingToolIds.size} tools still pending - keeping streaming state`);
                sessions = sessions.map(s => 
                  s.id === sessionId ? { ...s, runningBash: false, userBashRunning: false } : s
                );
              } else {
                // Clear streaming and bash running on interruption or error
                console.log('System message received, clearing streaming and bash state');
                sessions = sessions.map(s => {
                  if (s.id === sessionId) {
                    // Calculate thinking time on stream end
                    let updatedAnalytics = s.analytics;
                    if (s.thinkingStartTime && updatedAnalytics) {
                      const thinkingDuration = Math.floor((Date.now() - s.thinkingStartTime) / 1000);
                      updatedAnalytics = {
                        ...updatedAnalytics,
                        thinkingTime: (updatedAnalytics.thinkingTime || 0) + thinkingDuration
                      };
                      console.log(`ðŸ“Š [THINKING TIME] Stream end - Added ${thinkingDuration}s, total: ${updatedAnalytics.thinkingTime}s`);
                    }
                    return { ...s, streaming: false, thinkingStartTime: undefined, runningBash: false, userBashRunning: false, analytics: updatedAnalytics };
                  }
                  return s;
                });
              }
              return { sessions };
            } else if (message.type === 'tool_use') {
              // When we get a tool_use message, ensure streaming is active
              // This handles cases where tools are running (especially Task/agent tools)
              console.log('Tool use message received, ensuring streaming state is active');
              
              // Track if this is a Bash command
              const isBash = message.message?.name === 'Bash';
              if (isBash) {
                console.log('ðŸ–¥ï¸ Bash command started');
              }
              
              // Add tool ID to pending set
              const toolId = message.message?.id;
              sessions = sessions.map(s => {
                if (s.id === sessionId) {
                  const pendingTools = new Set(s.pendingToolIds || []);
                  if (toolId) {
                    pendingTools.add(toolId);
                    console.log(`[Store] Added tool ${toolId} to pending. Total pending: ${pendingTools.size}`);
                  }
                  return { 
                    ...s, 
                    streaming: true,
                    runningBash: isBash ? true : s.runningBash,
                    pendingToolIds: pendingTools
                  };
                }
                return s;
              });
            } else if (message.type === 'tool_result') {
              // Keep streaming active for tool results as more tools may follow
              // The streaming state will be cleared by the result message
              
              // Remove tool ID from pending set
              const toolUseId = message.message?.tool_use_id;
              sessions = sessions.map(s => {
                if (s.id === sessionId) {
                  const pendingTools = new Set(s.pendingToolIds || []);
                  if (toolUseId && pendingTools.has(toolUseId)) {
                    pendingTools.delete(toolUseId);
                    console.log(`[Store] Removed tool ${toolUseId} from pending. Remaining: ${pendingTools.size}`);
                  }
                  return { 
                    ...s, 
                    runningBash: false,
                    pendingToolIds: pendingTools
                  };
                }
                return s;
              });
            }
            
            persistSessions(sessions); // Persist after any message update
            return { sessions };
          });
      });
      
      // Combined cleanup function
      const cleanup = () => {
        messageCleanup();
        titleCleanup();
        errorCleanup();
      };
      
      // Store cleanup function (could be used later)
      (activeSession as any).cleanup = cleanup;
      
        return sessionId;
      } catch (error) {
        // If Claude SDK initialization fails, update tab to error status
        console.error('Failed to initialize Claude SDK session:', error);
        set(state => ({
          sessions: state.sessions.map(s => 
            s.id === tempSessionId 
              ? { ...s, status: 'error' as const, updatedAt: new Date() }
              : s
          )
        }));
        throw error;
      }
    } catch (error) {
      console.error('Failed to create session:', error);
      throw error;
    }
  },
  
  setCurrentSession: async (sessionId: string) => {
    const state = get();
    const { currentSessionId: oldSessionId } = state;
    
    // Don't do anything if we're already on this session
    if (oldSessionId === sessionId) {
      console.log('[Store] Already on session:', sessionId);
      return;
    }
    
    console.log('[Store] Switching session from', oldSessionId, 'to', sessionId);
    
    // Check if this session needs to be resumed (has claudeSessionId but not connected)
    const session = state.sessions.find(s => s.id === sessionId);
    if (session) {
      const mapping = state.sessionMappings[sessionId];
      const claudeSessionId = session.claudeSessionId || mapping?.claudeSessionId;
      
      if (claudeSessionId) {
        console.log(`[Store] Session ${sessionId} has claudeSessionId ${claudeSessionId}, checking if needs resumption`);
        
        // Try to resume the session with the server
        try {
          const result = await claudeCodeClient.createSession(
            session.name,
            session.workingDirectory || '/',
            {
              sessionId: sessionId,
              claudeSessionId: claudeSessionId,
              messages: session.messages || [],
              hasGeneratedTitle: session.claudeTitle ? true : false
            }
          );
          
          console.log(`[Store] Session ${sessionId} resumed successfully`);
          
          // Update session with claudeSessionId if it wasn't already set
          if (!session.claudeSessionId) {
            set(state => ({
              sessions: state.sessions.map(s => 
                s.id === sessionId 
                  ? { ...s, claudeSessionId: claudeSessionId }
                  : s
              )
            }));
          }
        } catch (error) {
          console.error(`[Store] Failed to resume session ${sessionId}:`, error);
          // Continue anyway, session exists locally
        }
      }
    }
    
    // Don't clear streaming state when switching tabs - let it persist
    // The streaming state will be cleared when the actual response finishes
    
    // Update the current session
    set({ currentSessionId: sessionId });
    localStorage.setItem('yurucode-current-session', sessionId);
  },
  
  sendMessage: async (content: string, bashMode?: boolean) => {
    const { currentSessionId } = get();
    console.log('[Store] sendMessage called:', { 
      sessionId: currentSessionId,
      contentLength: content?.length,
      contentType: typeof content
    });
    
    if (!currentSessionId) {
      console.error('[Store] Cannot send message: No active session');
      return;
    }
    
    // Don't add empty messages
    if (!content || (typeof content === 'string' && !content.trim())) {
      console.warn('[Store] Cannot send empty message');
      return;
    }
    
    // Wait for session to be active if it's pending
    let sessionToUse = currentSessionId;
    const currentSession = get().sessions.find(s => s.id === currentSessionId);
    if (currentSession?.status === 'pending') {
      console.log('[Store] Session is pending, waiting for activation...');
      // Wait up to 5 seconds for session to become active
      let retries = 50;
      while (retries > 0) {
        await new Promise(resolve => setTimeout(resolve, 100));
        // Check if currentSessionId has been updated (temp replaced with real)
        const newSessionId = get().currentSessionId;
        const session = get().sessions.find(s => s.id === newSessionId);
        if (session?.status === 'active') {
          console.log('[Store] Session is now active, proceeding with message');
          sessionToUse = newSessionId;
          break;
        }
        retries--;
      }
      const finalSession = get().sessions.find(s => s.id === get().currentSessionId);
      if (finalSession?.status !== 'active') {
        console.error('[Store] Session failed to activate after waiting');
        return;
      }
      sessionToUse = get().currentSessionId;
    }
    
    // Add user message immediately with unique ID
    const userMessage = {
      id: `user-${Date.now()}-${Math.random()}`,
      type: 'user',
      message: { content },
      timestamp: Date.now(),
      bashMode: bashMode || false
    };
    
    console.log('[Store] Adding user message to session:', userMessage.id);
    
    // Only set streaming to true if it's not already streaming
    // This prevents the thinking indicator from disappearing when sending followup messages
    // START THINKING TIME when user sends a message
    const now = Date.now();
    set(state => ({
      sessions: state.sessions.map(s => {
        if (s.id === sessionToUse) {
          // When already streaming (followup during active response), preserve streaming state
          // When not streaming (new conversation), set streaming to true
          const wasStreaming = s.streaming;
          console.log('[Store] Current streaming state:', wasStreaming, 'Preserving during followup:', wasStreaming);
          console.log(`[THINKING TIME] Starting thinking timer at ${now} when user sends message`);
          
          const updates: any = { 
            messages: [...s.messages, userMessage]
          };
          
          // Handle thinking time accumulation
          let updatedAnalytics = s.analytics;
          if (wasStreaming && s.thinkingStartTime && updatedAnalytics) {
            // If already streaming, accumulate the previous thinking time before starting new timer
            const previousThinkingDuration = Math.floor((now - s.thinkingStartTime) / 1000);
            updatedAnalytics = {
              ...updatedAnalytics,
              thinkingTime: (updatedAnalytics.thinkingTime || 0) + previousThinkingDuration
            };
            console.log(`ðŸ“Š [THINKING TIME] Accumulated ${previousThinkingDuration}s from followup, total: ${updatedAnalytics.thinkingTime}s`);
          }
          
          // Always start new thinking timer when user sends message
          updates.thinkingStartTime = now;
          updates.analytics = updatedAnalytics;
          
          // Only set streaming to true if we're not already streaming
          // This prevents flickering the thinking indicator during followups
          if (!wasStreaming) {
            updates.streaming = true;
          }
          
          return { ...s, ...updates };
        }
        return s;
      })
    }));
    
    try {
      // Send message to Claude Code Server (REAL SDK) with selected model
      const { selectedModel } = get();
      console.log('[Store] Sending to Claude with model:', selectedModel, 'sessionId:', sessionToUse);
      await claudeCodeClient.sendMessage(sessionToUse, content, selectedModel);
      
      // Messages are handled by the onMessage listener
      // The streaming state will be cleared when we receive the result message
      console.log('[Store] Message sent successfully, waiting for response...');
    } catch (error) {
      console.error('[Store] Error sending message:', error);
      
      // Add error message to chat
      set(state => ({
        sessions: state.sessions.map(s => 
          s.id === sessionToUse 
            ? { 
                ...s, 
                messages: [...s.messages, {
                  type: 'system',
                  subtype: 'error',
                  message: `Failed to send message: ${error.message}`,
                  timestamp: Date.now()
                }]
              }
            : s
        )
      }));
    }
  },
  
  resumeSession: async (sessionId: string) => {
    const state = get();
    const session = state.sessions.find(s => s.id === sessionId);
    if (!session) {
      // Try to load from server if not in local state
      await get().loadPersistedSession(sessionId);
      return;
    }
    
    // Check if we need to reconnect to server (after app restart)
    // Look for claudeSessionId in session mappings or in session itself
    const mapping = state.sessionMappings[sessionId];
    const claudeSessionId = session.claudeSessionId || mapping?.claudeSessionId;
    
    if (claudeSessionId && !session.claudeSessionId) {
      console.log(`[Store] Reconnecting session ${sessionId} with claudeSessionId ${claudeSessionId}`);
      
      // Need to call createSession with the claudeSessionId to resume
      try {
        const result = await claudeCodeClient.createSession(
          session.name, 
          session.workingDirectory || '/',
          {
            sessionId: sessionId,
            claudeSessionId: claudeSessionId,
            messages: session.messages || [],
            hasGeneratedTitle: session.claudeTitle ? true : false
          }
        );
        
        // Update session with claudeSessionId
        set(state => ({
          sessions: state.sessions.map(s => 
            s.id === sessionId 
              ? { ...s, claudeSessionId: mapping.claudeSessionId }
              : s
          )
        }));
        
        console.log(`[Store] Successfully reconnected session ${sessionId}`);
      } catch (error) {
        console.error(`[Store] Failed to reconnect session ${sessionId}:`, error);
        // Continue anyway, will create new session on first message
      }
    }
    
    // Use setCurrentSession to properly handle session switching
    get().setCurrentSession(sessionId);
    set({ persistedSessionId: sessionId });
    
    // Notify server of directory change if needed
    if (session.workingDirectory) {
      await claudeCodeClient.setWorkingDirectory(sessionId, session.workingDirectory);
    }
  },
  
  reconnectSession: (sessionId: string, claudeSessionId: string) => {
    // Set up message listeners for a restored session
    // This doesn't create a new claude process, just reconnects the message handlers
    console.log(`[Store] Reconnecting session ${sessionId} with claudeSessionId ${claudeSessionId}`);
    
    // Listen for title updates
    const titleCleanup = claudeCodeClient.onTitle(sessionId, (title: string) => {
      console.log('[Store] Received title for reconnected session:', sessionId, title);
      set(state => ({
        sessions: state.sessions.map(s => 
          s.id === sessionId && !s.userRenamed
            ? { ...s, claudeTitle: title } 
            : s
        )
      }));
    });
    
    // Set up error handler for resumed session
    const errorCleanup = claudeCodeClient.onError(sessionId, (error) => {
      console.error('[Store] Error received for resumed session:', sessionId, error);
      
      set(state => ({
        ...state,
        sessions: state.sessions.map(s => 
          s.id === sessionId 
            ? {
                ...s,
                messages: [...s.messages, {
                  id: `error-${Date.now()}`,
                  type: 'error',
                  content: error.message,
                  timestamp: error.timestamp || Date.now(),
                  errorType: error.type
                }],
                streaming: false,
                status: 'active' as const
              }
            : s
        )
      }));
    });
    
    // Listen for messages
    const messageCleanup = claudeCodeClient.onMessage(sessionId, (message) => {
      // Use the same message handler logic as createSession
      set(state => {
        let sessions = state.sessions.map(s => {
          if (s.id !== sessionId) return s;
          
          // Update status to active once we receive a message
          if (s.status === 'paused') {
            s = { ...s, status: 'active' as const };
          }
          
          const existingMessages = [...s.messages];
          
          // Skip user messages from server
          if (message.type === 'user') {
            console.warn('[Store] Ignoring user message from server');
            return s;
          }
          
          // Handle message updates
          if (message.id) {
            const existingIndex = existingMessages.findIndex(m => m.id === message.id);
            if (existingIndex >= 0) {
              existingMessages[existingIndex] = message;
            } else {
              existingMessages.push(message);
            }
          } else {
            const isDuplicate = existingMessages.some(m => 
              m.type === message.type && 
              JSON.stringify(m.message) === JSON.stringify(message.message)
            );
            if (!isDuplicate) {
              existingMessages.push(message);
            }
          }
          
          return { 
            ...s, 
            messages: existingMessages, 
            updatedAt: new Date()
          };
        });
        
        // Handle streaming state
        if (message.type === 'assistant') {
          sessions = sessions.map(s => 
            s.id === sessionId ? { ...s, streaming: message.streaming || false } : s
          );
        } else if (message.type === 'result' || 
                   (message.type === 'system' && (message.subtype === 'interrupted' || message.subtype === 'error'))) {
          sessions = sessions.map(s => 
            s.id === sessionId ? { ...s, streaming: false, runningBash: false, userBashRunning: false } : s
          );
        }
        
        persistSessions(sessions); // Persist any changes
        return { sessions };
      });
    });
    
    // Store cleanup function
    const session = get().sessions.find(s => s.id === sessionId);
    if (session) {
      (session as any).cleanup = () => {
        messageCleanup();
        titleCleanup();
        errorCleanup();
      };
    }
  },
  
  loadSessionHistory: async (sessionId: string) => {
    set({ isLoadingHistory: true });
    try {
      const history = await claudeCodeClient.getSessionHistory(sessionId);
      if (history.messages) {
        set(state => ({
          sessions: state.sessions.map(s => 
            s.id === sessionId 
              ? { ...s, messages: history.messages, updatedAt: new Date() }
              : s
          ),
          isLoadingHistory: false
        }));
      }
    } catch (error) {
      console.error('Failed to load session history:', error);
      set({ isLoadingHistory: false });
    }
  },
  
  listAvailableSessions: async () => {
    try {
      const sessions = await claudeCodeClient.listSessions();
      set({ availableSessions: sessions });
    } catch (error) {
      console.error('Failed to list sessions:', error);
    }
  },
  
  loadPersistedSession: async (sessionId: string) => {
    set({ isLoadingHistory: true });
    try {
      // Get home directory for resumed session
      let workingDirectory = '/';
      if (window.__TAURI__) {
        try {
          const { invoke } = await import('@tauri-apps/api/core');
          workingDirectory = await invoke<string>('get_home_directory');
        } catch (err) {
          const isWindows = navigator.platform.toLowerCase().includes('win');
          workingDirectory = isWindows ? 'C:\\Users\\' : '/Users';
        }
      }
      
      // CRITICAL FIX: Check for stored claudeSessionId in mappings
      const state = get();
      const mapping = state.sessionMappings[sessionId];
      const claudeSessionId = mapping?.claudeSessionId || null;
      
      if (claudeSessionId) {
        console.log(`[Store] Resuming session ${sessionId} with stored claudeSessionId: ${claudeSessionId}`);
      }
      
      // Create/resume session with existing ID and claudeSessionId
      const result = await claudeCodeClient.createSession('resumed session', workingDirectory, {
        sessionId,
        claudeSessionId,
        messages: [] // Will be populated from server if session exists
      });
      
      const messages = result.messages || [];
      workingDirectory = result.workingDirectory || workingDirectory;
      
      const session: Session = {
        id: sessionId,
        name: `resumed session`,
        status: 'active' as const,
        messages,
        workingDirectory,
        createdAt: new Date(),
        updatedAt: new Date(),
        // Initialize fresh analytics for resumed session
        analytics: {
          totalMessages: 0,
          userMessages: 0,
          assistantMessages: 0,
          toolUses: 0,
          tokens: { 
            input: 0, 
            output: 0, 
            total: 0,
            byModel: {
              opus: { input: 0, output: 0, total: 0 },
              sonnet: { input: 0, output: 0, total: 0 }
            }
          },
          cost: { total: 0, byModel: { opus: 0, sonnet: 0 } },
          duration: 0,
          lastActivity: new Date(),
          thinkingTime: 0
        }
      };
      
      // Listen for title updates
      const titleCleanup = claudeCodeClient.onTitle(sessionId, (title: string) => {
        console.log('[Store] Received title for resumed session:', sessionId, title);
        set(state => ({
          sessions: state.sessions.map(s => 
            // Only update title if user hasn't manually renamed
            s.id === sessionId && !s.userRenamed ? { ...s, claudeTitle: title } : s
          )
        }));
      });
      
      // Set up error handler for loaded session
      const errorCleanup = claudeCodeClient.onError(sessionId, (error) => {
        console.error('[Store] Error received for loaded session:', sessionId, error);
        
        set(state => ({
          ...state,
          sessions: state.sessions.map(s => 
            s.id === sessionId 
              ? {
                  ...s,
                  messages: [...s.messages, {
                    id: `error-${Date.now()}`,
                    type: 'error',
                    content: error.message,
                    timestamp: error.timestamp || Date.now(),
                    errorType: error.type
                  }],
                  streaming: false
                }
              : s
          )
        }));
      });
      
      // Set up message listener
      const messageCleanup = claudeCodeClient.onMessage(sessionId, (message) => {
        set(state => {
          let sessions = state.sessions.map(s => {
            if (s.id !== sessionId) return s;
            
            const existingMessages = [...s.messages];
            
            if (message.type === 'user') {
              console.warn('Ignoring user message from server');
              return s;
            }
            
            if (message.id) {
              const existingIndex = existingMessages.findIndex(m => m.id === message.id);
              if (existingIndex >= 0) {
                existingMessages[existingIndex] = message;
              } else {
                existingMessages.push(message);
              }
            } else {
              const isDuplicate = existingMessages.some(m => 
                m.type === message.type && 
                JSON.stringify(m.message) === JSON.stringify(message.message)
              );
              if (!isDuplicate) {
                existingMessages.push(message);
              }
            }
            
            // Extract title from first assistant message
            if (message.type === 'assistant' && s.claudeTitle === 'new session' && message.message?.content) {
              const content = typeof message.message.content === 'string' 
                ? message.message.content 
                : '';
              console.log('[Title] Assistant message received, extracting title from:', content.substring(0, 100));
              
              if (content && content.length > 3) {
                // Take first line, remove emojis, max 50 chars
                let title = content.split('\n')[0]
                  .replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '')
                  .replace(/^\W+/, '')
                  .replace(/\s+/g, ' ')
                  .trim()
                  .substring(0, 50);
                
                if (title && title.length > 3) {
                  s.claudeTitle = title.toLowerCase();
                  console.log('[Title] Updated session title to:', s.claudeTitle);
                }
              }
            }
            
            return { ...s, messages: existingMessages, updatedAt: new Date() };
          });
          
          if (message.type === 'assistant') {
            // Extract title from first assistant message if not already set
            sessions = sessions.map(s => {
              if (s.id === sessionId) {
                let updates: any = { streaming: message.streaming || false };
                
                // Extract title from first assistant message
                if (!s.claudeTitle && message.message?.content) {
                  const content = typeof message.message.content === 'string' 
                    ? message.message.content 
                    : '';
                  console.log('[Title] Checking for title extraction:', { 
                    hasContent: !!content, 
                    contentPreview: content.substring(0, 100),
                    sessionId 
                  });
                  if (content) {
                    // Extract first line or sentence as title (max 60 chars)
                    const firstLine = content.split('\n')[0].trim();
                    let title = firstLine;
                    
                    // Find end of first sentence
                    const periodIndex = firstLine.indexOf('.');
                    const exclamIndex = firstLine.indexOf('!');
                    const colonIndex = firstLine.indexOf(':');
                    
                    const endIndex = Math.min(
                      ...[periodIndex, exclamIndex, colonIndex, 60].filter(i => i > 0)
                    );
                    
                    if (endIndex < firstLine.length) {
                      title = firstLine.substring(0, endIndex);
                    }
                    
                    // Remove emojis and special characters
                    title = title
                      .replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '')
                      .replace(/^\W+/, '') // Remove leading non-word chars
                      .replace(/\s+/g, ' ')
                      .trim()
                      .substring(0, 50); // Max 50 chars for tab
                    
                    if (title && title.length > 3) {
                      updates.claudeTitle = title.toLowerCase(); // Keep lowercase
                      console.log('[Title] Extracted title:', updates.claudeTitle);
                    }
                  }
                }
                
                return { ...s, ...updates };
              }
              return s;
            });
          } else if (message.type === 'result' || 
                     (message.type === 'system' && (message.subtype === 'interrupted' || message.subtype === 'error'))) {
            sessions = sessions.map(s => 
              s.id === sessionId ? { ...s, streaming: false, runningBash: false, userBashRunning: false } : s
            );
          }
          
          return { sessions };
        });
      });
      
      // Combined cleanup function
      const cleanup = () => {
        messageCleanup();
        titleCleanup();
        errorCleanup();
      };
      
      (session as any).cleanup = cleanup;
      
      set(state => ({
        sessions: [...state.sessions.filter(s => s.id !== sessionId), session],
        currentSessionId: sessionId,
        persistedSessionId: sessionId,
        isLoadingHistory: false
      }));
    } catch (error) {
      console.error('Failed to load persisted session:', error);
      set({ isLoadingHistory: false });
    }
  },
  
  pauseSession: (sessionId: string) => {
    // Update local state
    set(state => ({
      sessions: state.sessions.map(s => 
        s.id === sessionId ? { ...s, status: 'paused' as const } : s
      )
    }));
  },
  
  deleteSession: (sessionId: string) => {
    // Clean up any listeners
    const session = get().sessions.find(s => s.id === sessionId);
    if ((session as any)?.cleanup) {
      (session as any).cleanup();
    }
    set(state => {
      const newSessions = state.sessions.filter(s => s.id !== sessionId);
      let newCurrentId = state.currentSessionId;
      
      // If we're deleting the current session, switch to another one
      if (state.currentSessionId === sessionId) {
        if (newSessions.length > 0) {
          // Find the index of the deleted session
          const deletedIndex = state.sessions.findIndex(s => s.id === sessionId);
          // Try to switch to the session at the same index, or the last one
          const newIndex = Math.min(deletedIndex, newSessions.length - 1);
          newCurrentId = newSessions[newIndex]?.id || null;
        } else {
          newCurrentId = null;
        }
      }
      
      persistSessions(newSessions); // Persist after deletion
      if (newCurrentId) {
        localStorage.setItem('yurucode-current-session', newCurrentId);
      } else {
        localStorage.removeItem('yurucode-current-session');
      }
      return {
        sessions: newSessions,
        currentSessionId: newCurrentId
      };
    });
  },
  
  deleteAllSessions: () => {
    // Clean up all listeners
    const sessions = get().sessions;
    sessions.forEach(session => {
      if ((session as any)?.cleanup) {
        (session as any).cleanup();
      }
    });
    set({
      sessions: [],
      currentSessionId: null,
      streamingMessage: ''
    });
    localStorage.removeItem('yurucode-sessions');
    localStorage.removeItem('yurucode-current-session');
  },
  
  reorderSessions: (fromIndex: number, toIndex: number) => {
    set(state => {
      const newSessions = [...state.sessions];
      const [movedSession] = newSessions.splice(fromIndex, 1);
      newSessions.splice(toIndex, 0, movedSession);
      return { sessions: newSessions };
    });
  },
  
  renameSession: (sessionId: string, newTitle: string) => {
    set(state => ({
      sessions: state.sessions.map(s => 
        s.id === sessionId 
          ? { 
              ...s, 
              claudeTitle: newTitle.trim().toLowerCase(),
              userRenamed: true // Mark as user renamed to skip auto title
            } 
          : s
      )
    }));
    
    // Save title to localStorage for persistence
    const state = get();
    const session = state.sessions.find(s => s.id === sessionId);
    if (session && session.claudeSessionId) {
      localStorage.setItem(`session-title-${session.claudeSessionId}`, newTitle.trim().toLowerCase());
    }
    
    // Update the session mapping with new name
    if (session && session.claudeSessionId) {
      state.updateSessionMapping(sessionId, session.claudeSessionId, {
        name: newTitle.trim().toLowerCase(),
        projectPath: session.workingDirectory
      });
    }
    
    console.log('[Store] Session renamed:', sessionId, newTitle);
  },
  
  interruptSession: async () => {
    const { currentSessionId, sessions } = get();
    const currentSession = sessions.find(s => s.id === currentSessionId);
    
    // Only interrupt if actually streaming
    if (currentSessionId && currentSession?.streaming) {
      // Immediately set streaming and runningBash to false to prevent double calls
      set(state => ({
        sessions: state.sessions.map(s => {
          if (s.id === currentSessionId) {
            // Calculate thinking time before clearing streaming state
            let updatedAnalytics = s.analytics;
            if (s.thinkingStartTime && updatedAnalytics) {
              const thinkingDuration = Math.floor((Date.now() - s.thinkingStartTime) / 1000);
              updatedAnalytics = {
                ...updatedAnalytics,
                thinkingTime: (updatedAnalytics.thinkingTime || 0) + thinkingDuration
              };
              console.log(`ðŸ“Š [THINKING TIME] Interrupt - Added ${thinkingDuration}s, total: ${updatedAnalytics.thinkingTime}s`);
            }
            
            return { 
              ...s, 
              streaming: false, 
              runningBash: false, 
              userBashRunning: false,
              thinkingStartTime: undefined,
              pendingToolIds: new Set(), // Clear pending tools on interrupt
              analytics: updatedAnalytics
            };
          }
          return s;
        })
      }));
      
      try {
        await claudeCodeClient.interrupt(currentSessionId);
        
        // Don't add interrupt message here - server already sends it
        set(state => ({
          sessions: state.sessions.map(s => 
            s.id === currentSessionId 
              ? { 
                  ...s, 
                  claudeSessionId: undefined // Clear Claude session ID after interrupt
                } 
              : s
          ),
          streamingMessage: ''
        }));
      } catch (error) {
        console.error('Failed to interrupt session:', error);
        // Still stop streaming indicator even if interrupt fails
        set(state => ({
          sessions: state.sessions.map(s => {
            if (s.id === currentSessionId) {
              // Calculate thinking time even if interrupt fails
              let updatedAnalytics = s.analytics;
              if (s.thinkingStartTime && updatedAnalytics) {
                const thinkingDuration = Math.floor((Date.now() - s.thinkingStartTime) / 1000);
                updatedAnalytics = {
                  ...updatedAnalytics,
                  thinkingTime: (updatedAnalytics.thinkingTime || 0) + thinkingDuration
                };
                console.log(`ðŸ“Š [THINKING TIME] Interrupt failed - Added ${thinkingDuration}s, total: ${updatedAnalytics.thinkingTime}s`);
              }
              return { 
                ...s, 
                streaming: false, 
                thinkingStartTime: undefined,
                analytics: updatedAnalytics
              };
            }
            return s;
          }),
          streamingMessage: ''
        }));
      }
    }
  },
  
  clearContext: async (sessionId: string) => {
    console.log(`ðŸ§¹ [Store] clearContext called for session ${sessionId}`);
    
    // First interrupt streaming if active
    const state = get();
    const session = state.sessions.find(s => s.id === sessionId);
    if (session?.streaming) {
      console.log(`ðŸ§¹ [Store] Session is streaming, interrupting first`);
      await state.interruptSession();
    }
    
    // Clear local messages and reset analytics
    set(state => {
      const session = state.sessions.find(s => s.id === sessionId);
      if (session) {
        console.log(`ðŸ§¹ [Store] Current analytics before clear:`, session.analytics);
        console.log(`ðŸ§¹ [Store] Current messages count: ${session.messages.length}`);
        console.log(`ðŸ§¹ [Store] Current claudeSessionId: ${session.claudeSessionId}`);
      }
      
      // Find the session index to maintain tab number
      const sessionIndex = state.sessions.findIndex(s => s.id === sessionId);
      const tabNumber = sessionIndex !== -1 ? sessionIndex + 1 : 1;
      
      return {
        sessions: state.sessions.map(s => 
          s.id === sessionId 
            ? { 
                ...s, 
                messages: [], // Clear ALL messages - don't keep any
                claudeSessionId: undefined, // Clear Claude session to start fresh
                claudeTitle: `tab ${tabNumber}`, // Reset title to 'tab x' format
                pendingToolIds: new Set(), // Clear pending tools
                streaming: false, // Stop streaming
              analytics: {
                totalMessages: 0,
                userMessages: 0,
                assistantMessages: 0,
                toolUses: 0,
                tokens: { 
                  input: 0, 
                  output: 0, 
                  total: 0,
                  byModel: {
                    opus: { input: 0, output: 0, total: 0 },
                    sonnet: { input: 0, output: 0, total: 0 }
                  }
                },
                cost: { total: 0, byModel: { opus: 0, sonnet: 0 } },
                duration: 0,
                lastActivity: new Date(),
                thinkingTime: 0
              },
              updatedAt: new Date()
            }
          : s
        )
      };
    });
    
    // Log the result
    set(state => {
      const session = state.sessions.find(s => s.id === sessionId);
      if (session) {
        console.log(`ðŸ§¹ [Store] After clear - analytics:`, session.analytics);
        console.log(`ðŸ§¹ [Store] After clear - messages count: ${session.messages.length}`);
        console.log(`ðŸ§¹ [Store] After clear - claudeSessionId: ${session.claudeSessionId}`);
      }
      return state;
    });
    
    // Notify server to clear the Claude session - use the imported singleton
    claudeCodeClient.clearSession(sessionId).catch(error => {
      console.error('Failed to clear server session:', error);
    });
  },
  
  updateSessionDraft: (sessionId: string, input: string, attachments: any[]) => {
    set(state => ({
      sessions: state.sessions.map(s => 
        s.id === sessionId 
          ? { 
              ...s, 
              draftInput: input,
              draftAttachments: attachments
            }
          : s
      )
    }));
  },
  
  toggleModel: () => {
    const currentModel = get().selectedModel;
    const newModel = currentModel.includes('opus') ? 
      'claude-sonnet-4-20250514' : 
      'claude-opus-4-1-20250805';
    set({ selectedModel: newModel });
    console.log(`ðŸ”„ Model toggled to: ${newModel.includes('opus') ? 'Opus 4.1' : 'Sonnet 4.0'}`);
  },

  addMessageToSession: (sessionId: string, message: SDKMessage) => {
    set(state => ({
      sessions: state.sessions.map(s => 
        s.id === sessionId 
          ? { ...s, messages: [...s.messages, message], updatedAt: new Date() }
          : s
      )
    }));
  },

  restoreToMessage: (sessionId: string, messageIndex: number) => {
    set(state => {
      let sessions = [...state.sessions];
      const sessionIdx = sessions.findIndex(s => s.id === sessionId);
      if (sessionIdx !== -1) {
        const session = sessions[sessionIdx];
        // Keep only messages up to and including the specified index
        const restoredMessages = session.messages.slice(0, messageIndex + 1);
        
        // Reset session to continue from this point
        sessions[sessionIdx] = {
          ...session,
          messages: restoredMessages,
          claudeSessionId: undefined, // Clear Claude session to start fresh
          streaming: false,
          updatedAt: new Date(),
          // Reset analytics to reflect only the kept messages
          analytics: {
            ...session.analytics,
            totalMessages: restoredMessages.length,
            userMessages: restoredMessages.filter(m => m.role === 'user').length,
            assistantMessages: restoredMessages.filter(m => m.role === 'assistant').length,
            // Keep existing token counts as they reflect actual usage
            tokens: session.analytics?.tokens || {
              input: 0,
              output: 0,
              total: 0,
              byModel: {
                opus: { input: 0, output: 0, total: 0 },
                sonnet: { input: 0, output: 0, total: 0 }
              }
            },
            cost: session.analytics?.cost || { total: 0, byModel: { opus: 0, sonnet: 0 } },
            lastActivity: new Date(),
            thinkingTime: session.analytics?.thinkingTime || 0
          }
        };
        
        // Notify server to clear the Claude session
        claudeCodeClient.clearSession(sessionId);
        
        console.log(`Restored session ${sessionId} to message ${messageIndex}`);
      }
      return { sessions };
    });
  },
  
  configureMcpServers: async (servers: any) => {
    // MCP configuration would go here
    console.log('MCP servers:', servers);
  },
  
  setPermissionMode: (mode) => {
    // Permission mode would be set here
    console.log('Permission mode:', mode);
  },
  
  updateAllowedTools: (tools) => {
    // Tool allowlist would be updated here
    console.log('Allowed tools:', tools);
  },
  
  setGlobalWatermark: (image: string | null) => {
    set({ globalWatermarkImage: image });
  },

  updateSessionMapping: (sessionId: string, claudeSessionId: string, metadata?: any) => {
    const state = get();
    const mappings = { ...state.sessionMappings };
    
    mappings[sessionId] = {
      claudeSessionId,
      ...metadata,
      updatedAt: Date.now()
    };
    
    set({ sessionMappings: mappings });
    
    // Save to localStorage
    localStorage.setItem('yurucode-session-mappings', JSON.stringify(mappings));
    
    // Update server with the mapping
    claudeCodeClient.updateSessionMetadata(sessionId, { 
      claudeSessionId,
      ...metadata 
    }).catch(err => {
      console.error('Failed to update session metadata on server:', err);
    });
    
    console.log('[Store] Updated session mapping:', sessionId, '->', claudeSessionId);
  },

  loadSessionMappings: () => {
    try {
      const stored = localStorage.getItem('yurucode-session-mappings');
      if (stored) {
        const mappings = JSON.parse(stored);
        set({ sessionMappings: mappings });
        console.log('[Store] Loaded session mappings:', Object.keys(mappings).length);
      }
    } catch (err) {
      console.error('Failed to load session mappings:', err);
    }
  },

  saveSessionMappings: () => {
    const state = get();
    localStorage.setItem('yurucode-session-mappings', JSON.stringify(state.sessionMappings));
    console.log('[Store] Saved session mappings:', Object.keys(state.sessionMappings).length);
  }
}),
    {
      name: 'claude-code-storage',
      partialize: (state) => ({
        // Only persist model selection and watermark - sessions should be ephemeral
        selectedModel: state.selectedModel,
        globalWatermarkImage: state.globalWatermarkImage
        // Do NOT persist sessionId - sessions should not survive app restarts
      })
    }
  )
);