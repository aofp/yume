import React, { useState, useEffect } from 'react';
import { 
  IconPlayerPlay,
  IconPlus,
  IconTrash,
  IconEdit,
  IconX,
  IconCheck,
  IconRotateClockwise
} from '@tabler/icons-react';
import { hooksService } from '../../services/hooksService';
import { invoke } from '@tauri-apps/api/core';
import { YURUCODE_HOOKS } from './hooks-data';

interface HooksTabProps {
  selectedHooks: any;
  setSelectedHooks: (hooks: any) => void;
  hookScripts: any;
  setHookScripts: (scripts: any) => void;
}

export const HooksTab: React.FC<HooksTabProps> = ({
  selectedHooks,
  setSelectedHooks,
  hookScripts,
  setHookScripts
}) => {
  const [customHooks, setCustomHooks] = useState<any[]>([]);
import os
import re
from pathlib import Path

try:
    input_data = json.load(sys.stdin)
    prompt = input_data.get('data', {}).get('prompt', '')
    session_id = input_data.get('sessionId', '')
    
    # Load configuration and state
    config_path = Path.home() / '.yurucode' / 'hooks' / 'config.json'
    state_path = Path.home() / '.yurucode' / 'hooks' / 'state.json'
    
    enhanced_prompt = prompt
    additions = []
    
    # Add context from previous decisions
    if state_path.exists():
        try:
            with open(state_path, 'r') as f:
                state = json.load(f)
                recent_blocks = [d for d in state.get('decisions', [])[-5:] 
                                if d['action'] == 'block']
                if recent_blocks:
                    additions.append("Recent blocked actions:")
                    for block in recent_blocks:
                        additions.append(f"- {block['reason']}")
        except:
            pass
    
    # Detect intent and add appropriate context
    if re.search(r'\b(implement|create|build|write|add)\b', prompt.lower()):
        additions.append("Follow existing code patterns and conventions in this codebase.")
        additions.append("Check for existing similar implementations before creating new ones.")
    
    if re.search(r'\b(fix|debug|error|bug)\b', prompt.lower()):
        additions.append("First identify the root cause before implementing fixes.")
        additions.append("Consider edge cases and test thoroughly.")
    
    if re.search(r'\b(refactor|optimize|improve)\b', prompt.lower()):
        additions.append("Ensure backward compatibility.")
        additions.append("Make incremental changes that can be tested.")
    
    if re.search(r'\b(delete|remove|clean)\b', prompt.lower()):
        additions.append("‚ö†Ô∏è Be extra careful with deletion operations.")
        additions.append("Verify the impact before removing code or files.")
    
    # Add codebase-specific conventions
    if re.search(r'\b(hook|hooks)\b', prompt.lower()):
        additions.append("Hooks must return proper JSON with 'action' field.")
        additions.append("Use exit code 2 for blocking, 0 for success.")
    
    # Construct enhanced prompt
    if additions:
        enhanced_prompt = prompt + "\n\nüìã Context & Reminders:\n" + "\n".join(additions)
    
    # Log the enhancement
    log_entry = {
        "timestamp": input_data.get('timestamp', ''),
        "original_length": len(prompt),
        "enhanced_length": len(enhanced_prompt),
        "additions_count": len(additions)
    }
    
    # Return modified prompt
    response = {
        "action": "modify",
        "modifications": {
            "prompt": enhanced_prompt
        },
        "metadata": log_entry
    }
    print(json.dumps(response))
    sys.exit(0)
    
except Exception as e:
    # On error, continue without modification
    print(json.dumps({"action": "continue", "error": str(e)}))
    sys.exit(0)`
  },
  {
    id: 'pre_tool_use',
    name: 'Tool Shield',
    icon: IconShield,
    description: 'block dangerous operations before execution',
    script: `#!/usr/bin/env python3
import json
import sys
import re
import os
from pathlib import Path
from datetime import datetime

class AdvancedToolShield:
    def __init__(self):
        self.dangerous_patterns = [
            # Destructive commands
            (r'rm\s+.*-[a-z]*r[a-z]*f', 100, "Recursive force deletion detected"),
            (r'rm\s+.*-[a-z]*f[a-z]*r', 100, "Force recursive deletion detected"),
            (r'rm\s+-rf\s+[~/.]', 100, "Dangerous rm -rf on home/current directory"),
            (r'rm\s+-rf\s+/', 100, "CRITICAL: rm -rf on root directory!"),
            
            # Disk operations
            (r'dd\s+if=.+of=/dev/', 100, "Direct disk write operation"),
            (r'mkfs', 90, "Filesystem format command"),
            (r'> */dev/sd[a-z]', 100, "Direct device overwrite"),
            
            # System modifications
            (r'chmod\s+777', 80, "Overly permissive chmod detected"),
            (r'chmod\s+-R\s+777', 100, "Recursive overly permissive chmod"),
            (r'chown\s+-R\s+root', 90, "Recursive root ownership change"),
            
            # Dangerous execution
            (r':(){ :|:& };:', 100, "Fork bomb detected!"),
            (r'curl.+\|\s*(bash|sh)', 90, "Piping web content to shell"),
            (r'wget.+\|\s*(bash|sh)', 90, "Piping downloaded content to shell"),
            (r'eval\s*\(', 70, "Dynamic code evaluation"),
            (r'exec\s*\(', 70, "Dynamic code execution"),
            
            # Network operations
            (r'nc\s+-l', 60, "Netcat listener"),
            (r'nmap', 50, "Network scanning tool"),
            
            # Privilege escalation
            (r'sudo\s+rm', 80, "Sudo with removal command"),
            (r'sudo\s+chmod', 70, "Sudo with permission change"),
            (r'sudo\s+chown', 70, "Sudo with ownership change"),
            (r'sudo\s+passwd', 90, "Password change with sudo"),
            
            # Encoding/Decoding (potential obfuscation)
            (r'base64\s+-d', 40, "Base64 decoding detected"),
            (r'echo.+\|\s*base64\s+-d', 60, "Piped base64 decoding"),
        ]
        
        self.protected_paths = [
            '/System', '/usr', '/bin', '/sbin', '/etc',
            '/Windows', '/Program Files', 'C:\\Windows',
            '~/.ssh', '~/.gnupg', '~/.aws'
        ]
        
        self.protected_files = [
            '.env', '.env.local', '.env.production', '.env.development',
            'secrets', 'credentials', 'private_key', 'id_rsa', 'id_ed25519',
            'passwd', 'shadow', '.htpasswd', 'wp-config.php',
            'database.yml', 'config/database.yml', 'settings.py',
            '.git-credentials', '.netrc', '.npmrc', '.pypirc'
        ]
        
        self.log_path = Path.home() / '.yurucode' / 'hooks' / 'shield.log'
        self.state_path = Path.home() / '.yurucode' / 'hooks' / 'state.json'
    
    def calculate_risk_score(self, tool, input_data):
        """Calculate comprehensive risk score"""
        total_score = 0
        reasons = []
        
        if tool == 'Bash':
            command = input_data.get('command', '')
            
            # Check dangerous patterns
            for pattern, score, reason in self.dangerous_patterns:
                if re.search(pattern, command, re.IGNORECASE):
                    total_score += score
                    reasons.append(reason)
            
            # Check for operations on protected paths
            for protected in self.protected_paths:
                if protected in command:
                    total_score += 50
                    reasons.append(f"Operation on protected path: {protected}")
            
            # Time-based risk (after hours)
            hour = datetime.now().hour
            if hour < 6 or hour > 22:
                total_score += 20
                reasons.append("After-hours operation")
            
            # Check command length (potential obfuscation)
            if len(command) > 500:
                total_score += 30
                reasons.append("Suspiciously long command")
            
            # Check for multiple commands
            if ';' in command or '&&' in command or '||' in command:
                total_score += 10
                reasons.append("Multiple commands chained")
        
        elif tool in ['Write', 'Edit', 'MultiEdit', 'NotebookEdit']:
            file_path = input_data.get('file_path', '').lower()
            
            # Check protected files
            for protected in self.protected_files:
                if protected in file_path:
                    total_score += 80
                    reasons.append(f"Protected file: {protected}")
            
            # Check protected paths
            for protected in self.protected_paths:
                if file_path.startswith(protected.lower()):
                    total_score += 70
                    reasons.append(f"Protected directory: {protected}")
            
            # Check for backup files
            if file_path.endswith('.bak') or file_path.endswith('.backup'):
                total_score += 30
                reasons.append("Modifying backup file")
        
        return min(100, total_score), reasons
    
    def log_decision(self, decision):
        """Log security decisions"""
        try:
            self.log_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.log_path, 'a') as f:
                f.write(json.dumps(decision) + '\n')
        except:
            pass
    
    def update_state(self, decision):
        """Update state with decision"""
        try:
            state = {}
            if self.state_path.exists():
                with open(self.state_path, 'r') as f:
                    state = json.load(f)
            
            if 'decisions' not in state:
                state['decisions'] = []
            
            state['decisions'].append(decision)
            # Keep only last 100 decisions
            state['decisions'] = state['decisions'][-100:]
            
            self.state_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.state_path, 'w') as f:
                json.dump(state, f, indent=2)
        except:
            pass

try:
    shield = AdvancedToolShield()
    input_data = json.load(sys.stdin)
    
    tool = input_data.get('data', {}).get('tool', '')
    tool_input = input_data.get('data', {}).get('input', {})
    session_id = input_data.get('sessionId', '')
    
    # Calculate risk score
    risk_score, reasons = shield.calculate_risk_score(tool, tool_input)
    
    # Create decision record
    decision = {
        "timestamp": datetime.now().isoformat(),
        "session_id": session_id,
        "tool": tool,
        "risk_score": risk_score,
        "reasons": reasons
    }
    
    # Determine action based on risk score
    if risk_score >= 80:
        decision["action"] = "block"
        message = f"üõ°Ô∏è BLOCKED: {', '.join(reasons[:2])}"
        if risk_score == 100:
            message = "‚õî " + message
        
        shield.log_decision(decision)
        shield.update_state(decision)
        
        print(json.dumps({
            "action": "block",
            "message": message,
            "risk_score": risk_score,
            "reasons": reasons
        }))
        sys.exit(2)
    
    elif risk_score >= 50:
        decision["action"] = "warn"
        message = f"‚ö†Ô∏è Warning: {', '.join(reasons[:2])} (Risk: {risk_score}/100)"
        
        shield.log_decision(decision)
        shield.update_state(decision)
        
        print(json.dumps({
            "action": "continue",
            "message": message,
            "risk_score": risk_score
        }))
        sys.exit(0)
    
    else:
        decision["action"] = "allow"
        shield.update_state(decision)
        print('{"action":"continue"}')
        sys.exit(0)

except Exception as e:
    print(json.dumps({"action": "continue", "error": str(e)}))
    sys.exit(0)`
  },
  {
    id: 'context_warning',
    name: 'Context Guard',
    icon: IconAlertTriangle,
    description: 'handle context warnings at 75%+ usage',
    script: `#!/usr/bin/env python3
import json
import sys

try:
    input_data = json.load(sys.stdin)
    usage = input_data.get('data', {}).get('usage_percentage', 0)
    
    if usage >= 95:
        # Critical - force compaction
        response = {
            "action": "block",
            "message": f"‚ö†Ô∏è Context at {usage}%. Compaction required! Use /compact immediately."
        }
        print(json.dumps(response))
        sys.exit(2)
    elif usage >= 90:
        # High usage - strong warning
        response = {
            "action": "continue",
            "message": f"‚ö†Ô∏è Context at {usage}%. Consider using /compact soon."
        }
        print(json.dumps(response))
        sys.exit(0)
    elif usage >= 75:
        # Moderate usage - gentle reminder
        response = {
            "action": "continue",
            "message": f"Context at {usage}%. Start wrapping up current work."
        }
        print(json.dumps(response))
        sys.exit(0)
    else:
        print('{"action":"continue"}')
        sys.exit(0)
except:
    print('{"action":"continue"}')
    sys.exit(0)`
  },
  {
    id: 'compaction_trigger',
    name: 'Smart Compaction',
    icon: IconRefresh,
    description: 'auto-compact at 96% context usage',
    script: `#!/usr/bin/env python3
import json
import sys

try:
    input_data = json.load(sys.stdin)
    usage = input_data.get('data', {}).get('usage_percentage', 0)
    action_type = input_data.get('data', {}).get('action_type', '')
    
    if action_type == 'AutoTrigger' and usage >= 96:
        # Auto-trigger compaction
        response = {
            "action": "continue",
            "message": f"üîÑ Auto-compacting at {usage}%. Preserving conversation context..."
        }
        print(json.dumps(response))
        sys.exit(0)
    elif action_type == 'Force' and usage >= 98:
        # Force compaction
        response = {
            "action": "continue",
            "message": f"‚ö†Ô∏è Force-compacting at {usage}% to prevent overflow."
        }
        print(json.dumps(response))
        sys.exit(0)
    else:
        print('{"action":"continue"}')
        sys.exit(0)
except:
    print('{"action":"continue"}')
    sys.exit(0)`
  },
  {
    id: 'discussion_enforcer',
    name: 'Discussion Enforcer',
    icon: IconBan,
    description: 'require discussion before code changes',
    script: `#!/usr/bin/env python3
import json
import sys
from pathlib import Path
from datetime import datetime, timedelta

class DAICEnforcer:
    """Discussion, Approval, Implementation, Completion workflow enforcer"""
    
    def __init__(self):
        self.state_file = Path.home() / '.yurucode' / 'hooks' / 'daic_state.json'
        self.state = self.load_state()
        self.allowed_tools = ['Read', 'Grep', 'LS', 'Glob', 'WebSearch', 'WebFetch']
        self.blocked_tools = ['Write', 'Edit', 'MultiEdit', 'NotebookEdit', 'Bash']
    
    def load_state(self):
        """Load DAIC state from file"""
        try:
            if self.state_file.exists():
                with open(self.state_file, 'r') as f:
                    return json.load(f)
        except:
            pass
        
        return {
            'mode': 'discussion',
            'proposals': [],
            'approved_changes': [],
            'last_discussion': None,
            'implementation_started': None
        }
    
    def save_state(self):
        """Save DAIC state to file"""
        try:
            self.state_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.state_file, 'w') as f:
                json.dump(self.state, f, indent=2)
        except:
            pass
    
    def add_proposal(self, tool, file_path):
        """Add a change proposal"""
        proposal = {
            'timestamp': datetime.now().isoformat(),
            'tool': tool,
            'file_path': file_path,
            'status': 'pending'
        }
        self.state['proposals'].append(proposal)
        # Keep only last 20 proposals
        self.state['proposals'] = self.state['proposals'][-20:]
        self.save_state()
    
    def check_discussion_timeout(self):
        """Check if discussion has timed out"""
        if self.state['last_discussion']:
            last = datetime.fromisoformat(self.state['last_discussion'])
            if datetime.now() - last > timedelta(minutes=30):
                # Reset to discussion mode after 30 minutes
                self.state['mode'] = 'discussion'
                self.state['proposals'] = []
                self.save_state()
                return True
        return False
    
    def process_tool(self, tool, input_data):
        """Process tool request based on DAIC state"""
        # Check for timeout
        self.check_discussion_timeout()
        
        current_mode = self.state['mode']
        
        if current_mode == 'discussion':
            if tool in self.blocked_tools:
                file_path = input_data.get('file_path', input_data.get('command', 'operation'))
                self.add_proposal(tool, file_path)
                
                # Update last discussion time
                self.state['last_discussion'] = datetime.now().isoformat()
                self.save_state()
                
                proposals_count = len(self.state['proposals'])
                
                return {
                    'action': 'block',
                    'message': f"üìù DISCUSSION MODE: Please explain what you want to do with {file_path}\n" +
                              f"Current proposals: {proposals_count}\n" +
                              "To proceed: 1) Explain all changes, 2) Get approval, 3) Implement",
                    'metadata': {
                        'mode': 'discussion',
                        'proposals': proposals_count
                    }
                }
        
        elif current_mode == 'approval':
            if tool in self.blocked_tools:
                return {
                    'action': 'block',
                    'message': "‚è≥ APPROVAL MODE: Waiting for user approval of proposed changes\n" +
                              "User must approve before implementation can begin.",
                    'metadata': {'mode': 'approval'}
                }
        
        elif current_mode == 'implementation':
            # Allow implementation
            if not self.state['implementation_started']:
                self.state['implementation_started'] = datetime.now().isoformat()
                self.save_state()
            
            # Log the implementation
            if tool in self.blocked_tools:
                file_path = input_data.get('file_path', '')
                self.state['approved_changes'].append({
                    'timestamp': datetime.now().isoformat(),
                    'tool': tool,
                    'file_path': file_path
                })
                self.save_state()
                
                return {
                    'action': 'continue',
                    'message': f"‚úÖ IMPLEMENTATION MODE: Executing approved change on {file_path}",
                    'metadata': {'mode': 'implementation'}
                }
        
        elif current_mode == 'completion':
            # Reset for next cycle
            self.state['mode'] = 'discussion'
            self.state['proposals'] = []
            self.state['approved_changes'] = []
            self.state['implementation_started'] = None
            self.save_state()
            
            return {
                'action': 'continue',
                'message': "üèÅ COMPLETION: Task completed. Returning to discussion mode.",
                'metadata': {'mode': 'completion'}
            }
        
        # Default: allow read operations
        return {'action': 'continue'}

try:
    enforcer = DAICEnforcer()
    input_data = json.load(sys.stdin)
    
    tool = input_data.get('data', {}).get('tool', '')
    tool_input = input_data.get('data', {}).get('input', {})
    
    result = enforcer.process_tool(tool, tool_input)
    
    if result['action'] == 'block':
        print(json.dumps(result))
        sys.exit(2)
    else:
        print(json.dumps(result))
        sys.exit(0)

except Exception as e:
    print(json.dumps({"action": "continue", "error": str(e)}))
    sys.exit(0)`
  },
  {
    id: 'post_tool_use',
    name: 'Response Processor',
    icon: IconCode,
    description: 'process tool results before claude sees them',
    script: `#!/usr/bin/env python3
import json
import sys

try:
    input_data = json.load(sys.stdin)
    tool = input_data.get('data', {}).get('tool', '')
    result = input_data.get('data', {}).get('result', '')
    
    # Log successful operations
    if tool in ['Write', 'Edit', 'MultiEdit']:
        file_path = input_data.get('data', {}).get('input', {}).get('file_path', '')
        # Could log to a file or send notification
        response = {
            "action": "continue",
            "message": f"‚úÖ Successfully modified: {file_path}"
        }
        print(json.dumps(response))
        sys.exit(0)
    
    print('{"action":"continue"}')
    sys.exit(0)
except:
    print('{"action":"continue"}')
    sys.exit(0)`
  },
  {
    id: 'assistant_response',
    name: 'Response Analyzer',
    icon: IconBrain,
    description: 'analyze claude responses for issues',
    script: `#!/usr/bin/env python3
import json
import sys

try:
    input_data = json.load(sys.stdin)
    response_text = input_data.get('data', {}).get('response', '')
    
    # Check for common issues in responses
    warnings = []
    
    if 'error' in response_text.lower() or 'exception' in response_text.lower():
        warnings.append("Response contains error mentions")
    
    if 'todo' in response_text.lower() or 'fixme' in response_text.lower():
        warnings.append("Response contains TODO/FIXME items")
    
    if len(response_text) > 10000:
        warnings.append("Very long response - consider breaking down")
    
    if warnings:
        response = {
            "action": "continue",
            "message": "‚ö†Ô∏è " + "; ".join(warnings)
        }
        print(json.dumps(response))
    else:
        print('{"action":"continue"}')
    
    sys.exit(0)
except:
    print('{"action":"continue"}')
    sys.exit(0)`
  },
  {
    id: 'session_start',
    name: 'Session Initializer',
    icon: IconRocket,
    description: 'run initialization when session starts',
    script: `#!/usr/bin/env python3
import json
import sys
from datetime import datetime

try:
    input_data = json.load(sys.stdin)
    session_id = input_data.get('sessionId', 'unknown')
    
    # Log session start
    timestamp = datetime.now().isoformat()
    
    response = {
        "action": "continue",
        "message": f"üöÄ Session {session_id[:8]} started at {timestamp}"
    }
    
    print(json.dumps(response))
    sys.exit(0)
except:
    print('{"action":"continue"}')
    sys.exit(0)`
  },
  {
    id: 'session_end',
    name: 'Session Cleanup',
    icon: IconTrash,
    description: 'cleanup when session ends',
    script: `#!/usr/bin/env python3
import json
import sys
from datetime import datetime

try:
    input_data = json.load(sys.stdin)
    session_id = input_data.get('sessionId', 'unknown')
    
    # Log session end
    timestamp = datetime.now().isoformat()
    
    response = {
        "action": "continue",
        "message": f"üèÅ Session {session_id[:8]} ended at {timestamp}"
    }
    
    print(json.dumps(response))
    sys.exit(0)
except:
    print('{"action":"continue"}')
    sys.exit(0)`
  }
];

export const HooksTab: React.FC<HooksTabProps> = ({ 
  selectedHooks, 
  setSelectedHooks,
  hookScripts,
  setHookScripts 
}) => {
  const [customHooks, setCustomHooks] = useState<any[]>([]);
  const [showCustomModal, setShowCustomModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [editingHook, setEditingHook] = useState<any>(null);
  const [editingScript, setEditingScript] = useState('');
  const [testResult, setTestResult] = useState('');
  const [testing, setTesting] = useState(false);
  const [customHookName, setCustomHookName] = useState('');
  const [customHookEvent, setCustomHookEvent] = useState('user_prompt_submit');
  const [customHookDescription, setCustomHookDescription] = useState('');
  const [customHookScript, setCustomHookScript] = useState('');

  useEffect(() => {
    loadCustomHooks();
    loadSavedStates();
  }, []);

  const loadCustomHooks = () => {
    const saved = localStorage.getItem('custom_hooks');
    if (saved) {
      setCustomHooks(JSON.parse(saved));
    }
  };

  const loadSavedStates = () => {
    // Load saved states for yurucode hooks - default to enabled
    const states: any = {};
    const scripts: any = {};
    
    YURUCODE_HOOKS.forEach(hook => {
      const saved = localStorage.getItem(`hook_${hook.id}_enabled`);
      // If never saved before, default to true and save it
      if (saved === null) {
        states[hook.id] = true;
        localStorage.setItem(`hook_${hook.id}_enabled`, 'true');
        hooksService.saveHook(hook.id, { enabled: true, script: hook.script });
      } else {
        states[hook.id] = saved === 'true';
      }
      
      // Load saved scripts or use default
      const savedScript = localStorage.getItem(`hook_${hook.id}_script`);
      if (savedScript === null) {
        scripts[hook.id] = hook.script;
        localStorage.setItem(`hook_${hook.id}_script`, hook.script);
        hooksService.saveHook(hook.id, { script: hook.script });
      } else {
        scripts[hook.id] = savedScript;
      }
    });
    
    setSelectedHooks(states);
    setHookScripts(scripts);
  };

  const toggleHook = (hookId: string, enabled: boolean) => {
    const newStates = { ...selectedHooks, [hookId]: enabled };
    setSelectedHooks(newStates);
    localStorage.setItem(`hook_${hookId}_enabled`, enabled ? 'true' : 'false');
    hooksService.saveHook(hookId, { enabled });
  };

  const editHook = (hook: any) => {
    setEditingHook(hook);
    setEditingScript(hookScripts[hook.id] || hook.script || '');
    setShowEditModal(true);
  };

  const saveHookScript = () => {
    if (!editingHook) return;
    
    setHookScripts({ ...hookScripts, [editingHook.id]: editingScript });
    localStorage.setItem(`hook_${editingHook.id}_script`, editingScript);
    hooksService.saveHook(editingHook.id, { script: editingScript });
    
    setShowEditModal(false);
    setEditingHook(null);
    setEditingScript('');
  };

  const testHookScript = async () => {
    if (!editingHook || !editingScript) return;
    
    setTesting(true);
    setTestResult('');
    
    try {
      const result = await invoke<string>('test_hook', {
        script: editingScript,
        event: editingHook.id
      });
      setTestResult(result);
    } catch (error) {
      setTestResult(`Error: ${error}`);
    } finally {
      setTesting(false);
    }
  };

  const loadSampleHooks = async () => {
    try {
      const samples = await invoke<Array<[string, string, string]>>('get_sample_hooks');
      
      samples.forEach(([name, event, script]) => {
        const hook = YURUCODE_HOOKS.find(h => h.id === event);
        if (hook) {
          setHookScripts({ ...hookScripts, [event]: script });
          localStorage.setItem(`hook_${event}_script`, script);
          hooksService.saveHook(event, { script });
        }
      });
    } catch (error) {
      console.error('Failed to load sample hooks:', error);
    }
  };

  const addCustomHook = () => {
    if (!customHookName) return;
    
    const newHook = {
      id: `custom_${Date.now()}`,
      name: customHookName,
      description: customHookDescription || 'custom hook',
      event: customHookEvent,
      enabled: false,
      script: customHookScript || '#!/bin/bash\necho \'{"action":"continue"}\''
    };
    
    const updated = [...customHooks, newHook];
    setCustomHooks(updated);
    localStorage.setItem('custom_hooks', JSON.stringify(updated));
    
    setShowCustomModal(false);
    setCustomHookName('');
    setCustomHookDescription('');
    setCustomHookScript('');
  };

  const deleteCustomHook = (hookId: string) => {
    const updated = customHooks.filter(h => h.id !== hookId);
    setCustomHooks(updated);
    localStorage.setItem('custom_hooks', JSON.stringify(updated));
  };

  const resetAllToDefaults = () => {
    if (!confirm('This will reset all yurucode hooks to their default scripts. Are you sure?')) {
      return;
    }
    
    // Reset all hooks to defaults
    const defaultStates: any = {};
    const defaultScripts: any = {};
    
    YURUCODE_HOOKS.forEach(hook => {
      defaultStates[hook.id] = true; // All enabled by default
      defaultScripts[hook.id] = hook.script;
      
      // Save to localStorage
      localStorage.setItem(`hook_${hook.id}_enabled`, 'true');
      localStorage.setItem(`hook_${hook.id}_script`, hook.script);
      
      // Save to hooksService
      hooksService.saveHook(hook.id, { 
        enabled: true, 
        script: hook.script,
        name: hook.name
      });
    });
    
    setSelectedHooks(defaultStates);
    setHookScripts(defaultScripts);
  };

  return (
    <>
      {/* Built-in Hooks */}
      <div className="settings-section">
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
          <h5 style={{ fontSize: '11px', color: '#999', margin: 0 }}>built-in hooks</h5>
          <button 
            onClick={resetAllToDefaults}
            style={{ 
              background: 'transparent',
              border: '1px solid rgba(255, 255, 255, 0.2)',
              color: 'rgba(255, 255, 255, 0.4)',
              padding: '2px 6px',
              borderRadius: '4px',
              fontSize: '10px',
              cursor: 'default',
              display: 'flex',
              alignItems: 'center',
              gap: '4px'
            }}
          >
            <IconRotateClockwise size={10} />
            reset to defaults
          </button>
        </div>
        
        {YURUCODE_HOOKS.map(hook => (
          <div key={hook.id} style={{ marginBottom: '6px' }}>
            <div className="checkbox-setting">
              <span className="checkbox-label" style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                {hook.icon && <hook.icon size={12} />}
                {hook.name}
              </span>
              <input 
                type="checkbox" 
                className="checkbox-input"
                id={`hook-${hook.id}`}
                checked={selectedHooks[hook.id] || false}
                onChange={(e) => toggleHook(hook.id, e.target.checked)}
              />
              <div className="toggle-switch-container">
                <label htmlFor={`hook-${hook.id}`} className={`toggle-switch ${selectedHooks[hook.id] ? 'active' : ''}`}>
                  <span className="toggle-switch-slider" />
                  <span className="toggle-switch-label off">OFF</span>
                  <span className="toggle-switch-label on">ON</span>
                </label>
              </div>
            </div>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <p style={{ fontSize: '9px', color: '#666', margin: '2px 0 0 0' }}>{hook.description}</p>
              {selectedHooks[hook.id] && (
                <button
                  onClick={() => editHook(hook)}
                  style={{
                    background: 'transparent',
                    border: 'none',
                    color: '#666',
                    cursor: 'default',
                    padding: '2px',
                    fontSize: '10px'
                  }}
                >
                  <IconEdit size={10} />
                </button>
              )}
            </div>
          </div>
        ))}
      </div>
      
      {/* Custom Hooks */}
      <div className="settings-section">
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
          <h5 style={{ fontSize: '11px', color: '#999', margin: 0 }}>custom hooks</h5>
          <button 
            onClick={() => setShowCustomModal(true)}
            style={{ 
              background: 'transparent',
              border: '1px solid rgba(255, 255, 255, 0.2)',
              color: 'rgba(255, 255, 255, 0.4)',
              padding: '2px 6px',
              borderRadius: '4px',
              fontSize: '10px',
              cursor: 'default'
            }}
          >
            + add custom
          </button>
        </div>
        
        {customHooks.length === 0 ? (
          <p style={{ fontSize: '10px', color: '#666' }}>no custom hooks yet</p>
        ) : (
          customHooks.map(hook => (
            <div key={hook.id} style={{ marginBottom: '6px' }}>
              <div className="checkbox-setting">
                <span className="checkbox-label">{hook.name}</span>
                <input 
                  type="checkbox" 
                  className="checkbox-input"
                  id={`custom-${hook.id}`}
                  checked={hook.enabled}
                  onChange={(e) => {
                    const updated = customHooks.map(h => 
                      h.id === hook.id ? { ...h, enabled: e.target.checked } : h
                    );
                    setCustomHooks(updated);
                    localStorage.setItem('custom_hooks', JSON.stringify(updated));
                  }}
                />
                <div className="toggle-switch-container">
                  <label htmlFor={`custom-${hook.id}`} className={`toggle-switch ${hook.enabled ? 'active' : ''}`}>
                    <span className="toggle-switch-slider" />
                    <span className="toggle-switch-label off">OFF</span>
                    <span className="toggle-switch-label on">ON</span>
                  </label>
                </div>
              </div>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <p style={{ fontSize: '9px', color: '#666', margin: '2px 0 0 0' }}>{hook.description}</p>
                <div style={{ display: 'flex', gap: '4px' }}>
                  {hook.enabled && (
                    <button
                      onClick={() => editHook(hook)}
                      style={{
                        background: 'transparent',
                        border: 'none',
                        color: '#666',
                        cursor: 'default',
                        padding: '2px',
                        fontSize: '10px'
                      }}
                    >
                      <IconEdit size={10} />
                    </button>
                  )}
                  <button
                    onClick={() => deleteCustomHook(hook.id)}
                    style={{
                      background: 'transparent',
                      border: 'none',
                      color: '#ff9999',
                      cursor: 'default',
                      padding: '2px',
                      fontSize: '10px'
                    }}
                  >
                    <IconTrash size={10} />
                  </button>
                </div>
              </div>
            </div>
          ))
        )}
      </div>

      {/* Edit Hook Modal */}
      {showEditModal && editingHook && (
        <div className="hook-modal-overlay" onClick={() => setShowEditModal(false)}>
          <div className="hook-modal" onClick={(e) => e.stopPropagation()}>
            <div className="hook-modal-header">
              <h4>edit {editingHook.name}</h4>
              <button onClick={() => setShowEditModal(false)}>
                <IconX size={14} />
              </button>
            </div>
            
            <textarea
              className="hook-script-editor"
              value={editingScript}
              onChange={(e) => setEditingScript(e.target.value)}
              placeholder="Enter hook script..."
              spellCheck={false}
              style={{
                width: '100%',
                height: '200px',
                background: '#111',
                border: '1px solid #333',
                color: '#fff',
                padding: '8px',
                fontSize: '11px',
                fontFamily: 'monospace',
                borderRadius: '4px',
                resize: 'vertical'
              }}
            />
            
            {testResult && (
              <div style={{
                marginTop: '8px',
                padding: '8px',
                background: '#111',
                border: '1px solid #333',
                borderRadius: '4px',
                fontSize: '10px',
                color: '#999',
                fontFamily: 'monospace'
              }}>
                <strong>test result:</strong>
                <pre style={{ margin: '4px 0 0 0' }}>{testResult}</pre>
              </div>
            )}
            
            <div className="hook-modal-actions" style={{ marginTop: '12px', display: 'flex', gap: '8px' }}>
              <button
                onClick={testHookScript}
                disabled={testing}
                style={{
                  flex: 1,
                  background: 'transparent',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  color: 'rgba(255, 255, 255, 0.4)',
                  padding: '6px',
                  borderRadius: '4px',
                  fontSize: '11px',
                  cursor: 'default'
                }}
              >
                <IconPlayerPlay size={12} style={{ marginRight: '4px', verticalAlign: 'middle' }} />
                {testing ? 'testing...' : 'test'}
              </button>
              <button
                onClick={saveHookScript}
                style={{
                  flex: 1,
                  background: 'rgba(153, 187, 255, 0.1)',
                  border: '1px solid rgba(153, 187, 255, 0.3)',
                  color: '#99bbff',
                  padding: '6px',
                  borderRadius: '4px',
                  fontSize: '11px',
                  cursor: 'default'
                }}
              >
                <IconCheck size={12} style={{ marginRight: '4px', verticalAlign: 'middle' }} />
                save
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Add Custom Hook Modal */}
      {showCustomModal && (
        <div className="hook-modal-overlay" onClick={() => setShowCustomModal(false)}>
          <div className="hook-modal" onClick={(e) => e.stopPropagation()}>
            <div className="hook-modal-header">
              <h4>add custom hook</h4>
              <button onClick={() => setShowCustomModal(false)}>
                <IconX size={14} />
              </button>
            </div>
            
            <input
              type="text"
              placeholder="hook name..."
              value={customHookName}
              onChange={(e) => setCustomHookName(e.target.value)}
              style={{
                width: '100%',
                padding: '6px',
                background: '#111',
                border: '1px solid #333',
                color: '#fff',
                fontSize: '11px',
                borderRadius: '4px',
                marginBottom: '8px'
              }}
            />
            
            <input
              type="text"
              placeholder="description..."
              value={customHookDescription}
              onChange={(e) => setCustomHookDescription(e.target.value)}
              style={{
                width: '100%',
                padding: '6px',
                background: '#111',
                border: '1px solid #333',
                color: '#fff',
                fontSize: '11px',
                borderRadius: '4px',
                marginBottom: '8px'
              }}
            />
            
            <select
              value={customHookEvent}
              onChange={(e) => setCustomHookEvent(e.target.value)}
              style={{
                width: '100%',
                padding: '6px 8px',
                background: '#111',
                backgroundImage: 'linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0) 100%)',
                border: '1px solid #333',
                color: '#fff',
                fontSize: '11px',
                borderRadius: '4px',
                marginBottom: '12px',
                cursor: 'default',
                outline: 'none',
                appearance: 'none',
                WebkitAppearance: 'none',
                MozAppearance: 'none',
                backgroundRepeat: 'no-repeat',
                backgroundPosition: 'right 8px center',
                backgroundSize: '12px',
                paddingRight: '28px',
                backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E"), linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0) 100%)`,
                transition: 'border-color 0.2s, background-color 0.2s'
              }}
              onFocus={(e) => {
                e.target.style.borderColor = '#99bbff';
                e.target.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
              }}
              onBlur={(e) => {
                e.target.style.borderColor = '#333';
                e.target.style.backgroundColor = '#111';
              }}
            >
              <option value="user_prompt_submit" style={{ background: '#111', color: '#fff' }}>user_prompt_submit</option>
              <option value="pre_tool_use" style={{ background: '#111', color: '#fff' }}>pre_tool_use</option>
              <option value="post_tool_use" style={{ background: '#111', color: '#fff' }}>post_tool_use</option>
              <option value="assistant_response" style={{ background: '#111', color: '#fff' }}>assistant_response</option>
              <option value="session_start" style={{ background: '#111', color: '#fff' }}>session_start</option>
              <option value="session_end" style={{ background: '#111', color: '#fff' }}>session_end</option>
              <option value="context_warning" style={{ background: '#111', color: '#fff' }}>context_warning</option>
              <option value="compaction_trigger" style={{ background: '#111', color: '#fff' }}>compaction_trigger</option>
              <option value="error" style={{ background: '#111', color: '#fff' }}>error</option>
            </select>
            
            <textarea
              placeholder="hook script (bash/python)..."
              value={customHookScript}
              onChange={(e) => setCustomHookScript(e.target.value)}
              style={{
                width: '100%',
                padding: '8px',
                background: '#111',
                backgroundImage: 'linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0) 100%)',
                border: '1px solid #333',
                color: '#fff',
                fontSize: '11px',
                fontFamily: 'var(--font-mono, "Fira Code", monospace)',
                borderRadius: '4px',
                marginBottom: '12px',
                resize: 'vertical',
                minHeight: '120px',
                outline: 'none',
                transition: 'border-color 0.2s, background-color 0.2s'
              }}
              onFocus={(e) => {
                e.target.style.borderColor = '#99bbff';
                e.target.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
              }}
              onBlur={(e) => {
                e.target.style.borderColor = '#333';
                e.target.style.backgroundColor = '#111';
              }}
              spellCheck={false}
            />
            
            <button
              onClick={addCustomHook}
              disabled={!customHookName}
              style={{
                width: '100%',
                background: 'rgba(153, 187, 255, 0.1)',
                border: '1px solid rgba(153, 187, 255, 0.3)',
                color: '#99bbff',
                padding: '6px',
                borderRadius: '4px',
                fontSize: '11px',
                cursor: 'default'
              }}
            >
              <IconPlus size={12} style={{ marginRight: '4px', verticalAlign: 'middle' }} />
              add hook
            </button>
          </div>
        </div>
      )}

      <style jsx>{`
        .hook-modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        }
        
        .hook-modal {
          background: #000;
          border: 1px solid #333;
          border-radius: 8px;
          padding: 16px;
          width: 90%;
          max-width: 500px;
        }
        
        .hook-modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 12px;
        }
        
        .hook-modal-header h4 {
          margin: 0;
          font-size: 14px;
          color: #fff;
        }
        
        .hook-modal-header button {
          background: transparent;
          border: none;
          color: #666;
          cursor: pointer;
          padding: 4px;
        }
        
        .hook-modal-header button:hover {
          color: #999;
        }
      `}</style>
    </>
  );
};