console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"),console.log("ü™ü YURUCODE SERVER: Windows External Server (server-claude-windows.cjs)"),console.log("ü™ü Platform-specific server for Windows - aligned with macOS flow"),console.log("ü™ü Edit code at: server-claude-windows.cjs"),console.log("ü™ü Uses external file for easier debugging and updates"),console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");const originalConsole={log:console.log.bind(console),error:console.error.bind(console),warn:console.warn.bind(console),info:console.info.bind(console),debug:console.debug.bind(console)};console.log=function(...e){try{originalConsole.log(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.error=function(...e){try{originalConsole.error(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.warn=function(...e){try{originalConsole.warn(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.info=function(...e){try{originalConsole.info(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.debug=function(...e){try{originalConsole.debug(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}};const wrapperState={sessions:new Map,stats:{apiCalls:0,totalTokens:0,compacts:0}};function getWrapperSession(e){return wrapperState.sessions.has(e)||(wrapperState.sessions.set(e,{id:e,inputTokens:0,outputTokens:0,totalTokens:0,messageCount:0,apiResponses:[],compactCount:0,wasCompacted:!1,tokensSaved:0}),console.log(`‚úÖ [WRAPPER] Created session: ${e}`)),wrapperState.sessions.get(e)}function processWrapperLine(e,s){if(!e||!e.trim())return e;const o=getWrapperSession(s);try{const s=JSON.parse(e);if(wrapperState.stats.apiCalls++,console.log(`üì° [WRAPPER] API ${s.type} #${wrapperState.stats.apiCalls}`),o.apiResponses.push({timestamp:Date.now(),type:s.type,data:{...s}}),"user"!==s.type&&"assistant"!==s.type||o.messageCount++,"user"===s.type&&s.message?.content){const e="string"==typeof s.message.content?s.message.content:Array.isArray(s.message.content)?s.message.content.find(e=>"text"===e.type)?.text:"";if("/compact"===e?.trim()){o.compactInProgress=!0,console.log("üóúÔ∏è [WRAPPER] Detected /compact command starting");const e=o.history.slice(-20);let s="‚úÖ Conversation compacted successfully!\n\n";s+="üìä Compaction Summary:\n",s+=`‚Ä¢ Messages compressed: ${o.messageCount}\n`,s+=`‚Ä¢ Tokens saved: ${o.totalTokens.toLocaleString()}\n`;const t=e.filter(e=>"user"===e.type);if(t.length>0){s+="\nüìù Recent context:\n";const e=t.slice(-3).map(e=>{const s=e.data?.message?.content;let o="";if("string"==typeof s)o=s;else if(Array.isArray(s)){const e=s.find(e=>"text"===e.type);o=e?.text||""}return o=o.replace(/\n+/g," ").trim(),o.length>80&&(o=o.substring(0,77)+"..."),o}).filter(e=>e);e.forEach((e,o)=>{s+=`‚Ä¢ ${e}\n`})}s+="\n‚ú® Context reset - you can continue normally.",o.compactSummary=s,console.log(`üóúÔ∏è [WRAPPER] Generated compact summary: ${s.substring(0,100)}...`)}}const t=o.compactInProgress||o.isCompacting;if(s.usage&&!t){const e=s.usage.input_tokens||0,t=s.usage.output_tokens||0,n=s.usage.cache_creation_input_tokens||0,i=s.usage.cache_read_input_tokens||0,r=o.totalTokens;o.inputTokens=e,o.outputTokens=t,o.cacheCreationTokens=n,o.cacheReadTokens=i,o.totalTokens=e+t;const a=o.totalTokens-r;wrapperState.stats.totalTokens+=a,console.log(`üìä [WRAPPER] TOKENS +${a} ‚Üí ${o.totalTokens}/200000 (${Math.round(o.totalTokens/2e3)}%)`),(n>0||i>0)&&console.log(`   üì¶ Cache: creation=${n}, read=${i} (cache_read doesn't count toward 200k limit)`)}else s.usage&&t&&console.log("üóúÔ∏è [WRAPPER] Compact operation tokens (not accumulated):",s.usage);if("assistant"===s.type&&o.compactInProgress&&s.message?.content){let e="";"string"==typeof s.message.content?e=s.message.content:Array.isArray(s.message.content)&&(e=s.message.content.filter(e=>"text"===e.type).map(e=>e.text).join("")),e&&(o.compactSummary=e,console.log(`üóúÔ∏è [WRAPPER] Captured compact summary: ${e.substring(0,100)}...`))}if("result"===s.type&&(!s.usage||0===s.usage.input_tokens&&0===s.usage.output_tokens)&&o.totalTokens>0){const e=o.totalTokens;console.log(`üóúÔ∏è [WRAPPER] COMPACTION DETECTED! Saved ${e} tokens`),o.compactCount++,o.wasCompacted=!0,o.tokensSaved+=e,wrapperState.stats.compacts++,o.inputTokens=0,o.outputTokens=0,o.totalTokens=0,o.cacheCreationTokens=0,o.cacheReadTokens=0,o.compactSummary?(s.result=o.compactSummary,delete o.compactSummary):s.result&&""!==s.result||(s.result=`Conversation compacted. Saved ${e.toLocaleString()} tokens.`),s.wrapper_compact={savedTokens:e,totalSaved:o.tokensSaved,compactCount:o.compactCount},o.compactInProgress=!1,console.log("üóúÔ∏è [WRAPPER] Compaction complete")}return s.wrapper={enabled:!0,tokens:{total:o.totalTokens,input:o.inputTokens,output:o.outputTokens,cache_read:o.cacheReadTokens||0,cache_creation:o.cacheCreationTokens||0},compaction:{count:o.compactCount,wasCompacted:o.wasCompacted,tokensSaved:o.tokensSaved}},JSON.stringify(s)}catch(s){return e}}console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"),console.log("üéØ WRAPPER EMBEDDED - Token tracking and compaction enabled"),console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");const{execSync:execSync,spawn:spawn}=require("child_process"),{existsSync:existsSync,mkdirSync:mkdirSync,readFileSync:readFileSync,writeFileSync:writeFileSync,unlinkSync:unlinkSync}=require("fs"),{dirname:dirname,join:join,isAbsolute:isAbsolute}=require("path"),{createServer:createServer}=require("http"),{Server:Server}=require("socket.io"),{homedir:homedir,platform:platform}=require("os");let CLAUDE_PATH="claude";const isWindows="win32"===platform();let CLAUDE_EXECUTION_MODE="auto",NATIVE_WINDOWS_CLAUDE_PATH=null,WSL_CLAUDE_PATH=null;function loadClaudeSettings(){try{const e=isWindows?join(process.env.APPDATA||process.env.USERPROFILE,"yurucode","claude_settings.json"):join(homedir(),".config","yurucode","claude_settings.json");if(existsSync(e)){const s=JSON.parse(readFileSync(e,"utf8"));console.log("üìã Loaded Claude settings:",s.settings?.executionMode||"not set"),s.settings?.executionMode&&(CLAUDE_EXECUTION_MODE=s.settings.executionMode),s.detection?.nativeWindows?.path&&(NATIVE_WINDOWS_CLAUDE_PATH=s.detection.nativeWindows.path,console.log("üéØ Native Windows Claude path:",NATIVE_WINDOWS_CLAUDE_PATH)),s.detection?.wsl?.path&&(WSL_CLAUDE_PATH=s.detection.wsl.path,console.log("üéØ WSL Claude path:",WSL_CLAUDE_PATH))}}catch(e){console.log("‚ö†Ô∏è Could not load Claude settings, using defaults:",e.message)}}function windowsToWslPath(e){if(!e)return e;const s=e.replace(/\\/g,"/"),o=s.match(/^([A-Z]):(.*)/i);return o?`/mnt/${o[1].toLowerCase()}${o[2]}`:s}function wslToWindowsPath(e){if(!e)return e;const s=e.match(/^\/mnt\/([a-z])(.*)/i);return s?`${s[1].toUpperCase()}:${s[2].replace(/\//g,"\\")}`:e}function createNativeWindowsClaudeCommand(e,s,o){let t=NATIVE_WINDOWS_CLAUDE_PATH||"claude",n=null,i=null;if(t.endsWith(".cmd")){console.log("üì¶ Detected .cmd file, looking for Node.js and actual JS file...");const s=["C:\\Program Files\\nodejs\\node.exe","C:\\Program Files (x86)\\nodejs\\node.exe",process.env.ProgramFiles+"\\nodejs\\node.exe",process.env["ProgramFiles(x86)"]+"\\nodejs\\node.exe"].filter(Boolean);for(const e of s)if(existsSync(e)){n=e;break}if(!n){const e=require("path").dirname(t),s=require("path").join(e,"node.exe");existsSync(s)&&(n=s,console.log(`‚úÖ Found Node.js in npm directory: ${n}`))}if(!n)try{const{execSync:e}=require("child_process"),s=e("where node",{encoding:"utf8",windowsHide:!0,stdio:["pipe","pipe","ignore"]}).trim();if(s){const e=s.split("\n").map(e=>e.trim()).filter(e=>e.endsWith(".exe"));e.length>0&&(n=e[0],console.log(`‚úÖ Found Node.js via PATH: ${n}`))}}catch(e){try{const e=execSync('powershell -Command "Get-Command node | Select-Object -ExpandProperty Source"',{encoding:"utf8",windowsHide:!0,stdio:["pipe","pipe","ignore"]}).trim();e&&e.endsWith(".exe")&&(n=e,console.log(`‚úÖ Found Node.js via PowerShell: ${n}`))}catch(e){console.error("‚ö†Ô∏è Could not find Node.js via where or PowerShell")}}const o=require("path"),r=o.dirname(t);console.log(`üìÇ Looking for Claude JS relative to: ${r}`);const a=[o.join(r,"node_modules","@anthropic-ai","claude-cli","bin","claude.js"),o.join(r,"..","@anthropic-ai","claude-cli","bin","claude.js"),o.join(r,"..","node_modules","@anthropic-ai","claude-cli","bin","claude.js"),o.join(process.env.APPDATA||"","npm","node_modules","@anthropic-ai","claude-cli","bin","claude.js"),t.replace(".cmd",".js"),t.replace("claude.cmd","..\\@anthropic-ai\\claude-cli\\bin\\claude.js"),o.join(r,"node_modules","claude","bin","claude.js"),o.join(r,"..","lib","node_modules","@anthropic-ai","claude-cli","bin","claude.js")].filter(Boolean);console.log(`üîç Checking ${a.length} possible paths for Claude JS...`);for(const e of a){const s=existsSync(e);if(console.log(`  ${s?"‚úÖ":"‚ùå"} ${e}`),s){i=e;break}}n&&i?(console.log("‚úÖ Using Node.js to run Claude directly:"),console.log(`  Node: ${n}`),console.log(`  Claude JS: ${i}`),t=n,e=[i,...e]):n?i||(console.error("‚ùå Could not find Claude JavaScript file"),console.error(`  Checked paths relative to: ${r}`),console.error(`  Node.js found at: ${n}`),console.log("‚ö†Ô∏è Falling back to .cmd file execution with shell")):(console.error("‚ùå Could not find Node.js executable"),console.error("  Checked standard paths and PATH environment"),console.error("  Please ensure Node.js is installed and in PATH"),console.log("‚ö†Ô∏è Falling back to .cmd file execution with shell"))}if(console.log("üñ•Ô∏è Creating native Windows Claude command"),console.log(`  Claude path: ${t}`),console.log(`  Working dir: ${s}`),console.log(`  Args: ${e.join(" ")}`),o){const s=require("fs"),n=require("path"),i=require("os"),r=n.join(i.tmpdir(),`yurucode-msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}.txt`);try{s.writeFileSync(r,o,"utf8"),console.log(`  Temp file: ${r} (${o.length} chars)`)}catch(e){throw console.error(`‚ùå Failed to write temp file: ${e.message}`),e}return[t,e,!0,r]}return[t,e,!1,null]}function getClaudeCommand(e,s,o){loadClaudeSettings();let t=s;if("native-windows"===CLAUDE_EXECUTION_MODE&&NATIVE_WINDOWS_CLAUDE_PATH)return console.log("üñ•Ô∏è Using native Windows Claude execution"),createNativeWindowsClaudeCommand(e,s,o);if("wsl"===CLAUDE_EXECUTION_MODE||isWindows&&!NATIVE_WINDOWS_CLAUDE_PATH)return console.log("üêß Using WSL Claude execution"),t=windowsToWslPath(s),createWslClaudeCommand(e,t,o);if("auto"===CLAUDE_EXECUTION_MODE){if(NATIVE_WINDOWS_CLAUDE_PATH)return console.log("ü§ñ Auto mode: Using native Windows Claude"),createNativeWindowsClaudeCommand(e,s,o);if(isWindows)return console.log("ü§ñ Auto mode: Falling back to WSL"),t=windowsToWslPath(s),createWslClaudeCommand(e,t,o)}return[CLAUDE_PATH,e,!1,null]}function createWslClaudeCommand(e,s,o){const t="C:\\Windows\\System32\\wsl.exe";if(!s)throw new Error("Working directory is required for WSL Claude command");const n=s;if(o){const{execFileSync:s}=require("child_process");let i=null,r="yuru";try{r=s(t,["-e","bash","-c","whoami"],{encoding:"utf8",windowsHide:!0}).trim(),console.log(`üîç WSL user: ${r}`)}catch(e){console.log(`‚ö†Ô∏è Could not detect WSL user, using default: ${r}`)}try{console.log("üîé Finding Claude path by sourcing .bashrc...");const e=s(t,["-e","bash","-c",`. /home/${r}/.bashrc 2>/dev/null && type claude 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim();if(e&&(console.log(`üîç 'type claude' output: ${e}`),e.includes("is aliased to"))){const s=e.match(/is aliased to [`']([^`']+)[`']/);s&&(i=s[1],console.log(`‚úÖ CLAUDE PATH FROM ALIAS: ${i}`))}}catch(e){console.log("‚ö†Ô∏è Could not get claude from .bashrc")}if(!i){const o=`/home/${r}/.claude/local/claude`;console.log(`üîé Checking known location: ${o}`);try{"yes"===s(t,["-e","bash","-c",`[ -f "${o}" ] && echo "yes"`],{encoding:"utf8",windowsHide:!0}).trim()&&(i=o,console.log(`‚úÖ CLAUDE FOUND AT: ${i}`))}catch(e){}}if(!i)try{i=s(t,["-e","bash","-c","which claude 2>/dev/null"],{encoding:"utf8",windowsHide:!0}).trim(),i&&console.log(`‚úÖ CLAUDE PATH FROM WHICH: ${i}`)}catch(e){}if(!i){const e=`Claude CLI not found in WSL. Checked: /home/${r}/.claude/local/claude. Please ensure Claude is installed.`;throw console.error(`‚ùå ${e}`),new Error(e)}const a=e.map(e=>e.includes(" ")||e.includes(":")||e.includes("(")||e.includes(")")||e.includes(",")?`'${e.replace(/'/g,"'\\''")}'`:e).join(" "),c=`/tmp/yurucode-msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}.txt`,l=require("fs"),d=require("path"),u=require("os"),g=d.join(u.tmpdir(),`yurucode-msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}.txt`);try{l.writeFileSync(g,o,"utf8")}catch(e){throw console.error(`‚ùå Failed to write temp file: ${e.message}`),e}const m=`/mnt/${g[0].toLowerCase()}${g.substring(2).replace(/\\/g,"/")}`,p=`trap 'rm -f "${c}"' EXIT; cd "${n}" && cat "${m}" > "${c}" && rm -f "${m}" && cat "${c}" | ${i} ${a} 2>&1`;return console.log("üîç WSL script (main message):"),console.log(`  Working dir: ${n}`),console.log(`  Claude path: ${i}`),console.log(`  Args: ${a}`),console.log(`  Message length: ${o.length} chars`),console.log(`  Windows temp file: ${g}`),console.log(`  WSL temp file: ${c}`),[t,["-e","bash","-c",p],!0,g]}{const{execFileSync:s}=require("child_process"),o="C:\\Windows\\System32\\wsl.exe";let t=null,i="user";try{i=s(o,["-e","bash","-c","whoami"],{encoding:"utf8",windowsHide:!0}).trim(),console.log(`üîç WSL user detected for title gen: ${i}`)}catch(e){console.warn("‚ö†Ô∏è Could not detect WSL user for title gen, using default")}const r=[`/home/${i}/.claude/local/node_modules/.bin/claude`,"~/.npm-global/bin/claude","~/node_modules/.bin/claude","/usr/local/bin/claude","/usr/bin/claude","~/.local/bin/claude"];for(const n of r)try{if("exists"===s(o,["-e","bash","-c",n.startsWith("~")?`[ -f "${n.replace("~","$HOME")}" ] && echo "exists"`:`[ -f "${n}" ] && echo "exists"`],{encoding:"utf8",windowsHide:!0}).trim()){if(n.startsWith("~")){const e=s(o,["-e","bash","-c","echo $HOME"],{encoding:"utf8",windowsHide:!0}).trim();t=n.replace("~",e)}else t=n;break}}catch(e){}if(!t)try{const e=s(o,["-e","bash","-c","which claude"],{encoding:"utf8",windowsHide:!0}).trim();e&&(t=e)}catch(e){}t||(t=`/home/${i}/.claude/local/node_modules/.bin/claude`,console.log(`‚ö†Ô∏è Claude not found for title gen, using default: ${t}`));const a=e.map(e=>e.includes(" ")||e.includes(":")||e.includes("(")||e.includes(")")||e.includes(",")?`'${e.replace(/'/g,"'\\''")}'`:e).join(" "),c=`cd "${n}" && ${t} ${a} 2>&1`;return console.log(`üîç WSL script (title gen) with args: ${a}`),[o,["-e","bash","-c",c],!1]}}if(isWindows)loadClaudeSettings(),console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"),console.log("üîç PLATFORM: Windows detected"),console.log("üîç CLAUDE EXECUTION MODE:",CLAUDE_EXECUTION_MODE),NATIVE_WINDOWS_CLAUDE_PATH&&console.log("‚úÖ Native Windows Claude available:",NATIVE_WINDOWS_CLAUDE_PATH),WSL_CLAUDE_PATH&&console.log("‚úÖ WSL Claude available:",WSL_CLAUDE_PATH),console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"),CLAUDE_PATH="native-windows"===CLAUDE_EXECUTION_MODE&&NATIVE_WINDOWS_CLAUDE_PATH?"NATIVE_WINDOWS_CLAUDE":"WSL_CLAUDE";else{const e=[join(homedir(),".npm-global/bin/claude"),"/opt/homebrew/bin/claude","/usr/local/bin/claude","/usr/bin/claude",process.env.CLAUDE_PATH].filter(Boolean);for(const s of e)try{if(existsSync(s)){CLAUDE_PATH=s,console.log(`‚úÖ Found Claude CLI at: ${CLAUDE_PATH}`);break}}catch(e){}if("claude"===CLAUDE_PATH)try{const e=execSync("which claude",{encoding:"utf8"}).trim();e&&(CLAUDE_PATH=e,console.log(`‚úÖ Found Claude CLI via which: ${CLAUDE_PATH}`))}catch(e){}if("claude"===CLAUDE_PATH)try{const e=execSync("whereis claude",{encoding:"utf8"}).trim().match(/claude:\s+(.+)/);if(e&&e[1]){const s=e[1].split(/\s+/);for(const e of s)if(existsSync(e)){CLAUDE_PATH=e,console.log(`‚úÖ Found Claude CLI via whereis: ${CLAUDE_PATH}`);break}}}catch(e){console.warn("‚ö†Ô∏è Claude CLI not found via whereis. Using 'claude' and hoping for the best.")}}const express=require("express"),cors=require("cors"),net=require("net"),app=express(),httpServer=createServer(app),io=new Server(httpServer,{cors:{origin:"*",methods:["GET","POST"]},transports:["websocket","polling"],pingTimeout:12e5,pingInterval:3e4,upgradeTimeout:6e4,maxHttpBufferSize:5e8,perMessageDeflate:!1,httpCompression:!1});app.use(cors()),app.use(express.json());const PORT=(()=>{if(process.env.PORT){const e=parseInt(process.env.PORT);return console.log(`‚úÖ Using PORT from Rust: ${e}`),e}console.log("üîç Finding available port in range 60000-61000...");let e=6e4+Math.floor(1001*Math.random());for(let s=0;s<100;s++){const o=6e4+(e-6e4+s)%1001,t=net.createServer();try{return t.listen(o,"127.0.0.1"),t.close(),console.log(`‚úÖ Found available port: ${o}`),o}catch(e){}}return console.log("‚ö†Ô∏è Could not find available port, using 3001"),3001})();let sessions=new Map,activeProcesses=new Map,activeProcessStartTimes=new Map,activeBashProcesses=new Map,lastAssistantMessageIds=new Map,allAssistantMessageIds=new Map,streamHealthChecks=new Map,streamTimeouts=new Map,isSpawningProcess=!1;const processSpawnQueue=[];async function generateTitle(e,s,o,t){try{console.log(`üè∑Ô∏è Generating title for session ${e}`),console.log(`üè∑Ô∏è Message preview: "${s}"`);const n=`user message: "${s.substring(0,200)}"\ntask: reply with ONLY 1-3 words describing what user wants. lowercase only. no punctuation. be extremely concise. examples: "echo command", "file search", "debug issue"`,i=["-p",n,"--print","--output-format","json","--model","claude-sonnet-4-5-20250929"];console.log(`üè∑Ô∏è Title prompt: "${n}"`);const r={...process.env},a="/opt/homebrew/bin";r.PATH?.includes(a)||(r.PATH=`${a}:${r.PATH||"/usr/bin:/bin"}`);const c=join(homedir(),".yurucode-title-gen");try{if(!existsSync(c)){const{mkdirSync:e}=require("fs");e(c,{recursive:!0}),console.log("üìÅ Created title generation directory:",c)}}catch(e){console.log("‚ö†Ô∏è Could not create title gen directory, using home:",e.message)}const l=isWindows?(()=>{const[e,s,o,t]=getClaudeCommand(i,c,null);if("C:\\Windows\\System32\\wsl.exe"===e){const{execSync:s}=require("child_process");let o="user";try{o=s('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){}const t=`/home/${o}/.yurucode-title-gen`;try{s(`C:\\Windows\\System32\\wsl.exe -e bash -c "mkdir -p ${t}"`,{windowsHide:!0})}catch(e){console.log("‚ö†Ô∏è Could not create WSL title gen directory:",e.message)}}const n={cwd:c,env:r,stdio:["pipe","pipe","pipe"],windowsHide:!0,detached:!1};if((e.endsWith(".cmd")||e.endsWith(".bat"))&&!e.endsWith("node.exe")){n.shell=!0;const e=["C:\\Program Files\\nodejs","C:\\Program Files (x86)\\nodejs",process.env.ProgramFiles+"\\nodejs"].filter(Boolean);for(const s of e)if(existsSync(s)){n.env={...n.env},n.env.PATH=s+";"+(n.env.PATH||process.env.PATH),console.log(`‚úÖ Added Node.js to PATH for .cmd execution: ${s}`);break}}return spawn(e,s,n)})():spawn(CLAUDE_PATH,i,{cwd:c,env:r,stdio:["pipe","pipe","pipe"],windowsHide:!0,detached:!1});let d="",u="";l.stdout.on("data",e=>{d+=e.toString(),console.log(`üè∑Ô∏è Title generation stdout: ${e.toString()}`)}),l.stderr.on("data",e=>{u+=e.toString(),console.log(`üè∑Ô∏è Title generation stderr: ${e.toString()}`)}),l.on("close",s=>{console.log(`üè∑Ô∏è Title generation process closed with code ${s}`),console.log(`üè∑Ô∏è Full output: "${d}"`),u&&console.log(`üè∑Ô∏è Error output: "${u}"`);try{const s=d.trim().split("\n"),n=s[s.length-1];console.log(`üè∑Ô∏è Parsing last line: "${n}"`);const i=JSON.parse(n),r=i.completion||i.result;if(r){let s=r.toLowerCase().replace(/[^\w\s]/g,"").trim().substring(0,30);if(s&&s.length>2){console.log(`üè∑Ô∏è Generated title: "${s}" - emitting to client`);const n=`title:${e}`;console.log(`üè∑Ô∏è Emitting event: ${n} with data:`,{title:s}),o.emit(n,{title:s}),t&&t()}else console.log(`üè∑Ô∏è Title too short or empty: "${s}"`)}else console.log("üè∑Ô∏è No title text in response:",i)}catch(e){console.error("üè∑Ô∏è Failed to parse title response:",e),console.error("üè∑Ô∏è Raw output was:",d)}}),l.on("error",e=>{console.error("üè∑Ô∏è Failed to spawn title generation process:",e)}),l.stdin.end()}catch(e){console.error("üè∑Ô∏è Failed to generate title:",e)}}const MAX_MESSAGE_HISTORY=1e3,MAX_LINE_BUFFER_SIZE=52428800;app.get("/health",(e,s)=>{s.json({status:"ok",pid:process.pid,service:"yurucode-claude",claudeCodeLoaded:!0})}),app.delete("/claude-project/:projectPath",async(e,s)=>{try{const{projectPath:o}=e.params,t=join(homedir(),".claude","projects",o);if(console.log("Deleting project:",t),!existsSync(t))return s.status(404).json({error:"project not found"});const{rm:n}=await import("fs/promises");await n(t,{recursive:!0,force:!0}),console.log("Project deleted successfully"),s.json({success:!0})}catch(e){console.error("Error deleting project:",e),s.status(500).json({error:"Failed to delete project",details:e.message})}}),app.delete("/claude-session/:projectPath/:sessionId",async(e,s)=>{try{const{projectPath:o,sessionId:t}=e.params,n=join(homedir(),".claude","projects",o,`${t}.jsonl`);if(console.log("Deleting session:",n),!existsSync(n))return s.status(404).json({error:"session not found"});const{unlink:i}=await import("fs/promises");await i(n),console.log("Session deleted successfully"),s.json({success:!0})}catch(e){console.error("Error deleting session:",e),s.status(500).json({error:"Failed to delete session",details:e.message})}}),app.get("/claude-session/:projectPath/:sessionId",async(e,s)=>{try{const{projectPath:o,sessionId:t}=e.params;if(console.log("Loading session request:"),console.log("  - Raw projectPath:",o),console.log("  - SessionId:",t),console.log("  - Platform:",platform()),isWindows){let n="user";try{const{execSync:e}=require("child_process");n=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const i=`/home/${n}/.claude/projects/${o}/${t}.jsonl`;console.log("  - WSL path:",i);try{const{execSync:n}=require("child_process"),r=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'cat \\"${i}\\" 2>/dev/null'}"`,{encoding:"utf8",windowsHide:!0,maxBuffer:52428800});console.log("Raw file content:",r.replace(/\n/g,"\\n").replace(/\r/g,"\\r")),console.log("Total file size:",r.length,"characters");const a=r[r.length-1];console.log("File ends with:","\n"===a?"newline":"$"===a?"dollar":"char: "+a);const c=[];let l=0,d=0,u=0,g=0;for(;l<r.length;){for(g++;l<r.length&&/\s/.test(r[l]);)l++;if(l>=r.length)break;if("{"!==r[l]){console.log("Warning: Expected { at position",l,"but found:",r[l]);const e=r.indexOf("\n",l);if(-1===e)break;l=e+1;continue}let s=0,o=!1,t=!1,n=-1;for(let e=l;e<r.length;e++){const i=r[e];if(t)t=!1;else if("\\"!==i)if('"'!==i||t){if(!o)if("{"===i)s++;else if("}"===i&&(s--,0===s)){if(!(e+1<r.length)){n=e+1;break}{const s=r[e+1];if("$"===s||"\n"===s||"\r"===s){n=e+1;break}}}}else o=!o;else t=!0}if(-1===n){console.log("Warning: Could not find end of JSON object starting at position",l);break}const i=r.substring(l,n);try{const e=JSON.parse(i);if("user"===e.role){if(!e.content){l=n,l<r.length&&"$"===r[l]&&l++,l<r.length&&"\n"===r[l]&&l++,l<r.length&&"\r"===r[l]&&l++;continue}if(!("string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.length>0?e.content.map(e=>e.text||"").join(""):"").trim()){l=n,l<r.length&&"$"===r[l]&&l++,l<r.length&&"\n"===r[l]&&l++,l<r.length&&"\r"===r[l]&&l++;continue}}c.push(e),d++,d<=5&&("summary"===e.type?console.log(`Line ${g}: Added summary:`,e.summary||""):"user"===e.type?console.log(`Line ${g}: Added user message`):"assistant"===e.type?console.log(`Line ${g}: Added assistant message`):e.sessionId&&console.log(`Line ${g}: Added session metadata`))}catch(e){u++,u<=5&&(console.log(`Failed to parse JSON at line ${g}, position ${l}:`,e.message),console.log("JSON output:",i))}l=n,l<r.length&&"$"===r[l]&&l++,l<r.length&&"\n"===r[l]&&l++,l<r.length&&"\r"===r[l]&&l++}console.log(`Processed ${g} lines, successfully parsed ${d} JSON objects from session file`);const m=o.replace(/^([A-Z])--/,"$1:/").replace(/^-/,"/").replace(/-/g,"/");console.log(`Loaded session with ${c.length} messages`),console.log(`Converted project path: ${o} -> ${m}`);let p=null;if(c.length>0){const e=c[c.length-1];("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(p=e.title)}if(!p){const e=c.find(e=>"summary"===e.type&&e.summary);e&&(p=e.summary)}if(!p){const e=c.find(e=>"user"===e.role&&e.content);if(e){const s="string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.find(e=>"text"===e.type)?.text||"";s&&(p=s.substring(0,100))}}p||(p="Untitled session"),s.json({sessionId:t,projectPath:m,messages:c,sessionCount:c.length,title:p})}catch(e){console.error("Error reading session file from WSL:",e.message),s.status(404).json({error:"Session not found"})}}else{const n=join(homedir(),".claude","projects",o,`${t}.jsonl`);if(console.log("  - Full path:",n),!existsSync(n))return console.error("Session not found:",n),s.status(404).json({error:"session not found"});const{readFile:i}=await import("fs/promises");try{const r=await i(n,"utf8"),a=[],c=r.split(/\$|\n/).filter(e=>e.trim());for(const s of c)try{const e=JSON.parse(s);if("user"===e.role){if(!e.content)continue;if(!("string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.length>0?e.content.map(e=>e.text||"").join(""):"").trim())continue}a.push(e)}catch(e){}let l=null;if(a.length>0){const e=a[a.length-1];("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(l=e.title)}if(!l){const e=a.find(e=>"summary"===e.type&&e.summary);e&&(l=e.summary)}if(!l){const e=a.find(e=>"user"===e.role&&e.content);if(e){const s="string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.find(e=>"text"===e.type)?.text||"";s&&(l=s.substring(0,100))}}l||(l="Untitled session");const d=o.replace(/^([A-Z])--/,"$1:/").replace(/^-/,"/").replace(/-/g,"/");s.json({sessionId:t,projectPath:d,messages:a,sessionCount:a.length,title:l})}catch(e){console.error("Error reading session file:",e),s.status(500).json({error:"Failed to read session",details:e.message})}}}catch(e){console.error("Error loading session:",e),s.status(500).json({error:"Failed to load session",details:e.message})}}),app.get("/claude-analytics",async(e,s)=>{console.log("üìä Loading analytics from all Claude sessions...");try{const o={totalSessions:0,totalMessages:0,totalTokens:0,totalCost:0,tokenBreakdown:{input:0,output:0,cacheCreation:0,cacheRead:0},byModel:{opus:{sessions:0,tokens:0,cost:0},sonnet:{sessions:0,tokens:0,cost:0}},byDate:{},byProject:{}};if(isWindows){const{readdir:s,readFile:t,stat:n}=await import("fs/promises"),i=await import("path"),r=["yuru","muuko",process.env.USER,process.env.USERNAME].filter(Boolean),a=["Ubuntu","Ubuntu-20.04","Ubuntu-22.04","Ubuntu-24.04"],c=["\\\\wsl$","\\\\wsl.localhost"];console.log("üìä Analytics: Searching for WSL Claude projects..."),console.log("  Possible users:",r),console.log("  Possible distros:",a);let l=null,d=0;for(const s of c){for(const o of a){for(const t of r){const i=`${s}\\${o}\\home\\${t}\\.claude\\projects`;d++;try{await n(i),l=i,console.log(`‚úÖ Found WSL Claude projects at: ${i} (attempt ${d})`);break}catch(e){}}if(l)break}if(l)break}if(l||console.log(`‚ùå WSL Claude projects not found after ${d} attempts`),l)try{const r=await s(l);console.log(`Found ${r.length} projects in WSL directory`);const a=10;for(const c of r.slice(0,a)){const r=i.win32.join(l,c);try{if(!(await n(r)).isDirectory())continue;console.log(`Processing WSL project: ${c}`);const a=(await s(r)).filter(e=>e.endsWith(".jsonl"));console.log(`  Found ${a.length} session files`);const l=20;for(const s of a.slice(0,l))try{const a=i.win32.join(r,s),l=await n(a);if(l.size>10485760){console.log(`  Skipping large file: ${s} (${l.size} bytes)`);continue}console.log(`  Reading session: ${s} (${l.size} bytes)`);const d=(await t(a,"utf8")).split("\n").filter(e=>e.trim());console.log(`    Total lines in file: ${d.length}`);let u=0,g=0,m="sonnet",p=(new Date).toISOString().split("T")[0],h=0;for(const s of d)try{const e=JSON.parse(s);if("assistant"===e.type&&e.message&&e.message.usage){const s=e.message.usage,t=s.input_tokens||0,n=s.output_tokens||0,i=s.cache_creation_input_tokens||0,r=s.cache_read_input_tokens||0;u+=t+n+i,e.message&&e.message.model&&(m=e.message.model.toLowerCase().includes("opus")?"opus":"sonnet");const a="opus"===m;g+=t*(a?15e-6:3e-6)+n*(a?75e-6:15e-6)+i*(a?1875e-8:375e-8)+r*(a?15e-7:3e-7),o.tokenBreakdown.input+=t,o.tokenBreakdown.output+=n,o.tokenBreakdown.cacheCreation+=i,o.tokenBreakdown.cacheRead+=r}"user"!==e.type&&"assistant"!==e.type||h++,e.timestamp&&(p=new Date(e.timestamp).toISOString().split("T")[0])}catch(e){}if(console.log(`    Parsed: ${h} messages, ${u} tokens`),u>0){console.log(`    Session: ${u} tokens, $${g.toFixed(4)}`),o.totalSessions++,o.totalMessages+=2*h,o.totalTokens+=u,o.totalCost+=g;const e="opus"===m?"opus":"sonnet";o.byModel[e].sessions++,o.byModel[e].tokens+=u,o.byModel[e].cost+=g,o.byDate[p]||(o.byDate[p]={sessions:0,messages:0,tokens:0,cost:0}),o.byDate[p].sessions++,o.byDate[p].messages+=2*h,o.byDate[p].tokens+=u,o.byDate[p].cost+=g;const s=c.replace(/-/g,"/");o.byProject[s]||(o.byProject[s]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:l.mtime.getTime()}),o.byProject[s].sessions++,o.byProject[s].messages+=2*h,o.byProject[s].tokens+=u,o.byProject[s].cost+=g}}catch(e){console.error(`  Error processing session ${s}:`,e.message)}}catch(e){console.error(`Error processing project ${c}:`,e.message)}}}catch(e){console.error("Error reading WSL projects directory:",e.message),l=null}if(!l){console.log("WSL mount not accessible, trying Windows path...");const r=i.win32.join(homedir(),".claude","projects");try{const a=await s(r);console.log(`Found ${a.length} projects in Windows directory`);for(const c of a.slice(0,5)){const a=i.win32.join(r,c);if(!(await n(a)).isDirectory())continue;console.log(`Processing Windows project: ${c}`);const l=(await s(a)).filter(e=>e.endsWith(".jsonl"));console.log(`  Found ${l.length} session files`);for(const s of l.slice(0,10))try{const r=i.win32.join(a,s),l=await n(r);if(l.size>10485760){console.log(`  Skipping large file: ${s} (${l.size} bytes)`);continue}console.log(`  Reading session: ${s} (${l.size} bytes)`);const d=(await t(r,"utf8")).split("\n").filter(e=>e.trim());console.log(`    Total lines in file: ${d.length}`);let u=0,g=0,m="sonnet",p=(new Date).toISOString().split("T")[0],h=0;for(const s of d)try{const e=JSON.parse(s);if("assistant"===e.type&&e.message&&e.message.usage){const s=e.message.usage,t=s.input_tokens||0,n=s.output_tokens||0,i=s.cache_creation_input_tokens||0,r=s.cache_read_input_tokens||0;u+=t+n+i,e.message&&e.message.model&&(m=e.message.model.toLowerCase().includes("opus")?"opus":"sonnet");const a="opus"===m;g+=t*(a?15e-6:3e-6)+n*(a?75e-6:15e-6)+i*(a?1875e-8:375e-8)+r*(a?15e-7:3e-7),o.tokenBreakdown.input+=t,o.tokenBreakdown.output+=n,o.tokenBreakdown.cacheCreation+=i,o.tokenBreakdown.cacheRead+=r}"user"!==e.type&&"assistant"!==e.type||h++,e.timestamp&&(p=new Date(e.timestamp).toISOString().split("T")[0])}catch(e){}if(console.log(`    Parsed: ${h} messages, ${u} tokens`),u>0){console.log(`    Session: ${u} tokens, $${g.toFixed(4)}`),o.totalSessions++,o.totalMessages+=2*h,o.totalTokens+=u,o.totalCost+=g;const e="opus"===m?"opus":"sonnet";o.byModel[e].sessions++,o.byModel[e].tokens+=u,o.byModel[e].cost+=g,o.byDate[p]||(o.byDate[p]={sessions:0,messages:0,tokens:0,cost:0}),o.byDate[p].sessions++,o.byDate[p].messages+=2*h,o.byDate[p].tokens+=u,o.byDate[p].cost+=g;const s=c.replace(/-/g,"/");o.byProject[s]||(o.byProject[s]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:l.mtime.getTime()}),o.byProject[s].sessions++,o.byProject[s].messages+=2*h,o.byProject[s].tokens+=u,o.byProject[s].cost+=g}}catch(e){console.error(`  Error processing session ${s}:`,e.message)}}}catch(e){console.error("Error reading Windows projects:",e.message)}}}else{const{readdir:s,readFile:t,stat:n}=await import("fs/promises"),i=join(homedir(),".claude","projects");try{const r=await s(i);for(const a of r){const r=join(i,a);if(!(await n(r)).isDirectory())continue;const c=(await s(r)).filter(e=>e.endsWith(".jsonl"));for(const s of c)try{const n=join(r,s),i=(await t(n,"utf8")).split("\n").filter(e=>e.trim());let c=0,l=0,d="sonnet",u=(new Date).toISOString().split("T")[0],g=0;for(const s of i)try{const e=JSON.parse(s);if("assistant"===e.type&&e.message&&e.message.usage){const s=e.message.usage,t=s.input_tokens||0,n=s.output_tokens||0,i=s.cache_creation_input_tokens||0,r=s.cache_read_input_tokens||0;c+=t+n+i,e.message&&e.message.model&&(d=e.message.model.toLowerCase().includes("opus")?"opus":"sonnet");const a="opus"===d;l+=t*(a?15e-6:3e-6)+n*(a?75e-6:15e-6)+i*(a?1875e-8:375e-8)+r*(a?15e-7:3e-7),o.tokenBreakdown.input+=t,o.tokenBreakdown.output+=n,o.tokenBreakdown.cacheCreation+=i,o.tokenBreakdown.cacheRead+=r}"user"!==e.type&&"assistant"!==e.type||g++,e.timestamp&&(u=new Date(e.timestamp).toISOString().split("T")[0])}catch(e){}(c>0||g>0)&&(o.totalSessions++,o.totalMessages+=g,o.totalTokens+=c,o.totalCost+=l,"opus"===d?(o.byModel.opus.sessions++,o.byModel.opus.tokens+=c,o.byModel.opus.cost+=l):(o.byModel.sonnet.sessions++,o.byModel.sonnet.tokens+=c,o.byModel.sonnet.cost+=l),o.byDate[u]||(o.byDate[u]={sessions:0,messages:0,tokens:0,cost:0}),o.byDate[u].sessions++,o.byDate[u].messages+=2*i.length,o.byDate[u].tokens+=c,o.byDate[u].cost+=l,o.byProject[a]||(o.byProject[a]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:Date.now()}),o.byProject[a].sessions++,o.byProject[a].messages+=g,o.byProject[a].tokens+=c,o.byProject[a].cost+=l)}catch(e){console.error(`Error processing session ${s}:`,e.message)}}}catch(e){console.error("Error reading projects directory:",e)}}console.log(`üìä Analytics loaded: ${o.totalSessions} sessions, ${o.totalTokens} tokens`),s.json(o)}catch(e){console.error("Error loading analytics:",e),s.status(500).json({error:"Failed to load analytics",details:e.message})}}),app.get("/claude-projects-quick",async(e,s)=>{try{const o=parseInt(e.query.limit)||20,t=parseInt(e.query.offset)||0;if(isWindows){console.log("üîç Windows detected - loading projects from WSL");let n="user";try{const{execSync:e}=require("child_process");n=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const i=`/home/${n}/.claude/projects`;try{const{execFileSync:n}=require("child_process"),r="C:\\Windows\\System32\\wsl.exe",a=`cd "${i}" && for d in *; do [ -d "$d" ] && echo "$d"; done`;console.log("üìÇ Getting projects from WSL:",i);const c=n(r,["-e","bash","-c",a],{encoding:"utf8",windowsHide:!0}).trim();if(!c)return console.log("‚ùå No projects found in WSL"),s.json({projects:[],count:0});const l=c.split("\n").filter(e=>e.trim()).filter(e=>{const s=e.toLowerCase();return!(s.includes("temp")||s.includes("tmp")||s.includes("yurucode-server")||s.includes("yurucode-title-gen")||"-yurucode-title-gen"===s||s.includes("appdata")||s.includes("-mnt-c-users-")&&s.includes("-appdata-local-temp"))||(console.log(`üö´ Filtering out temp/server/title-gen directory: ${e}`),!1)}),d=[];for(const s of l){let o=0;try{const e=n(r,["-e","bash","-c",`cd ${i}/${s} && ls -t *.jsonl 2>/dev/null | head -1 | xargs -r stat -c %Y 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim();e&&!isNaN(e)&&(o=1e3*parseInt(e))}catch(e){o=0}let t=0;try{const e=n(r,["-e","bash","-c",`ls -1 ${i}/"${s}"/*.jsonl 2>/dev/null | wc -l`],{encoding:"utf8",windowsHide:!0}).trim();t=parseInt(e)||0}catch(e){}0===t&&0===o||d.push({name:s,path:s,lastModified:o,sessionCount:t,sessions:[]})}d.sort((e,s)=>s.lastModified-e.lastModified),console.log(`‚úÖ Found ${d.length} projects in WSL`);const u=d.length,g=d.slice(t,t+o);return console.log(`üìÑ Returning ${g.length} projects (offset: ${t}, limit: ${o}, total: ${u})`),void s.json({projects:g,count:u})}catch(e){return console.error("‚ùå ERROR loading Windows projects:",e.message),console.error("Stack:",e.stack),s.json({projects:[],count:0})}}const n=join(homedir(),".claude","projects");if(console.log("Quick loading project list from:",n),!existsSync(n))return console.log("Claude projects directory not found:",n),s.json({projects:[],count:0});const{readdir:i,stat:r}=await import("fs/promises"),a=(await i(n)).filter(e=>!e.startsWith(".")).map(async e=>{try{const s=join(n,e),o=await r(s);if(!o.isDirectory())return null;const t=(await i(s)).filter(e=>e.endsWith(".jsonl")).length;return{path:e,name:e,sessionCount:isWindows&&0===t?null:t,lastModified:o.mtime.getTime()}}catch{return null}}),c=(await Promise.all(a)).filter(Boolean);c.sort((e,s)=>s.lastModified-e.lastModified);const l=c.length,d=c.slice(t,t+o);console.log(`Quick loaded ${d.length} of ${l} project names (offset: ${t}, limit: ${o})`),s.json({projects:d,count:l})}catch(e){console.error("Error quick loading projects:",e),s.status(500).json({error:"Failed to load projects",details:e.message})}}),app.get("/claude-project-sessions/:projectName",async(e,s)=>{try{const o=decodeURIComponent(e.params.projectName);if(console.log("üìÇ Loading sessions for project:",o),s.writeHead(200,{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"}),isWindows){let t="user";try{const{execSync:e}=require("child_process");t=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const n=`/home/${t}/.claude/projects/${o}`;try{console.log("üöÄ Getting session list from WSL:",n);const{execFileSync:o}=require("child_process"),t=o("C:\\Windows\\System32\\wsl.exe",["-e","bash","-c",`cd "${n}" 2>/dev/null && for f in *.jsonl; do [ -f "$f" ] && stat -c "%Y:%n" -- "$f"; done | sort -rn | head -50`],{encoding:"utf8",windowsHide:!0}).trim();if(!t)return console.log("No sessions found"),s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();const i=t.split("\n").filter(e=>e.trim()).map(e=>{const[s,o]=e.split(":");return{filename:o,timestamp:1e3*parseInt(s)}}).sort((e,s)=>s.timestamp-e.timestamp).slice(0,10);if(0===i.length)return console.log("No sessions found"),s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();for(let t=0;t<i.length;t++){const{filename:r,timestamp:a}=i[t];try{if(t>=50)break;const c="C:\\Windows\\System32\\wsl.exe",l=o(c,["-e","bash","-c",`head -n1 "${n}/${r}" 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim(),d=o(c,["-e","bash","-c",`tail -n1 "${n}/${r}" 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim(),u=o(c,["-e","bash","-c",`head -n50 "${n}/${r}" 2>/dev/null | wc -l`],{encoding:"utf8",windowsHide:!0}).trim(),g=r.replace(".jsonl","");let m="Untitled session",p=null;try{const e=JSON.parse(d);("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(p=e.title)}catch(e){}if(!p)try{const e=JSON.parse(l);if(e.summary&&(m=e.summary,p||(p=e.summary)),e.title&&(p=e.title),!p&&"user"===e.role&&e.content)if("string"==typeof e.content)m=e.content.substring(0,100),p=m;else if(Array.isArray(e.content)){const s=e.content.find(e=>"text"===e.type);s&&s.text&&(m=s.text.substring(0,100),p=m)}"summary"===e.type&&e.summary&&(p=e.summary,m=e.summary)}catch(e){console.log(`Could not parse session title from: ${l}`)}const h={id:g,summary:m,title:p,timestamp:a,path:r,messageCount:parseInt(u)||0};s.write(`data: ${JSON.stringify({session:h,index:t,total:i.length})}\n\n`),console.log(`  üìÑ Sent session ${t+1}/${i.length}: ${g}`)}catch(e){console.log(`Error processing ${r}:`,e.message)}}s.write('data: {"done": true}\n\n'),console.log("‚úÖ Streamed all sessions"),s.end()}catch(e){console.error("Error loading sessions:",e.message),s.write('data: {"error": true, "message": "'+e.message+'"}\n\n'),s.end()}}else{const t=path.join(os.homedir(),".claude","projects",o);try{if(!fs.existsSync(t))return console.log("Project directory not found:",t),s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();const n=fs.readdirSync(t).filter(e=>e.endsWith(".jsonl")).map(e=>{const s=path.join(t,e);return{filename:e,fullPath:s,timestamp:fs.statSync(s).mtimeMs}}).sort((e,s)=>s.timestamp-e.timestamp);if(console.log(`Found ${n.length} sessions in project`),0===n.length)return s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();for(let t=0;t<Math.min(n.length,50);t++){const{filename:i,fullPath:r,timestamp:a}=n[t];try{const c=fs.readFileSync(r,"utf8").split("\n")[0];if(!c)continue;const l=JSON.parse(c),d=l.uuid||i.replace(".jsonl",""),u={id:d,name:l.project_path||"Untitled",createdAt:new Date(a).toISOString(),messageCount:0,projectName:o};try{const e=fs.readFileSync(r,"utf8");u.messageCount=e.split("\n").filter(e=>e.trim()).length}catch(e){}s.write(`data: ${JSON.stringify({session:u,index:t,total:n.length})}\n\n`),console.log(`  üìÑ Sent session ${t+1}/${n.length}: ${d}`)}catch(e){console.log(`Error processing ${i}:`,e.message)}}s.write('data: {"done": true}\n\n'),console.log("‚úÖ Streamed all sessions"),s.end()}catch(e){console.error("Error loading sessions:",e.message),s.write('data: {"error": true, "message": "'+e.message+'"}\n\n'),s.end()}}}catch(e){console.error("Error loading project sessions:",e),s.write('data: {"error": true, "message": "Failed to load sessions"}\n\n'),s.end()}}),app.get("/claude-project-date/:projectName",async(e,s)=>{try{const o=decodeURIComponent(e.params.projectName);if(console.log(`üìÖ Getting date for project: ${o}`),isWindows){let t="yuru";try{const{execSync:e}=require("child_process");t=e('powershell.exe -NoProfile -Command "& {wsl.exe whoami}"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){}const n=`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'cd /home/${t}/.claude/projects/${o} && ls -t *.jsonl 2>/dev/null | head -1 | xargs -r stat -c %Y 2>/dev/null'}"`,{execSync:i}=require("child_process"),r=i(n,{encoding:"utf8",windowsHide:!0}).trim();let a=Date.now();if(r&&!isNaN(r)){a=1e3*parseInt(r);const e=new Date(a);console.log(`  ‚úÖ ${o}: ${e.toLocaleString()} (${r})`)}else console.log(`  ‚ö†Ô∏è ${o}: No sessions found, using current time`);s.json({projectName:o,lastModified:a})}else{const t=path.join(os.homedir(),".claude","projects",o);let n=Date.now();try{fs.existsSync(t)&&(n=fs.statSync(t).mtimeMs)}catch(e){console.log(`  ‚ö†Ô∏è ${o}: Error getting date, using current time`)}s.json({projectName:o,lastModified:n})}}catch(o){console.error("Error getting project date:",o),s.json({projectName:e.params.projectName,lastModified:Date.now()})}}),app.get("/claude-project-session-count/:projectName",async(e,s)=>{try{const o=decodeURIComponent(e.params.projectName);if(isWindows){let t="user";try{const{execSync:e}=require("child_process");t=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const n=`/home/${t}/.claude/projects/${o}`;try{const{execSync:e}=require("child_process"),t=e(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'ls -1 ${n}/*.jsonl 2>/dev/null | wc -l'}"`,{encoding:"utf8",windowsHide:!0}).trim(),i=parseInt(t)||0;s.json({projectName:o,sessionCount:i})}catch(e){s.json({projectName:o,sessionCount:0})}}else{const t=path.join(os.homedir(),".claude","projects"),n=path.join(t,o);try{const e=(await fs.promises.readdir(n)).filter(e=>e.endsWith(".jsonl")).length;console.log(`[Session Count] Project: ${o}, Count: ${e}`),s.json({projectName:o,sessionCount:e})}catch(e){console.error(`[Session Count] Error counting sessions for ${o}:`,e),s.json({projectName:o,sessionCount:0})}}}catch(e){s.status(500).json({error:"Failed to get session count"})}}),app.get("/claude-projects",async(e,s)=>{try{if(isWindows){console.log("üö® WINDOWS DETECTED - LOADING FROM WSL ONLY!");try{let o="yuru";try{const{execSync:e}=require("child_process");console.log("üîç Detecting WSL user via PowerShell...");const s='powershell.exe -NoProfile -Command "& {wsl.exe whoami}"';console.log("üíª PowerShell command:",s),o=e(s,{encoding:"utf8",windowsHide:!0}).trim(),console.log("‚úÖ WSL user found:",o)}catch(s){console.log("‚ö†Ô∏è Could not detect WSL user, using default:",o),console.log("  Error:",s.message)}const t=`/home/${o}/.claude/projects`;console.log("üìÇ WSL projects directory:",t),console.log("üîç WSL user detected:",o);const{execSync:n}=require("child_process");console.log("üîß Executing WSL command via PowerShell to list projects...");const i=`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'if [ -d ${t} ]; then ls -1 ${t}; else echo NO_PROJECTS_DIR; fi'}"`;console.log("üíª PowerShell command:",i);const r=n(i,{encoding:"utf8",windowsHide:!0}).trim();if(console.log("üìù Raw PowerShell/WSL output:",JSON.stringify(r)),!r||"NO_PROJECTS_DIR"===r||"ECHO is on."===r||r.includes("system cannot find"))return console.log("‚ùå No projects found or WSL error"),s.json({projects:[]});const a=r.split("\n").filter(e=>e&&!e.startsWith(".")&&"NO_DIR"!==e).filter(e=>{const s=e.toLowerCase();return!(s.includes("temp")||s.includes("tmp")||s.includes("yurucode-server")||s.includes("yurucode-title-gen")||"-yurucode-title-gen"===s||s.includes("appdata")||s.includes("-mnt-c-users-")&&s.includes("-appdata-local-temp"))||(console.log(`üö´ Filtering out temp/server/title-gen directory: ${e}`),!1)});console.log(`‚úÖ Found ${a.length} projects in WSL (after filtering):`,a);const c=[];for(const o of a){const i=`${t}/${o}`,r=[];try{const s=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'find ${i} -name *.jsonl -type f -exec basename {} .jsonl \\\\; 2>/dev/null'}"`,{encoding:"utf8",windowsHide:!0,shell:!0}).trim();if(s){const o=s.split("\n").filter(e=>e);for(const s of o.slice(0,5)){const o=`${i}/${s}.jsonl`;let t="untitled session",a=0,c=Date.now();try{const s=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'wc -l < ${o}'}"`,{encoding:"utf8",windowsHide:!0}).trim();a=parseInt(s)||0;const i=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'head -n1 ${o}'}"`,{encoding:"utf8",windowsHide:!0}).trim();if(i)try{const e=JSON.parse(i);e.summary?t=e.summary:"user"===e.role&&e.content&&(t=e.content.slice(0,100),e.content.length>100&&(t+="..."))}catch(e){}const r=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'stat -c %Y ${o}'}"`,{encoding:"utf8",windowsHide:!0}).trim();c=1e3*parseInt(r)||Date.now()}catch(e){}r.push({id:s,summary:t,timestamp:c,createdAt:c,path:o,messageCount:a})}}}catch(s){console.log(`Error loading sessions for ${o}:`,s.message)}r.length>0&&(r.sort((e,s)=>s.timestamp-e.timestamp),c.push({path:o,name:o,sessions:r,lastModified:r[0].timestamp,createdAt:Math.min(...r.map(e=>e.timestamp)),sessionCount:r.length,totalMessages:r.reduce((e,s)=>e+s.messageCount,0)}))}return c.sort((e,s)=>s.lastModified-e.lastModified),console.log(`‚úÖ Returning ${c.length} projects from WSL`),console.log("üìä Full projects data:",JSON.stringify(c,null,2).slice(0,500)),s.json({projects:c})}catch(e){return console.error("‚ùå ERROR loading WSL projects:",e.message),console.error("Stack:",e.stack),s.json({projects:[],count:0})}}const o=join(homedir(),".claude","projects");if(console.log("Loading projects from:",o),console.log("Platform:",platform()),!existsSync(o))return console.log("Claude projects directory not found:",o),s.json({projects:[]});const{readdir:t,stat:n,readFile:i}=await import("fs/promises"),r=await t(o);console.log(`Found ${r.length} project directories`);const a=r.filter(e=>!e.startsWith(".")).map(async e=>{try{const s=join(o,e),r=await n(s);if(!r.isDirectory())return null;const a=(await t(s)).filter(e=>e.endsWith(".jsonl")).map(async e=>{try{const o=join(s,e),t=await n(o),r=e.replace(".jsonl","");let a="untitled session",c=0,l="";try{const e=(await i(o,"utf8")).split(/\r?\n/).filter(e=>e.trim());c=e.length;for(let s=0;s<Math.min(5,e.length);s++)try{const o=JSON.parse(e[s]);if(o.summary){a=o.summary;break}"user"===o.role&&o.content&&!l&&(l=o.content.slice(0,100))}catch{}"untitled session"===a&&l&&(a=l+(l.length>=100?"...":""))}catch(e){console.error("Error reading session file:",o,e)}return{id:r,summary:a,timestamp:t.mtime.getTime(),createdAt:t.birthtime?.getTime()||t.ctime?.getTime()||t.mtime.getTime(),path:o,messageCount:c}}catch(s){return console.error("Error processing session:",e,s),null}}),c=(await Promise.all(a)).filter(Boolean);if(0===c.length)return null;c.sort((e,s)=>s.timestamp-e.timestamp);const l=Math.min(...c.map(e=>e.createdAt||e.timestamp));return{path:e,name:e,sessions:c,lastModified:c[0]?.timestamp||r.mtime.getTime(),createdAt:l,sessionCount:c.length,totalMessages:c.reduce((e,s)=>e+(s.messageCount||0),0)}}catch(s){return console.error("Error processing project:",e,s),null}}),c=(await Promise.all(a)).filter(Boolean);c.sort((e,s)=>s.lastModified-e.lastModified),console.log(`Returning ${c.length} projects`),s.json({projects:c})}catch(e){console.error("Error loading projects:",e),s.status(500).json({error:"Failed to load projects",details:e.message})}});const pidFilePath=process.env.ELECTRON_RUN_AS_NODE?join(homedir(),`.yurucode-server-${PORT}.pid`):join(__dirname,`server-${PORT}.pid`);function writePidFile(){try{writeFileSync(pidFilePath,process.pid.toString()),console.log(`üìù Server PID ${process.pid} written to ${pidFilePath}`)}catch(e){console.log("‚ö†Ô∏è Could not write PID file (running from read-only location?):",e.message)}}function removePidFile(){try{fs.existsSync(pidFilePath)&&(fs.unlinkSync(pidFilePath),console.log("üóëÔ∏è Removed PID file"))}catch(e){}}function cleanupOldPidFiles(){try{const e=/^(\.yurucode-)?server-\d+\.pid$/,s=homedir();fs.existsSync(s)&&fs.readdirSync(s).forEach(o=>{if(e.test(o)){const e=join(s,o);if(e!==pidFilePath)try{fs.unlinkSync(e),console.log(`üóëÔ∏è Cleaned up old PID file: ${o}`)}catch(e){}}});const o=__dirname;fs.existsSync(o)&&fs.readdirSync(o).forEach(s=>{if(e.test(s)){const e=join(o,s);if(e!==pidFilePath)try{fs.unlinkSync(e),console.log(`üóëÔ∏è Cleaned up old PID file: ${s}`)}catch(e){}}});const t=process.env.TEMP||process.env.TMP||"/tmp",n=join(t,"yurucode-server");fs.existsSync(n)&&fs.readdirSync(n).forEach(s=>{if(e.test(s)){const e=join(n,s);if(e!==pidFilePath)try{fs.unlinkSync(e),console.log(`üóëÔ∏è Cleaned up old PID file in temp: ${s}`)}catch(e){}}}),console.log("‚úÖ PID file cleanup complete")}catch(e){console.log("‚ö†Ô∏è PID file cleanup error:",e.message)}}process.on("SIGINT",()=>{console.log("\nüõë Server shutting down..."),removePidFile(),process.exit(0)}),process.on("SIGTERM",()=>{console.log("\nüõë Server terminated"),removePidFile(),process.exit(0)}),process.on("exit",()=>{removePidFile()}),process.on("uncaughtException",e=>{console.error("üí• Uncaught exception:",e),removePidFile(),process.exit(1)}),process.on("unhandledRejection",(e,s)=>{console.error("üí• Unhandled rejection at:",s,"reason:",e),removePidFile(),process.exit(1)}),io.on("connection",e=>{console.log("üîå Client connected:",e.id);let s=!0;const o=new Map;function t(){if(processSpawnQueue.length>0){const e=processSpawnQueue.shift();console.log(`üîÑ Processing next spawn request. Remaining in queue: ${processSpawnQueue.length}`),e()}}e.on("claude-settings-update",e=>{console.log("üîÑ Received Claude settings update:",e.settings?.executionMode),e.settings&&(CLAUDE_EXECUTION_MODE=e.settings.executionMode||"auto",e.detection?.nativeWindows?.path&&(NATIVE_WINDOWS_CLAUDE_PATH=e.detection.nativeWindows.path),e.detection?.wsl?.path&&(WSL_CLAUDE_PATH=e.detection.wsl.path),console.log("‚úÖ Claude settings updated successfully"))}),e.on("createSession",async(s,o)=>{try{let t,n=null,i=[],r=null;s.existingSessionId&&s.messages?(t=s.existingSessionId,r=sessions.get(t),r?.wasCompacted?(n=null,console.log(`üìÇ Loading compacted session: ${t} - ignoring old Claude ID`)):(n=s.claudeSessionId||null,console.log(`üìÇ Loading existing session: ${t} with Claude ID: ${n}`)),i=s.messages||[],console.log(`üìù Loaded ${i.length} existing messages`)):(t=`session-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,console.log(`‚ú® Creating new session: ${t}`));let a=s.workingDirectory;if(a&&isWindows&&"native-windows"===CLAUDE_EXECUTION_MODE&&NATIVE_WINDOWS_CLAUDE_PATH){const e=a;a=wslToWindowsPath(a),e!==a&&console.log(`üîÑ [Session Creation] Converted WSL path to Windows path: ${e} ‚Üí ${a}`)}if(a){const e=a.toLowerCase();(e.includes("\\temp\\")||e.includes("/temp/")||e.includes("\\tmp\\")||e.includes("/tmp/")||e.includes("appdata\\local\\temp")||e.includes("yurucode-server"))&&(console.log(`üö´ Rejecting temp directory as working directory: ${a}`),a=null)}a||(a=homedir(),console.log(`üìÇ Using home directory as fallback: ${a}`));const c={id:t,name:s.name||"new session",socketId:e.id,workingDirectory:a,messages:i,createdAt:Date.now(),claudeSessionId:n,interruptedSessionId:null,hasGeneratedTitle:i.length>0,wasInterrupted:!1,wasCompacted:r?.wasCompacted||!1};sessions.set(t,c),console.log(`‚úÖ Session ready: ${t}`),console.log(`üìÅ Working directory: ${a}`),o&&o({success:!0,sessionId:t,workingDirectory:a})}catch(e){console.error("‚ùå Error creating session:",e),o&&o({success:!1,error:e.message})}}),e.on("sendMessage",async(n,i)=>{console.log("üì® [sendMessage] Processing message in EMBEDDED SERVER");const{sessionId:r,content:a,autoGenerateTitle:c,systemPromptSettings:l}=n;let{model:d}=n;const u=sessions.get(r);if(!u)return console.error(`‚ùå Session not found: ${r}`),void(i&&i({success:!1,error:"Session not found"}));if(a&&"/test"===a.trim()){console.log("üß™ [TEST] Test command received"),e.emit(`message:${r}`,{type:"user",message:{content:a},timestamp:Date.now()});const s=`test-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;return e.emit(`message:${r}`,{id:s,type:"assistant",message:{content:[{type:"text",text:"‚úÖ test command works!\n\nyurucode is running properly."}]},streaming:!1,timestamp:Date.now()}),u.claudeSessionId&&u.claudeSessionId!==r&&e.emit(`message:${u.claudeSessionId}`,{id:s,type:"assistant",message:{content:[{type:"text",text:"‚úÖ test command works!\n\nyurucode is running properly."}]},streaming:!1,timestamp:Date.now()}),void(i&&i({success:!0}))}if(a&&a.startsWith("$")){console.log(`üêö [BASH] Detected bash command: ${a}`);let s=a.substring(1).trim();console.log(`üêö [BASH] Extracted command: ${s}`);const{spawn:o}=require("child_process"),t=`bash-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;try{e.emit(`message:${r}`,{type:"user",message:{content:a},timestamp:Date.now()}),e.emit(`message:${r}`,{id:t,type:"assistant",message:{content:""},streaming:!1,timestamp:Date.now()}),u.claudeSessionId&&u.claudeSessionId!==r&&e.emit(`message:${u.claudeSessionId}`,{id:t,type:"assistant",message:{content:""},streaming:!1,timestamp:Date.now()}),console.log(`üêö [BASH] Started streaming with message ID: ${t}`);const n=u.workingDirectory||require("os").homedir();if(console.log(`üêö [BASH] Working directory: ${n}`),"win32"===process.platform){let a;activeBashProcesses.set(r,null);const c=!1;c?(console.log(`üêö [CMD] Running Windows command: ${s}`),console.log(`üêö [CMD] Working directory: ${n}`),a=o("cmd.exe",["/C",s],{cwd:n,windowsHide:!0,detached:!1,shell:!1,stdio:["ignore","pipe","pipe"]}),console.log("üêö [CMD] Process spawned"),activeBashProcesses.set(r,a)):(console.log(`üêö [POWERSHELL] Running command: ${s}`),console.log(`üêö [POWERSHELL] Working directory: ${n}`),a=o("powershell.exe",["-NoProfile","-NonInteractive","-Command",s],{cwd:n,windowsHide:!0,detached:!1,shell:!1,stdio:["ignore","pipe","pipe"]}),console.log("üêö [POWERSHELL] Process spawned"),activeBashProcesses.set(r,a));let l="",d="";a.stdout.on("data",e=>{const s=e.toString();l+=s;const o=c?"[CMD]":"[BASH]";console.log(`üêö ${o} stdout chunk (${s.length} bytes)`)}),a.stderr.on("data",e=>{const s=e.toString();d+=s;const o=c?"[CMD]":"[BASH]";console.log(`üêö ${o} stderr chunk (${s.length} bytes)`)}),a.on("close",s=>{const o=c?"[CMD]":"[BASH]";console.log(`üêö ${o} Process exited with code ${s}`),console.log(`üêö ${o} Total output: ${l.length} bytes stdout, ${d.length} bytes stderr`),console.log(`üêö ${o} Sending streaming: false to clear thinking state`),activeBashProcesses.delete(r);let n="";0!==s?d?(n=`‚ùå Command failed with exit code ${s}\n\nError output:\n${d}`,l&&(n+=`\n\nStandard output:\n${l}`)):n=l?`‚ùå Command failed with exit code ${s}\n\n${l}`:`‚ùå Command failed with exit code ${s} (no output)`:n=l||d||"(no output)";const a={id:t,type:"assistant",message:{content:[{type:"text",text:`\`\`\`ansi\n${n}\n\`\`\``}]},streaming:!1,timestamp:Date.now()};console.log(`üêö ${o} SessionId:`,r),e.emit(`message:${r}`,a),u.claudeSessionId&&u.claudeSessionId!==r&&(console.log(`üêö ${o} Also emitting to Claude session: message:${u.claudeSessionId}`),e.emit(`message:${u.claudeSessionId}`,a)),setTimeout(()=>{console.log(`üêö ${o} Sending explicit stream end signal`),e.emit(`message:${r}`,{type:"system",subtype:"stream_end",streaming:!1,timestamp:Date.now()}),u.claudeSessionId&&u.claudeSessionId!==r&&e.emit(`message:${u.claudeSessionId}`,{type:"system",subtype:"stream_end",streaming:!1,timestamp:Date.now()})},100),i&&i({success:!0})}),a.on("exit",(e,s)=>{const o=c?"[CMD]":"[BASH]";console.log(`üêö ${o} Process EXIT event: code=${e}, signal=${s}`)}),a.on("error",s=>{const o=c?"[CMD]":"[BASH]";console.error(`üêö ${o} Process error: ${s.message}`),console.log(`üêö ${o} Sending streaming: false due to error`),e.emit(`message:${r}`,{type:"assistant",message:{content:[{type:"text",text:`\`\`\`\nError: ${s.message}\n\`\`\``}]},streaming:!1,timestamp:Date.now()}),i&&i({success:!1,error:s.message})})}else{console.log(`üêö [BASH] Unix command: ${s}`),console.log(`üêö [BASH] Using bashMessageId: ${t}`);const a=o("bash",["-c",s],{cwd:n,stdio:["ignore","pipe","pipe"]});activeBashProcesses.set(r,a);let c="",l="",d=!1;a.stdout.on("data",e=>{c+=e.toString(),console.log(`üêö [BASH] stdout received: ${e.toString().length} bytes`)}),a.stderr.on("data",e=>{l+=e.toString(),console.log(`üêö [BASH] stderr received: ${e.toString().length} bytes`)}),a.on("close",s=>{if(d)return void console.log("üêö [BASH] Ignoring duplicate close event");d=!0,activeBashProcesses.delete(r),console.log(`üêö [BASH] Unix process exited with code ${s}`),console.log(`üêö [BASH] Total output: ${c.length} bytes stdout, ${l.length} bytes stderr`),console.log(`üêö [BASH] Sending result with bashMessageId: ${t}`);let o="";0!==s?l?(o=`‚ùå Command failed with exit code ${s}\n\nError output:\n${l}`,c&&(o+=`\n\nStandard output:\n${c}`)):o=c?`‚ùå Command failed with exit code ${s}\n\n${c}`:`‚ùå Command failed with exit code ${s} (no output)`:o=c||l||"(no output)";const n={id:t,type:"assistant",message:{content:[{type:"text",text:`\`\`\`ansi\n${o}\n\`\`\``}]},streaming:!1,timestamp:Date.now()};e.emit(`message:${r}`,n),i&&i({success:!0})}),a.on("error",s=>{d||(d=!0,console.error(`üêö [BASH] Unix process error: ${s.message}`),e.emit(`message:${r}`,{id:t,type:"assistant",message:{content:[{type:"text",text:`\`\`\`\nError: ${s.message}\n\`\`\``}]},streaming:!1,timestamp:Date.now()}),i&&i({success:!1,error:s.message}))})}}catch(s){console.error(`üêö [BASH] Failed to spawn: ${s.message}`),e.emit(`message:${r}`,{type:"assistant",message:{content:[{type:"text",text:`\`\`\`\nFailed to execute: ${s.message}\n\`\`\``}]},streaming:!1,timestamp:Date.now()}),i&&i({success:!1,error:s.message})}return}console.log(`[${r}] Using model: ${d} (type: ${typeof d})`);const g=async()=>{try{if(console.log("\nüì® Processing message request:",{sessionId:r,messageLength:a?.length||0,model:d,queueLength:processSpawnQueue.length}),activeProcesses.has(r)){const s=activeProcesses.get(r),o=activeProcessStartTimes.get(r)||Date.now(),n=Date.now()-o;if(n<3e3)return console.log(`‚è≥ Process for session ${r} is only ${n}ms old, queueing message instead of killing`),e.emit(`message:${r}`,{type:"system",subtype:"info",message:"processing previous message, will send yours next...",timestamp:Date.now()}),void setTimeout(()=>{processSpawnQueue.push(g),t()},2e3);if(console.log(`‚ö†Ô∏è Killing existing process for session ${r} (PID: ${s.pid}, age: ${n}ms)`),"win32"!==process.platform&&s.pid)try{process.kill(-s.pid,"SIGINT")}catch(e){s.kill("SIGINT")}else s.kill("SIGINT");activeProcesses.delete(r),activeProcessStartTimes.delete(r),u.wasInterrupted=!0,u.claudeSessionId&&(u.interruptedSessionId=u.claudeSessionId,console.log(`üíæ Stored interrupted session ID: ${u.interruptedSessionId}`)),u.claudeSessionId=null,console.log(`üîÑ Marked session ${r} as interrupted and cleared claudeSessionId`),await new Promise(e=>setTimeout(e,500))}let n=u.workingDirectory;if(n){const e=n.toLowerCase();(e.includes("\\temp\\")||e.includes("/temp/")||e.includes("\\tmp\\")||e.includes("/tmp/")||e.includes("appdata\\local\\temp")||e.includes("yurucode-server"))&&(console.log(`üö´ Session has temp directory, using home instead: ${n}`),n=null)}if(console.log(`üîç Path conversion check:\n          - processWorkingDir: ${n}\n          - isWindows: ${isWindows}\n          - CLAUDE_EXECUTION_MODE: ${CLAUDE_EXECUTION_MODE}\n          - NATIVE_WINDOWS_CLAUDE_PATH: ${NATIVE_WINDOWS_CLAUDE_PATH}`),n&&isWindows&&"native-windows"===CLAUDE_EXECUTION_MODE&&NATIVE_WINDOWS_CLAUDE_PATH){const e=n;n=wslToWindowsPath(n),e!==n?console.log(`üîÑ Converted WSL path to Windows path: ${e} ‚Üí ${n}`):console.log(`‚ÑπÔ∏è Path unchanged (not WSL format): ${n}`)}else console.log("‚è≠Ô∏è Skipping path conversion (conditions not met)");n?console.log(`üìÇ Using working directory: ${n}`):(n=homedir(),console.log(`üìÇ Using home directory as fallback: ${n}`));const m=["--print","--output-format","stream-json","--verbose","--dangerously-skip-permissions","--disallowed-tools","AskUserQuestion,EnterPlanMode,ExitPlanMode"],p=l||{},h="you are in yurucode ui. prefer lowercase, be extremely concise, never use formal language, no greetings or pleasantries, straight to the point. you must plan first - use think and todo as much as possible to break down everything, including planning into multiple steps and do edits in small chunks";if(!1!==p.enabled){let e="";e="custom"===p.mode&&p.customPrompt?p.customPrompt:("preset"===p.mode&&p.selectedPreset,h),e&&(m.push("--append-system-prompt"),m.push(e),console.log(`üéØ [${r}] Using system prompt mode: ${p.mode||"default"} (${e.length} chars)`))}else console.log(`üéØ [${r}] System prompt disabled`);const f=u.totalTokens||0,y=2e5;f>=194e3&&!u.isCompacting&&"/compact"!==a.trim()&&(console.log(`‚ö†Ô∏è Auto-compact triggered: ${f}/${y} tokens (${Math.round(f/y*100)}%)`),e.emit(`message:${r}`,{type:"system",subtype:"info",message:{content:`üìä Context nearly full (${Math.round(f/y*100)}%). Auto-compacting conversation...`},timestamp:Date.now()}),w="/compact");let w=a;const $=w?.match(/^\/compact\s*(.*)?$/i);if($){const s=$[1]?.trim()||null;if(console.log("üóúÔ∏è Custom /compact triggered - will use Sonnet to self-summarize"),s&&console.log(`üóúÔ∏è Custom instructions: "${s}"`),d="claude-sonnet-4-5-20250929",console.log(`üóúÔ∏è Using Sonnet 4.5 for compact operation: ${d}`),!u.claudeSessionId)return console.log("‚ö†Ô∏è No active session to compact"),e.emit(`message:${r}`,{type:"system",subtype:"error",message:{content:"No active conversation to compact. Start a conversation first."},timestamp:Date.now()}),processSpawnQueue.shift(),isSpawningProcess=!1,void(processSpawnQueue.length>0&&processNextSpawnRequest());let o="Please provide a detailed summary of our entire conversation so far. Include:\n1. Key facts about me (name, project details, preferences)\n2. Main topics we've discussed\n3. Any code or solutions we've worked on\n4. Important decisions or conclusions\n5. Current task/problem we're addressing\n6. Any context needed to continue our work\n\nFormat as a clear, structured summary that preserves all important context.";s&&(o+=`\n\nAdditional instructions for the summary:\n${s}`),console.log(`üóúÔ∏è Asking Claude to self-summarize with session ${u.claudeSessionId}`),w=o,u.isCompacting=!0;const t=void 0!==getWrapperSession?getWrapperSession(r):null;console.log("üóúÔ∏è Wrapper session state:",t?{totalTokens:t.totalTokens,inputTokens:t.inputTokens,outputTokens:t.outputTokens}:"not available"),console.log(`üóúÔ∏è Session token state: totalTokens=${u.totalTokens}`),u.compactStartTokens=t?.totalTokens||u.totalTokens||0,u.compactMessageCount=u.messages?.length||0,u.compactCustomInstructions=s,console.log(`üóúÔ∏è Set compactStartTokens to ${u.compactStartTokens}`)}d&&(m.push("--model",d),console.log(`ü§ñ Using model: ${d}`));let S=!1;!u.claudeSessionId&&u.interruptedSessionId&&u.wasInterrupted&&(console.log(`üîÑ Restoring interrupted session: ${u.interruptedSessionId}`),u.claudeSessionId=u.interruptedSessionId,u.interruptedSessionId=null),S=u.claudeSessionId,S?(m.push("--resume",u.claudeSessionId),console.log("üîÑ Using --resume flag with session:",u.claudeSessionId),u.wasInterrupted&&(console.log("üìù Resuming after interrupt"),u.wasInterrupted=!1)):u.wasCompacted&&u.compactSummary?(console.log("üìù Starting fresh conversation after compaction"),console.log(`üóúÔ∏è Previous conversation was compacted, saved ${u.tokensSavedByCompact||0} tokens`),console.log("üóúÔ∏è Injecting summary into new conversation"),w=`[Previous conversation context - compacted from ${u.tokensSavedByCompact} tokens]:\n${u.compactSummary}\n\n[Continuing conversation]\nUser: ${w}`,u.wasCompacted=!1,u.compactSummary=null,console.log(`üóúÔ∏è Message with context: ${a.substring(0,200)}...`)):console.log("üìù Starting fresh conversation (no previous session)"),console.log("üöÄ Spawning claude with args:",m),console.log(`üîç Active processes count: ${activeProcesses.size}`);const C={...process.env},k="/opt/homebrew/bin";if(C.PATH?.includes(k)||(C.PATH=`${k}:${C.PATH||"/usr/bin:/bin"}`,console.log(`üîß Added ${k} to PATH for Claude CLI`)),C.CLAUDE_SESSION_ID=r,C.CLAUDE_INSTANCE=`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,isSpawningProcess&&(console.log("‚è≥ Waiting for previous Claude process to initialize..."),await new Promise(e=>setTimeout(e,200))),isSpawningProcess=!0,n&&isWindows&&"native-windows"===CLAUDE_EXECUTION_MODE&&NATIVE_WINDOWS_CLAUDE_PATH){const e=n,s=wslToWindowsPath(n);e!==s&&(console.log(`üîÑ Converting WSL path for validation: ${e} ‚Üí ${s}`),n=s)}C.PWD=n,C.HOME=homedir(),console.log(`üîß Set PWD=${n} and HOME=${homedir()} in environment`),existsSync(n)||(console.warn(`‚ö†Ô∏è Working directory does not exist: ${n}, using home directory`),n=homedir());const I={cwd:n,env:C,shell:!1,windowsHide:!0,detached:!1,stdio:["pipe","pipe","pipe"]};let P;console.log("üöÄ Spawning claude process with options:",{cwd:I.cwd,claudePath:CLAUDE_PATH,args:m});let T=null;if(isWindows){let e=n,s=w;if(u.pendingContextRestore&&u.messages&&u.messages.length>0){console.log("üîÑ Building context for WSL command");let e="Here's our previous conversation context:\\n\\n";const o=u.messages.slice(-10);for(const s of o)if("user"===s.type){const o=s.message?.content||"";let t="";"string"==typeof o?t=o:Array.isArray(o)&&(t=o.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`User: ${t.substring(0,200)}${t.length>200?"...":""}\\n\\n`}else if("assistant"===s.type){const o=s.message?.content||"";let t="";"string"==typeof o?t=o:Array.isArray(o)&&(t=o.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`Assistant: ${t.substring(0,200)}${t.length>200?"...":""}\\n\\n`}e+=`---\\nNow, continuing our conversation: ${w}`,s=e,u.pendingContextRestore=!1}const[o,t,i,r]=getClaudeCommand(m,e,s);if(T=r,console.log(`üöÄ Running command: ${o}`),console.log("üöÄ Args (first 500 chars):",JSON.stringify(t).substring(0,500)),console.log(`üöÄ Input handled: ${i}`),o.includes("wsl.exe")&&!existsSync(o))throw console.error(`‚ùå WSL.exe not found at: ${o}`),console.error("‚ùå Please ensure WSL is installed on Windows"),new Error("WSL.exe not found. Please install Windows Subsystem for Linux.");if((o.endsWith(".cmd")||o.endsWith(".bat"))&&!o.endsWith("node.exe")){I.shell=!0;const e=["C:\\Program Files\\nodejs","C:\\Program Files (x86)\\nodejs",process.env.ProgramFiles+"\\nodejs"].filter(Boolean);for(const s of e)if(existsSync(s)){I.env={...I.env},I.env.PATH=s+";"+(I.env.PATH||process.env.PATH),console.log(`‚úÖ Added Node.js to PATH for .cmd execution: ${s}`);break}}P=spawn(o,t,I),P.inputHandled=i}else P=spawn(CLAUDE_PATH,m,I);if(setTimeout(()=>{isSpawningProcess=!1},500),activeProcesses.set(r,P),activeProcessStartTimes.set(r,Date.now()),"win32"!==process.platform&&P.unref(),u.pendingContextRestore&&u.messages&&u.messages.length>0){console.log(`üîÑ Restoring context with ${u.messages.length} previous messages`);let e="Here's our previous conversation context:\n\n";const s=u.messages.slice(-10);for(const o of s)if("user"===o.type){const s=o.message?.content||"";let t="";"string"==typeof s?t=s:Array.isArray(s)&&(t=s.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`User: ${t.substring(0,200)}${t.length>200?"...":""}\n\n`}else if("assistant"===o.type){const s=o.message?.content||"";let t="";"string"==typeof s?t=s:Array.isArray(s)&&(t=s.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`Assistant: ${t.substring(0,200)}${t.length>200?"...":""}\n\n`}e+=`---\nNow, continuing our conversation: ${a}`;const o=e+"\n";if(console.log(`üìù Sending context + message to claude (${o.length} chars)`),!P.inputHandled){const e=setTimeout(()=>{console.error("‚ö†Ô∏è Stdin write timeout - forcing close");try{P.stdin.end(),P.stdin.destroy()}catch(e){console.error(`Failed to force close stdin: ${e.message}`)}},1e4);P.stdin.write(o,s=>{clearTimeout(e),s?console.error("‚ùå Error writing to stdin:",s):console.log("‚úÖ Successfully sent context restoration"),P.stdin.end(),console.log("üìù Closed stdin after sending message (--print mode requires this)")})}u.pendingContextRestore=!1}else if(a&&!P.inputHandled){const e=w+"\n";console.log(`üìù Sending message to claude via stdin (${w.length} chars) - resuming=${S}`);const s=setTimeout(()=>{console.error("‚ö†Ô∏è Stdin write timeout - forcing close");try{P.stdin.end(),P.stdin.destroy()}catch(e){console.error(`Failed to force close stdin: ${e.message}`)}},1e4);P.stdin.write(e,e=>{clearTimeout(s),e?console.error("‚ùå Error writing to stdin:",e):console.log("‚úÖ Successfully wrote to stdin"),P.stdin.end(),console.log("üìù Closed stdin after sending message (--print mode requires this)")})}else if(P.inputHandled){if(console.log("üìù Message already embedded in command (WSL or temp file)"),T&&"native-windows"===CLAUDE_EXECUTION_MODE){const e=require("fs");try{const s=e.readFileSync(T,"utf8");console.log(`üìù Piping temp file content to stdin (${s.length} chars)`),P.stdin.write(s),P.stdin.end(),setTimeout(()=>{try{e.unlinkSync(T),console.log(`üóëÔ∏è Cleaned up temp file: ${T}`)}catch(e){}},1e3)}catch(e){console.error(`‚ùå Failed to read temp file: ${e.message}`)}}}else a||console.log("üìù No message to send");if(console.log(`üè∑Ô∏è Title check: hasGeneratedTitle=${u.hasGeneratedTitle}, messageLength=${a?.length}, autoGenerateTitle=${c}`),c&&!u.hasGeneratedTitle&&a&&a.length>5){let s=a;try{const e=JSON.parse(a);Array.isArray(e)&&(s=e.filter(e=>"text"===e.type).map(e=>e.text).join(" "),console.log(`üè∑Ô∏è Extracted text from JSON: "${s}"`))}catch(e){console.log(`üè∑Ô∏è Using plain text content: "${s}"`)}s&&s.trim().length>5?(console.log(`üè∑Ô∏è Calling generateTitle for session ${r}`),generateTitle(r,s,e,()=>{console.log(`üè∑Ô∏è Title successfully generated for session ${r}`),u.hasGeneratedTitle=!0})):console.log(`üè∑Ô∏è Skipping title generation - text too short: "${s}"`)}let _="",b=0,v=0,E=Date.now(),D=Date.now(),A={timer:null};streamHealthChecks.has(r)&&clearInterval(streamHealthChecks.get(r)),streamTimeouts.has(r)&&clearTimeout(streamTimeouts.get(r));const j=setInterval(()=>{const s=Date.now()-E,o=Date.now()-D;if(console.log(`ü©∫ [${r}] duration: ${o}ms | since_last: ${s}ms | bytes: ${v} | msgs: ${b} | buffer: ${_.length} | alive: ${activeProcesses.has(r)}`),s>6e4&&s<65e3&&(console.log("‚è≥ No data for 1 min - Claude processing complex task..."),e.emit(`keepalive:${r}`,{timestamp:Date.now(),info:"Processing complex task",elapsed:s})),s>3e5&&s<305e3&&(console.warn("‚ö†Ô∏è No data for 5 min - task taking longer than usual"),e.emit(`keepalive:${r}`,{timestamp:Date.now(),warning:"Long-running operation in progress",elapsed:s})),s>48e4&&s<485e3&&(console.error("üö® No data for 8 min - may be frozen"),e.emit(`message:${r}`,{type:"system",subtype:"warning",content:"‚ö†Ô∏è Claude has been silent for 8 minutes. Will terminate at 10 minutes if no response.",timestamp:Date.now()})),s>6e5){if(console.error(`üíÄ Stream appears dead after ${s}ms, cleaning up`),activeBashProcesses.has(r)){const e=activeBashProcesses.get(r);if(e){console.log(`üî™ Killing frozen bash process for session ${r}`);try{e.kill("SIGKILL")}catch(e){console.error(`Failed to kill bash process: ${e.message}`)}activeBashProcesses.delete(r)}}if(activeProcesses.has(r)){const s=activeProcesses.get(r);console.log(`üî™ Force killing frozen Claude process for session ${r}`);try{s.kill("SIGKILL")}catch(e){console.error(`Failed to kill Claude process: ${e.message}`)}if(activeProcesses.delete(r),activeProcessStartTimes.delete(r),e.emit(`message:${r}`,{type:"system",subtype:"error",content:"‚ö†Ô∏è Claude became unresponsive and was terminated. Please retry your request.",timestamp:Date.now()}),u&&(u.needsRetry=!0,u.frozenCount=(u.frozenCount||0)+1,console.log(`üîÑ Session ${r} marked for retry (frozen ${u.frozenCount} times)`)),lastAssistantMessageIds.has(r)){const s=lastAssistantMessageIds.get(r);e.emit(`update:${r}`,{id:s,streaming:!1}),lastAssistantMessageIds.delete(r)}}clearInterval(j)}},5e3);streamHealthChecks.set(r,j);const x=()=>{A.timer&&clearTimeout(A.timer),A.timer=setTimeout(()=>{const s=Date.now()-E;if(console.error(`üêï WATCHDOG: Killing frozen process after ${s}ms of no data`),activeBashProcesses.has(r)){const e=activeBashProcesses.get(r);if(e){try{e.kill("SIGKILL")}catch(e){}activeBashProcesses.delete(r)}}if(activeProcesses.has(r)){const e=activeProcesses.get(r);try{e.kill("SIGKILL")}catch(e){}activeProcesses.delete(r),activeProcessStartTimes.delete(r)}e.emit(`message:${r}`,{type:"system",subtype:"error",content:"üî¥ Watchdog timer: Claude was terminated due to unresponsiveness",timestamp:Date.now()}),streamHealthChecks.has(r)&&(clearInterval(streamHealthChecks.get(r)),streamHealthChecks.delete(r)),streamTimeouts.has(r)&&(clearTimeout(streamTimeouts.get(r)),streamTimeouts.delete(r))},66e4)};x();const W=setTimeout(()=>{if(console.warn(`‚è∞ Stream timeout reached for session ${r} after 45 minutes`),activeProcesses.has(r)){const e=activeProcesses.get(r);console.log(`‚è∞ Terminating long-running process for ${r}`),e.kill("SIGTERM")}},27e5);streamTimeouts.set(r,W);const L=t=>{if(t.trim()){try{const e=processWrapperLine(t,r);e&&e!==t&&(t=e)}catch(e){console.error("[WRAPPER] Error processing line:",e.message)}if(E=Date.now(),x(),t.includes("No conversation found with session ID")){console.log(`üîÑ [${r}] Resume failed - session not found in Claude storage`),console.log(`üîÑ [${r}] Will create new session with existing context on next message`);const s=sessions.get(r);if(s){s.claudeSessionId=null;const o={id:`result-error-${Date.now()}-${Math.random()}`,type:"result",subtype:"error",is_error:!0,error:"Session not found - restoring from checkpoint",requiresCheckpointRestore:!0,streaming:!1,timestamp:Date.now()},t=`message:${r}`;console.log(`üì§ [${r}] Emitting error result with checkpoint restore flag`),e.emit(t,o),console.log(`üì§ [${r}] Sent checkpoint restore signal`);const n=`system-info-${Date.now()}-${Math.random()}`;e.emit(`message:${r}`,{id:n,type:"system",subtype:"info",message:{content:"session history not found - send message again to continue"},timestamp:Date.now(),streaming:!1}),console.log(`üì§ [${r}] Sent info message ${n} about session not found`),s.isReady=!0,console.log(`‚úÖ [${r}] Session marked as ready after resume failure`)}return}try{const n=JSON.parse(t),i=u?.messages?.filter(e=>"user"===e.role).pop(),a="/compact"===i?.message?.content?.trim();if(a&&n.type,n.session_id&&!a){const e=u.claudeSessionId;if(e&&e!==n.session_id){const s=getWrapperSession(r),o=s.totalTokens;s.totalTokens=0,s.inputTokens=0,s.outputTokens=0,s.cacheCreationTokens=0,s.cacheReadTokens=0,console.log(`üîÑ [${r}] NEW Claude session detected (${e} ‚Üí ${n.session_id})`),console.log(`üîÑ [${r}] Reset wrapper tokens: ${o} ‚Üí 0 (each session has independent 200k limit)`)}u.claudeSessionId=n.session_id,console.log(`üìå [${r}] Claude session ID: ${u.claudeSessionId}`)}else a&&n.session_id&&console.log(`üóúÔ∏è [${r}] Ignoring session ID during compact: ${n.session_id} (not resumable)`);if("system"===n.type&&"init"===n.subtype)e.emit(`message:${r}`,{type:"system",subtype:"init",message:n,timestamp:Date.now()});else if("assistant"===n.type){const t=`assistant-${r}-${Date.now()}-${Math.random()}`;if(n.message?.content){let i=!1,a=[],c=!1;for(const t of n.message.content)if("text"===t.type||"thinking"===t.type)i=!0,a.push(t),"thinking"===t.type&&console.log(`üß† [${r}] Found thinking block: ${(t.thinking||t.text||"").substring(0,100)}...`);else if("tool_use"===t.type){c=!0,"Bash"===t.name&&s&&(console.log(`üîß [${r}] Tracking first Bash tool use: ${t.id}`),o.set(t.id,{sessionId:r,timestamp:Date.now()}));const i={type:"tool_use",message:{name:t.name,input:t.input,id:t.id},timestamp:Date.now(),id:`tool-${r}-${Date.now()}`};n.parent_tool_use_id&&(i.parent_tool_use_id=n.parent_tool_use_id,console.log(`ü§ñ [${r}] Subagent tool_use (parent: ${n.parent_tool_use_id.substring(0,20)}...): ${t.name}`)),e.emit(`message:${r}`,i)}if(i&&a.length>0){lastAssistantMessageIds.set(r,t),console.log(`üìù [${r}] Emitting assistant message ${t} with streaming=true`),console.log(`üìù [${r}] Content blocks: ${a.length} (types: ${a.map(e=>e.type).join(", ")})`);const s={type:"assistant",id:t,message:{...n.message,content:a},streaming:!0,timestamp:Date.now()};if(n.parent_tool_use_id&&(s.parent_tool_use_id=n.parent_tool_use_id,console.log(`ü§ñ [${r}] Subagent assistant message (parent: ${n.parent_tool_use_id.substring(0,20)}...)`)),e.emit(`message:${r}`,s),u.messages.push({type:"assistant",message:{content:a},id:t,timestamp:Date.now()}),u.messages.length>1e3){const e=Math.floor(200);u.messages.splice(0,e),console.log(`üßπ Trimmed ${e} old messages from session ${r}`)}b++}else if(c&&!i){lastAssistantMessageIds.set(r,t),allAssistantMessageIds.has(r)||allAssistantMessageIds.set(r,[]),allAssistantMessageIds.get(r).push(t),console.log(`üìù [${r}] Emitting assistant message ${t} (tool-only) with streaming=true`),e.emit(`message:${r}`,{type:"assistant",id:t,message:{...n.message,content:[]},streaming:!0,timestamp:Date.now()});const s=sessions.get(r);s&&s.messages.push({type:"assistant",message:{content:[]},id:t,timestamp:Date.now()}),b++}}}else if("user"===n.type&&n.message?.content){for(const t of n.message.content)if("tool_result"===t.type){if(o.has(t.tool_use_id)){console.log(`üîß [${r}] Bash tool result received, triggering focus restoration`);const n=o.get(t.tool_use_id);o.delete(t.tool_use_id),s&&(s=!1,console.log(`üîß [${r}] First bash command completed, focus restoration disabled for future commands`)),"win32"===process.platform&&e.emit(`trigger:focus:${n.sessionId}`,{timestamp:Date.now()})}let i=t.content;if("string"==typeof t.content&&(t.content.includes("has been updated")||t.content.includes("updated.")||t.content.includes("Applied")&&t.content.includes("edit")||t.content.includes("The file")||t.content.includes("snippet of the edited file"))){const e=t.content.match(/The file (.+?) has been updated/)||t.content.match(/Applied \d+ edits? to (.+?):/)||t.content.match(/file[:\s]+(.+?)(?:\s+has been|\s+updated|:|\n)/)||t.content.match(/\/[^\s]+\.(?:tsx?|jsx?|py|rs|md|css|json|yml|yaml|toml|html|vue|svelte)/g);if(e){const s=Array.isArray(e)&&!e[1]?e[0]:e[1]||e[0],o=join(u.workingDirectory||process.cwd(),s);console.log(`üìù [${r}] Attempting to enhance diff for: ${s}`);try{if(existsSync(o)){const e=readFileSync(o,"utf8").split("\n"),s=t.content.split("\n"),n=/(?:^\s*(\d+)[‚Üí:])|(?:line[s]?\s+(\d+))/i,a=new Set;if(s.forEach(e=>{const s=e.match(n);if(s){const e=s[1]||s[2];e&&a.add(parseInt(e))}}),a.size>0){console.log(`üìù [${r}] Found ${a.size} changed lines, enhancing with context`);const o=3,t=[],n=s.findIndex(e=>e.includes("Here's the result of running"));n>=0&&t.push(...s.slice(0,n+1));const c=Array.from(a).sort((e,s)=>e-s);let l=-999;c.forEach(s=>{const n=Math.max(1,s-o),i=Math.min(e.length,s+o);for(let o=n;o<s;o++)if(o>l){const s=String(o).padStart(6," ");a.has(o)?t.push(`${s}‚Üí${e[o-1]}`):t.push(`${s} ${e[o-1]}`),l=o}const r=String(s).padStart(6," ");s>l&&(t.push(`${r}‚Üí${e[s-1]}`),l=s);for(let o=s+1;o<=i;o++)if(o>l){const s=String(o).padStart(6," ");a.has(o)?t.push(`${s}‚Üí${e[o-1]}`):t.push(`${s} ${e[o-1]}`),l=o}const d=c[c.indexOf(s)+1];d&&d>i+1&&t.push("   ...")}),i=t.join("\n")}}}catch(e){console.log(`Could not enhance Edit output with context lines: ${e.message}`)}}}const a={type:"tool_result",message:{tool_use_id:t.tool_use_id,content:i,is_error:t.is_error},streaming:!0,timestamp:Date.now(),id:`toolresult-${r}-${Date.now()}`};n.parent_tool_use_id&&(a.parent_tool_use_id=n.parent_tool_use_id,console.log(`ü§ñ [${r}] Subagent tool_result (parent: ${n.parent_tool_use_id.substring(0,20)}...)`)),e.emit(`message:${r}`,a)}}else if("content_block_start"===n.type)console.log(`üìù [${r}] Content block starting:`,n.content_block?.type),e.emit(`message:${r}`,{type:"content_block_start",content_block:n.content_block,index:n.index,timestamp:Date.now()});else if("content_block_stop"===n.type)console.log(`üìù [${r}] Content block stopped:`,n.index),e.emit(`message:${r}`,{type:"content_block_stop",index:n.index,timestamp:Date.now()});else if("rate_limit"===n.type)console.log(`‚ö†Ô∏è [${r}] Rate limit:`,n.rate_limit),e.emit(`message:${r}`,{type:"rate_limit",rate_limit:n.rate_limit,timestamp:Date.now()});else if("progress"===n.type)console.log(`‚è≥ [${r}] Progress:`,n.progress),e.emit(`message:${r}`,{type:"progress",progress:n.progress,message:n.message,timestamp:Date.now()});else if("compact"===n.type||"system"===n.type&&"compact"===n.subtype)console.log(`üóúÔ∏è [${r}] Context compacted`),e.emit(`message:${r}`,{type:"system",subtype:"compact",message:{content:"context compressed - usage will reset on next message"},timestamp:Date.now()});else if("ping"===n.type||"pong"===n.type)console.log(`üèì [${r}] ${n.type} received`);else if("metadata"===n.type)console.log(`üìã [${r}] Metadata:`,n),n.title&&e.emit(`title:${r}`,n.title);else if("summary"===n.type)console.log(`üìù [${r}] Summary:`,n.summary),n.summary&&e.emit(`title:${r}`,n.summary);else if("result"===n.type){console.log(`üì¶ [${r}] RESULT: success=${!n.is_error}, duration=${n.duration_ms}ms`);const s=sessions.get(r),o=s?.messages?.filter(e=>"user"===e.role).pop(),t="/compact"===o?.message?.content?.trim(),i=!0===s?.isCompacting,a=t&&(n.result?.includes("Compacted")||n.result?.includes("compressed")||n.result?.includes("summary")||""===n.result||null===n.result);if(i){console.log(`üóúÔ∏è [${r}] Received compact summary from Claude`);let o=n.result;if(!o||""===o.trim()||o.includes("ready to continue")||o.includes("continue normally")||o.length<50){console.log("üóúÔ∏è Result is empty/generic, looking for last assistant message");const e=s?.messages?.filter(e=>"assistant"===e.type&&e.message?.content)||[];for(let s=e.length-1;s>=0;s--){const t=e[s],n=t.message?.content;let i="";if("string"==typeof n?i=n:Array.isArray(n)&&(i=n.filter(e=>"text"===e.type&&e.text).map(e=>e.text).join("\n").trim()),i&&i.length>100){o=i,console.log(`üóúÔ∏è Using assistant message as summary (${i.length} chars)`);break}}(!o||o.length<50)&&(o="Conversation compacted successfully. Previous context preserved.",console.log("üóúÔ∏è Using fallback summary"))}console.log(`üóúÔ∏è Summary length: ${o.length} chars`),console.log(`üóúÔ∏è Previous token count: ${s.compactStartTokens}`),s.compactSummary=o;const t=void 0!==getWrapperSession?getWrapperSession(r):null;s.tokensSavedByCompact=s.compactStartTokens||t?.totalTokens||0;const i=s.claudeSessionId;s.claudeSessionId=null,s.wasCompacted=!0,s.isCompacting=!1,console.log(`üóúÔ∏è Saved summary and cleared session ${i}`),console.log("üóúÔ∏è Next message will start fresh with summary as context");let a=`‚úÖ Conversation compacted successfully!\n\nüìä Compaction Summary:\n‚Ä¢ Tokens saved: ${s.tokensSavedByCompact.toLocaleString()}\n‚Ä¢ Previous messages: ${s.compactMessageCount||s.messages.length}\n‚Ä¢ Summary preserved: Yes`;s.compactCustomInstructions&&(a+=`\n‚Ä¢ Custom focus: ${s.compactCustomInstructions}`),a+=`\n\nüìù Summary:\n${o}\n\n‚ú® Context has been compressed. You can continue normally.`;const c=activeProcessStartTimes.get(r),l=n.duration_ms||(c?Date.now()-c:0);console.log(`üóúÔ∏è Duration: jsonData.duration_ms=${n.duration_ms}, calculated=${c?Date.now()-c:"N/A"}, using=${l}ms`);const u={type:"result",subtype:"success",is_error:!1,result:a,session_id:null,duration_ms:n.duration_ms||l,usage:{input_tokens:0,output_tokens:0,cache_creation_input_tokens:0,cache_read_input_tokens:0},wrapperTokens:{input:0,output:0,total:0,cache_read:0,cache_creation:0},streaming:!1,id:`result-${r}-${Date.now()}-${Math.random()}`,model:n.model||d||"claude-sonnet-4-5-20250929",timestamp:Date.now()};return e.emit(`message:${r}`,u),console.log(`üì§ [${r}] Sent compact success message`),s.messages=[],void(s.compactCount=(s.compactCount||0)+1)}if(a&&!i){if(console.log(`üóúÔ∏è [${r}] Detected /compact command completion`),console.log(`üóúÔ∏è [${r}] Result text: "${n.result}"`),console.log(`üóúÔ∏è [${r}] Session ID in result: ${n.session_id}`),console.log(`üóúÔ∏è [${r}] Usage data:`,n.usage),s){const e=s.claudeSessionId;s.claudeSessionId=null,s.wasCompacted=!0,s.compactSummary=n.result||"conversation summarized",s.compactedTokenCount=compactedTokens?.total||0,s.tokensSavedByCompact=s.totalTokens||0,console.log(`üóúÔ∏è Cleared session ID (was ${e}) - next message will start fresh after compact`),console.log("üóúÔ∏è Marked session as compacted to prevent old ID restoration"),console.log(`üóúÔ∏è Stored compact summary for next session: ${s.compactSummary.substring(0,100)}...`),console.log("üóúÔ∏è The compact command has summarized the conversation - continuing with reduced context")}if(console.log(`üóúÔ∏è [${r}] Compact complete - tokens will reset on next message`),s){const e=s.totalTokens||0;s.totalTokens=0,s.inputTokens=0,s.outputTokens=0,console.log(`üóúÔ∏è [${r}] Reset session tokens from ${e} to 0`)}e.emit(`message:${r}`,{type:"system",subtype:"compact",session_id:null,message:{content:"context compacted - tokens reset",compactedTokens:{input:0,output:0,total:0,cache_read:0,cache_creation:0,reset:!0},tokensSaved:s?.tokensSavedByCompact||0,compactSummary:n.result||"conversation summarized"},timestamp:Date.now()})}if(n.usage){const e=n.usage.input_tokens||0,s=n.usage.output_tokens||0,o=n.usage.cache_creation_input_tokens||0,t=n.usage.cache_read_input_tokens||0,i=e+s;console.log("\nüìä TOKEN USAGE BREAKDOWN:"),console.log("   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"),console.log("   ‚îÇ Type            ‚îÇ Input    ‚îÇ Cache Read   ‚îÇ Cache New  ‚îÇ"),console.log("   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"),console.log(`   ‚îÇ User Message    ‚îÇ ${String(e).padEnd(8)} ‚îÇ              ‚îÇ            ‚îÇ`),console.log(`   ‚îÇ Assistant Reply ‚îÇ ${String(s).padEnd(8)} ‚îÇ              ‚îÇ            ‚îÇ`),console.log(`   ‚îÇ Context History ‚îÇ          ‚îÇ ${String(t).padEnd(12)} ‚îÇ            ‚îÇ`),console.log(`   ‚îÇ Cache Created   ‚îÇ          ‚îÇ              ‚îÇ ${String(o).padEnd(10)} ‚îÇ`),console.log("   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"),console.log(`   ‚îÇ New Tokens      ‚îÇ ${String(e+s).padEnd(8)} ‚îÇ (billing)    ‚îÇ (billing)  ‚îÇ`),console.log("   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"),console.log(`   CONTEXT USAGE: ${i} / 200000 (${(i/2e3).toFixed(1)}%)`),console.log("   Note: New tokens (input+output) count toward 200k. Cache values are for billing.")}const c=lastAssistantMessageIds.get(r);if(c){console.log(`‚úÖ Marking assistant message ${c} as streaming=false (result received)`);const s=sessions.get(r),o=s?.messages.find(e=>e.id===c);e.emit(`message:${r}`,{type:"assistant",id:c,message:o?.message||{content:""},streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(r)}console.log(`‚úÖ [${r}] Sending result message with model: ${d}`);const l={type:"result",...n,streaming:!1,id:`result-${r}-${Date.now()}`,model:d||"unknown"};if(n.usage?(l.usage=n.usage,l.wrapper={tokens:{input:n.usage.input_tokens||0,output:n.usage.output_tokens||0,total:(n.usage.input_tokens||0)+(n.usage.output_tokens||0),cache_read:n.usage.cache_read_input_tokens||0,cache_creation:n.usage.cache_creation_input_tokens||0}},console.log("üìä [WRAPPER-TOKENS] Added both usage and wrapper tokens to result message:",{usage:l.usage,wrapperTokens:l.wrapper.tokens})):console.log("‚ùå [WRAPPER-TOKENS] No usage data in jsonData, neither usage nor wrapper field added"),!a&&s.claudeSessionId&&(l.session_id=s.claudeSessionId),console.log(`   - Model in result message: ${l.model}`),console.log(`   - Session ID in result message: ${l.session_id||"(cleared after compact)"}`),l.usage){const e=(l.usage.input_tokens||0)+(l.usage.output_tokens||0);console.log("   - Usage breakdown:"),console.log(`     ‚Ä¢ input_tokens: ${l.usage.input_tokens||0}`),console.log(`     ‚Ä¢ output_tokens: ${l.usage.output_tokens||0}`),console.log(`     ‚Ä¢ cache_creation: ${l.usage.cache_creation_input_tokens||0} (billing only)`),console.log(`     ‚Ä¢ cache_read: ${l.usage.cache_read_input_tokens||0} (billing only)`),console.log(`     ‚Ä¢ CONTEXT USAGE: ${e} / 200000 (${(e/2e3).toFixed(1)}%)`)}console.log("üì§ [EMIT-DEBUG] About to emit result message with wrapper field:",{hasWrapper:!!l.wrapper,wrapperTokens:l.wrapper?.tokens,messageKeys:Object.keys(l),wrapperStructure:l.wrapper?Object.keys(l.wrapper):null}),e.emit(`message:${r}`,l),b++}}catch(e){console.log(`‚ö†Ô∏è [${r}] Failed to parse JSON, treating as plain text:`,e.message),console.log(`‚ö†Ô∏è [${r}] Line was: ${t}`)}}};console.log(`üîç [${r}] Process spawned with PID: ${P.pid}`),console.log(`üîç [${r}] Process connected: ${P.connected}`);let N="";P.stderr.on("data",e=>{const s=e.toString();N+=s,console.error(`‚ùå [${r}] STDERR output: ${s}`),(s.includes("command not found")||s.includes("No such file"))&&(console.error(`‚ùå [${r}] WSL PATH ERROR - Claude CLI not found!`),console.error(`‚ùå [${r}] Full stderr: ${N}`)),(s.includes("bash:")||s.includes("sh:"))&&console.error(`‚ùå [${r}] WSL BASH ERROR detected`)});const M=setInterval(()=>{if(_.length>0&&Date.now()-E>5e3&&(console.warn(`‚ö†Ô∏è [${r}] Flushing stale buffer (${_.length} chars)`),_.trim()))try{L(_),_=""}catch(e){console.log(`üìù [${r}] Buffer contains incomplete JSON, waiting for more data`)}},5e3);P.stdout.on("data",e=>{const s=e.toString();if(v+=e.length,E=Date.now(),x(),s.length>1e3&&console.log(`üì• [${r}] STDOUT: ${s.length} bytes (total: ${v})`),_.length>52428800){if(console.error(`‚ö†Ô∏è [${r}] Line buffer overflow (${_.length} bytes), processing and clearing`),_.includes("{")){const s=_.match(/\{[^}]*\}/g);if(s)for(const o of s)try{L(o)}catch(e){console.error(`[${r}] Failed to process JSON chunk:`,e)}}_=""}_+=s;const o=_.split("\n");_=o.pop()||"";for(let e=0;e<o.length;e++)L(o[e])}),P.on("exit",()=>{clearInterval(M)}),P.stderr.on("data",s=>{const o=s.toString();if(console.error(`‚ö†Ô∏è [${r}] Claude stderr (${s.length} bytes):`,o),E=Date.now(),o.includes("No conversation found with session ID")){if(console.log("üîÑ Resume failed - session not found in Claude storage"),console.log("üîÑ Clearing invalid session ID and will retry automatically"),u?.wasCompacted&&console.log("üîÑ This was expected - session was compacted and old ID is no longer valid"),u.claudeSessionId,u.claudeSessionId=null,u.wasInterrupted=!1,P&&!P.killed){console.log("üîÑ Killing failed process before retry");try{P.kill()}catch(e){console.error(`Failed to kill process: ${e.message}`)}}activeProcesses.delete(r);const s={id:`info-retry-${Date.now()}`,type:"system",subtype:"info",message:"üîÑ Session not found. Starting fresh conversation...",streaming:!1,timestamp:Date.now()};return e.emit(`message:${r}`,s),console.log("üîÑ Scheduling automatic retry without --resume flag"),void setTimeout(()=>{console.log(`üîÑ Retrying message for session ${r}`),g()},500)}e.emit(`message:${r}`,{type:"error",error:o,claudeSessionId:u.claudeSessionId,streaming:!1})}),P.on("close",s=>{if(P.stdin&&!P.stdin.destroyed)try{P.stdin.end(),console.log("üìù Closed stdin on process exit")}catch(e){}if(A.timer&&(clearTimeout(A.timer),A.timer=null,console.log("üêï Watchdog timer cleared on process exit")),T)try{const e=require("fs");e.existsSync(T)&&(e.unlinkSync(T),console.log(`üßπ Cleaned up Windows temp file: ${T}`))}catch(e){console.warn(`‚ö†Ô∏è Failed to clean up temp file: ${e.message}`)}streamHealthChecks.has(r)&&(clearInterval(streamHealthChecks.get(r)),streamHealthChecks.delete(r)),streamTimeouts.has(r)&&(clearTimeout(streamTimeouts.get(r)),streamTimeouts.delete(r)),clearInterval(j);const o=Date.now()-D;if(console.log(`üëã [${r}] Claude process exited with code ${s}`),console.log(`üìä [${r}] STREAM SUMMARY:`),console.log(`   ‚îú‚îÄ Total duration: ${o}ms`),console.log(`   ‚îú‚îÄ Total bytes: ${v}`),console.log(`   ‚îú‚îÄ Messages: ${b}`),console.log(`   ‚îú‚îÄ Exit code: ${s}`),console.log(`   ‚îú‚îÄ Stderr: ${N||"(empty)"}`),console.log(`   ‚îî‚îÄ Line buffer: ${_||"(empty)"}`),0===v&&(console.error(`‚ùå [${r}] NO OUTPUT RECEIVED FROM CLAUDE!`),console.error(`‚ùå [${r}] This usually means:`),console.error("   1. Claude CLI is not installed in WSL"),console.error("   2. Claude is not in any of the expected paths"),console.error("   3. WSL is not running properly"),console.error("   4. The command syntax is wrong")),activeProcesses.delete(r),activeProcessStartTimes.delete(r),0===s){const e=sessions.get(r);e&&(e.wasInterrupted=!1,console.log(`‚úÖ Marked session ${r} as completed normally`))}else if(1===s){const s=sessions.get(r);if(s&&s.claudeSessionId&&N.includes("No conversation found")){console.log("‚ö†Ô∏è Resume failed - session not found in Claude storage"),console.log("üîÑ Will recreate session with existing context on next attempt"),s.claudeSessionId=null;const o={id:`result-error-${Date.now()}-${Math.random()}`,type:"result",subtype:"error",is_error:!0,error:"Session not found - restoring from checkpoint",requiresCheckpointRestore:!0,streaming:!1,timestamp:Date.now()},t=`message:${r}`;console.log(`üì§ [${r}] Emitting error result with checkpoint restore (exit code 1)`),e.emit(t,o),console.log(`üì§ [${r}] Sent checkpoint restore signal (exit code 1)`);const n=lastAssistantMessageIds.get(r);n&&(console.log(`üî¥ Clearing assistant message ID ${n} after resume failure`),lastAssistantMessageIds.delete(r)),e.emit(`message:${r}`,{type:"system",subtype:"info",message:{content:"continuing conversation (session history not found in claude)"},timestamp:Date.now(),streaming:!1})}}if(_.trim())try{L(_)}catch(e){console.error("Failed to process remaining buffer:",e)}const t=lastAssistantMessageIds.get(r);if(t){console.log(`üî¥ Forcing streaming=false for assistant message ${t} on process exit`);const s=sessions.get(r),o=s?.messages.find(e=>e.id===t);e.emit(`message:${r}`,{type:"assistant",id:t,message:o?.message||{content:""},streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(r)}e.emit(`message:${r}`,{type:"system",subtype:"stream_end",streaming:!1,timestamp:Date.now()}),null===s||-2===s||"SIGKILL"===s?(console.error(`‚ö†Ô∏è Claude process terminated unexpectedly (code: ${s})`),e.emit(`message:${r}`,{type:"error",error:"session terminated unexpectedly. you can resume by sending another message.",streaming:!1,timestamp:Date.now()})):0!==s&&(u.wasInterrupted?(console.log(`Process exited with code ${s} after interruption - not showing error`),u.wasInterrupted=!1):(console.error(`Claude process failed with exit code ${s}`),e.emit(`message:${r}`,{type:"system",subtype:"info",message:`process completed with code ${s}`,timestamp:Date.now()})))}),P.on("error",s=>{if(T)try{const e=require("fs");e.existsSync(T)&&(e.unlinkSync(T),console.log(`üßπ Cleaned up Windows temp file on error: ${T}`))}catch(e){console.warn(`‚ö†Ô∏è Failed to clean up temp file: ${e.message}`)}streamHealthChecks.has(r)&&(clearInterval(streamHealthChecks.get(r)),streamHealthChecks.delete(r)),streamTimeouts.has(r)&&(clearTimeout(streamTimeouts.get(r)),streamTimeouts.delete(r)),clearInterval(j),console.error(`‚ùå [${r}] Failed to spawn claude:`,s),console.error(`‚ùå [${r}] Error details:`,{message:s.message,code:s.code,syscall:s.syscall,path:s.path});const o=lastAssistantMessageIds.get(r);if(o){console.log(`üî¥ Forcing streaming=false for assistant message ${o} on process error`);const s=sessions.get(r),t=s?.messages.find(e=>e.id===o);e.emit(`message:${r}`,{type:"assistant",id:o,message:t?.message||{content:""},streaming:!1,timestamp:Date.now()})}e.emit(`message:${r}`,{type:"error",error:`claude process error: ${s.message}. try sending your message again.`,claudeSessionId:u.claudeSessionId,streaming:!1}),activeProcesses.delete(r),activeProcessStartTimes.delete(r),lastAssistantMessageIds.delete(r),i&&i({success:!1,error:s.message})}),i&&i({success:!0})}catch(s){console.error("‚ùå Error in spawnRequest:",s),e.emit(`message:${r}`,{type:"error",error:s.message,claudeSessionId:u.claudeSessionId,streaming:!1}),i&&i({success:!1,error:s.message})}finally{t()}};processSpawnQueue.push(g),console.log(`üìã Added request to queue. Queue length: ${processSpawnQueue.length}`),1===processSpawnQueue.length&&t()}),e.on("interrupt",({sessionId:s},o)=>{const process=activeProcesses.get(s),t=activeBashProcesses.get(s),n=sessions.get(s),i=processSpawnQueue.length;if(i>0&&(processSpawnQueue.length=0,console.log(`üßπ Cleared ${i} queued messages after interrupt`)),t){console.log(`üõë Killing bash process for session ${s} (PID: ${t.pid})`);try{if("win32"!==process.platform&&t.pid)try{process.kill(-t.pid,"SIGTERM")}catch(e){t.kill("SIGTERM")}else t.kill("SIGTERM");activeBashProcesses.delete(s),e.emit(`message:${s}`,{type:"system",subtype:"interrupted",message:"bash command interrupted by user",timestamp:Date.now()}),o&&o({success:!0})}catch(e){console.error(`‚ùå Error killing bash process: ${e.message}`),o&&o({success:!1,error:e.message})}}else if(process){if(console.log(`üõë Killing claude process for session ${s} (PID: ${process.pid})`),"win32"!==process.platform&&process.pid)try{process.kill(-process.pid,"SIGINT")}catch(e){process.kill("SIGINT")}else process.kill("SIGINT");activeProcesses.delete(s),activeProcessStartTimes.delete(s),n&&(n.wasInterrupted=!1,n.claudeSessionId=null,n.interruptedSessionId=null,console.log(`üõë Session ${s} stopped by user - cleared session state to prevent auto-resume`));const t=lastAssistantMessageIds.get(s);t&&(e.emit(`message:${s}`,{type:"assistant",id:t,streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(s)),e.emit(`message:${s}`,{type:"system",subtype:"interrupted",message:"task interrupted by user",timestamp:Date.now()}),o&&o({success:!0})}else o&&o({success:!0})}),e.on("clearSession",({sessionId:s})=>{const o=sessions.get(s);if(!o)return void console.error(`Session not found: ${s}`);const process=activeProcesses.get(s);process&&(console.log(`üõë Killing process for cleared session ${s}`),process.kill("SIGINT"),activeProcesses.delete(s),activeProcessStartTimes.delete(s)),o.messages=[],o.claudeSessionId=null,o.hasGeneratedTitle=!1,o.wasInterrupted=!1,o.wasCompacted=!1,lastAssistantMessageIds.delete(s),console.log(`‚úÖ Session ${s} cleared - will start fresh Claude session on next message`),e.emit(`message:${s}`,{type:"system",subtype:"clear",message:"session cleared",timestamp:Date.now()});const t=`title:${s}`;console.log(`üè∑Ô∏è Emitting title reset for cleared session: ${t}`),e.emit(t,{title:"new session"})}),e.on("deleteSession",async(e,s)=>{const{sessionId:o}=e;sessions.delete(o),lastAssistantMessageIds.delete(o),s({success:!0})});const n=new Map,i=new Map;e.on("create-checkpoint",async s=>{const{sessionId:o,description:t,trigger:r="manual"}=s;console.log(`üì∏ Creating checkpoint for session ${o}`);try{const s=sessions.get(o);if(!s)return void e.emit("checkpoint-error",{sessionId:o,error:"Session not found"});const a=`chk_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,c={id:a,sessionId:o,projectPath:s.projectPath||process.cwd(),parentId:i.get(o)?.currentCheckpoint,createdAt:(new Date).toISOString(),messageCount:s.messages?s.messages.length:0,metadata:{description:t,trigger:r,tokensUsed:s.tokenCount||0,model:s.model||"opus",messageIds:s.messages?s.messages.map(e=>e.id):[]},fileSnapshots:[]};if(n.has(o)||n.set(o,[]),n.get(o).push(c),i.has(o)){const e=i.get(o);e.currentCheckpoint=a,e.checkpoints.set(a,c)}else i.set(o,{sessionId:o,rootCheckpoint:a,currentCheckpoint:a,checkpoints:new Map,branches:[]});const l="win32"===process.platform?process.env.USERPROFILE||process.env.HOMEDRIVE+process.env.HOMEPATH:process.env.HOME||homedir(),d=path.join(l,".yurucode","checkpoints",o);fs.existsSync(d)||fs.mkdirSync(d,{recursive:!0});const u=path.join(d,`${a}.json`);fs.writeFileSync(u,JSON.stringify(c,null,2)),console.log(`‚úÖ Checkpoint created: ${a}`),e.emit("checkpoint-created",{sessionId:o,checkpoint:c})}catch(s){console.error("‚ùå Checkpoint creation failed:",s),e.emit("checkpoint-error",{sessionId:o,error:s.message})}}),e.on("restore-checkpoint",async s=>{const{sessionId:o,checkpointId:t}=s;console.log(`‚èÆÔ∏è Restoring checkpoint ${t} for session ${o}`);try{const s=n.get(o);if(!s)throw new Error("No checkpoints found for session");const r=s.find(e=>e.id===t);if(!r)throw new Error("Checkpoint not found");const a=sessions.get(o);if(!a)throw new Error("Session not found");const c=a.messages.filter(e=>r.metadata.messageIds.includes(e.id));a.messages=c,a.tokenCount=r.metadata.tokensUsed;const l=i.get(o);l&&(l.currentCheckpoint=t),console.log(`‚úÖ Checkpoint restored: ${t}`),e.emit("checkpoint-restored",{sessionId:o,checkpointId:t,messages:c})}catch(s){console.error("‚ùå Checkpoint restoration failed:",s),e.emit("checkpoint-error",{sessionId:o,error:s.message})}}),e.on("get-timeline",async s=>{const{sessionId:o}=s,t=i.get(o),r=n.get(o)||[];e.emit("timeline-data",{sessionId:o,timeline:t||null,checkpoints:r})});const r=new Map,a=new Map;e.on("execute-agent",async s=>{const{sessionId:o,agentConfig:t,projectPath:n=process.cwd()}=s;console.log(`ü§ñ Executing agent for session ${o}`);const i=`run_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;try{const s={id:i,sessionId:o,status:"starting",config:t,projectPath:n,startTime:(new Date).toISOString(),endTime:null,output:[],metrics:{messagesProcessed:0,tokensUsed:0,toolsExecuted:0,errors:0}};r.set(i,s);const c=["--output-format","stream-json","--verbose","--print"];t.model&&c.push("--model",t.model);let l=t.systemPrompt||"";t.task&&(l=`${l}\n\nTask: ${t.task}`);const d=[...c];console.log(`üöÄ Spawning agent process: claude ${d.join(" ")}`);const u="win32"===process.platform,g=("linux"===process.platform&&fs.existsSync("/mnt/c"),u?claudePath.endsWith(".cmd")?claudePath:`${claudePath}.cmd`:claudePath),m=spawn(g,d,{cwd:n,env:{...process.env},shell:u});a.set(i,m),s.status="running",l&&m.stdin.write(l+"\n");let p="";m.stdout.on("data",t=>{p+=t.toString();const n=p.split("\n");p=n.pop()||"";for(const t of n)if(t.trim())try{const n=JSON.parse(t);s.metrics.messagesProcessed++,"tool_use"===n.type&&s.metrics.toolsExecuted++,"result"===n.type&&n.usage&&(s.metrics.tokensUsed+=n.usage.output_tokens||0),s.output.push({timestamp:(new Date).toISOString(),data:n}),e.emit("agent-progress",{runId:i,sessionId:o,data:n,metrics:s.metrics})}catch(e){console.error("Failed to parse agent output:",e),s.metrics.errors++}}),m.stderr.on("data",t=>{const n=t.toString();console.error(`‚ùå Agent error: ${n}`),s.metrics.errors++,e.emit("agent-error",{runId:i,sessionId:o,error:n})}),m.on("close",n=>{if(console.log(`‚úÖ Agent completed with code ${n}`),s.status=0===n?"completed":"failed",s.endTime=(new Date).toISOString(),a.delete(i),e.emit("agent-completed",{runId:i,sessionId:o,status:s.status,metrics:s.metrics}),t.createCheckpoint){const s={sessionId:o,description:`Agent run: ${t.name||i}`,trigger:"auto"};e.emit("create-checkpoint",s)}}),e.emit("agent-started",{runId:i,sessionId:o,config:t})}catch(s){console.error("‚ùå Agent execution failed:",s),e.emit("agent-error",{runId:i,sessionId:o,error:s.message})}}),e.on("stop-agent",async s=>{const{runId:o}=s;console.log(`‚èπÔ∏è Stopping agent ${o}`);const t=a.get(o);if(t){t.kill("SIGINT"),a.delete(o);const s=r.get(o);s&&(s.status="stopped",s.endTime=(new Date).toISOString()),e.emit("agent-stopped",{runId:o})}else e.emit("agent-error",{runId:o,error:"Agent not found or already stopped"})}),e.on("get-agent-runs",async s=>{const{sessionId:o}=s,t=Array.from(r.values()).filter(e=>e.sessionId===o);e.emit("agent-runs-data",{sessionId:o,runs:t})}),e.on("disconnect",()=>{console.log("üîå Client disconnected:",e.id);for(const[s,o]of sessions.entries())if(o.socketId===e.id){streamHealthChecks.has(s)&&(clearInterval(streamHealthChecks.get(s)),streamHealthChecks.delete(s)),streamTimeouts.has(s)&&(clearTimeout(streamTimeouts.get(s)),streamTimeouts.delete(s));const process=activeProcesses.get(s);process&&(console.log(`üßπ Cleaning up process for session ${s}`),process.kill("SIGINT"),activeProcesses.delete(s),activeProcessStartTimes.delete(s)),lastAssistantMessageIds.delete(s)}})}),cleanupOldPidFiles(),httpServer.listen(PORT,()=>{writePidFile(),console.log(`üöÄ yurucode server running on port ${PORT}`),console.log(`üìÇ Working directory: ${process.cwd()}`),console.log(`üñ•Ô∏è Platform: ${platform()}`),console.log(`üè† Home directory: ${homedir()}`),console.log(`üìÅ Claude projects: ${join(homedir(),".claude","projects")}`);const e=join(homedir(),".claude","projects");if(existsSync(e)){console.log("‚úÖ Claude projects directory exists");try{const{readdirSync:s}=require("fs"),o=s(e);console.log(`üìä Found ${o.length} project directory(s)`),o.length>0&&"win32"===platform()&&(console.log("üîç Sample project paths (first 3):"),o.slice(0,3).forEach(e=>{if(console.log(`  - ${e}`),e.match(/^[A-Z]--/)){const s=e.replace(/^([A-Z])--/,"$1:/").replace(/-/g,"/");console.log(`    ‚Üí Would convert to: ${s}`)}}))}catch(e){console.log("‚ö†Ô∏è Could not list projects:",e.message)}}else console.log("‚ö†Ô∏è Claude projects directory not found at:",e);console.log(`‚úÖ Server configured for ${"win32"===platform()?"Windows":platform()}`),console.log("‚úÖ Server ready for bash commands")}),httpServer.on("error",e=>{if("EADDRINUSE"===e.code){console.error(`‚ùå Port ${PORT} is already in use`),console.log("Attempting to kill existing process and retry...");const{exec:e}=require("child_process");e(`lsof -ti :${PORT} | xargs kill -9`,e=>{e?(console.error("Failed to kill existing process. Please restart the app."),process.exit(1)):(console.log("Killed existing process, retrying in 1 second..."),setTimeout(()=>{httpServer.listen(PORT)},1e3))})}else console.error("Server error:",e),process.exit(1)});