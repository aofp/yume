const originalConsole={log:console.log.bind(console),error:console.error.bind(console),warn:console.warn.bind(console),info:console.info.bind(console),debug:console.debug.bind(console)};console.log=function(...e){try{originalConsole.log(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.error=function(...e){try{originalConsole.error(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.warn=function(...e){try{originalConsole.warn(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.info=function(...e){try{originalConsole.info(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.debug=function(...e){try{originalConsole.debug(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}};const DEBUG="true"===process.env.YURUCODE_DEBUG;if(!DEBUG){const e=()=>{};console.log=e,console.info=e,console.debug=e}function debugLog(...e){DEBUG&&console.log(...e)}const wrapperState={sessions:new Map,stats:{apiCalls:0,totalTokens:0,compacts:0}};function getWrapperSession(e){return wrapperState.sessions.has(e)||(wrapperState.sessions.set(e,{id:e,inputTokens:0,outputTokens:0,totalTokens:0,messageCount:0,apiResponses:[],compactCount:0,wasCompacted:!1,tokensSaved:0}),console.log(`‚úÖ [WRAPPER] Created session: ${e}`)),wrapperState.sessions.get(e)}function calculateAccumulatedTokensFromMessages(e){if(!e||0===e.length)return 0;for(let s=e.length-1;s>=0;s--){const t=e[s],o=t.usage||t.message?.usage;if(o){const e=o.cache_read_input_tokens||0,s=o.cache_creation_input_tokens||0,t=o.input_tokens||0,n=o.output_tokens||0,i=e+s+t+n;return console.log(`üìä [WRAPPER] Calculated accumulated tokens from history: ${i} (cache_read=${e}, cache_creation=${s}, input=${t}, output=${n})`),i}}return 0}function initWrapperSessionWithTokens(e,s){const t=getWrapperSession(e);return s>0&&0===t.totalTokens&&(t.totalTokens=s,console.log(`üìä [WRAPPER] Initialized session ${e} with ${s} accumulated tokens from history`)),t}function processWrapperLine(e,s){if(!e||!e.trim())return e;const t=getWrapperSession(s);try{const s=JSON.parse(e);wrapperState.stats.apiCalls++,console.log(`üì° [WRAPPER] API ${s.type} #${wrapperState.stats.apiCalls}`),t.apiResponses.push({timestamp:Date.now(),type:s.type,data:{...s}}),"user"!==s.type&&"assistant"!==s.type||t.messageCount++;const o=s.usage||s.message?.usage;if(o&&"result"!==s.type){const e=o.input_tokens||0,s=o.output_tokens||0,n=o.cache_creation_input_tokens||0,i=o.cache_read_input_tokens||0,r=t.totalTokens;t.inputTokens=e,t.outputTokens=s,t.cacheCreationTokens=n,t.cacheReadTokens=i;const a=i+n+e+s;t.totalTokens=Math.max(t.totalTokens,a);const c=t.totalTokens-r;wrapperState.stats.totalTokens+=c,console.log(`üìä [WRAPPER] TOKENS +${c} ‚Üí ${t.totalTokens}/200000 (${Math.round(t.totalTokens/2e3)}%)`),(n>0||i>0)&&console.log(`   üì¶ Cache: creation=${n}, read=${i}`)}if("result"===s.type&&(!s.usage||0===s.usage.input_tokens&&0===s.usage.output_tokens)&&t.totalTokens>0){const e=t.totalTokens;console.log(`üóúÔ∏è [WRAPPER] COMPACTION DETECTED! Saved ${e} tokens`),t.compactCount++,t.wasCompacted=!0,t.tokensSaved+=e,wrapperState.stats.compacts++,t.inputTokens=0,t.outputTokens=0,t.totalTokens=0,s.result&&""!==s.result||(s.result=`Conversation compacted. Saved ${e.toLocaleString()} tokens.`),s.wrapper_compact={savedTokens:e,totalSaved:t.tokensSaved,compactCount:t.compactCount},console.log("üóúÔ∏è [WRAPPER] Compaction complete")}return s.wrapper={enabled:!0,tokens:{total:t.totalTokens,input:t.inputTokens,output:t.outputTokens},compaction:{count:t.compactCount,wasCompacted:t.wasCompacted,tokensSaved:t.tokensSaved}},JSON.stringify(s)}catch(s){return e}}console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"),console.log("üéØ WRAPPER EMBEDDED - Token tracking and compaction enabled"),console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");const{execSync:execSync,spawn:spawn}=require("child_process"),fs=require("fs"),{existsSync:existsSync,mkdirSync:mkdirSync,readFileSync:readFileSync,writeFileSync:writeFileSync,unlinkSync:unlinkSync,readdirSync:readdirSync}=fs,{dirname:dirname,join:join,isAbsolute:isAbsolute}=require("path"),{createServer:createServer}=require("http"),{Server:Server}=require("socket.io"),{homedir:homedir,platform:platform}=require("os");let CLAUDE_PATH="claude";const isWindows="win32"===platform();function createWslClaudeCommand(e,s,t){const o="C:\\Windows\\System32\\wsl.exe";if(!s)throw new Error("Working directory is required for WSL Claude command");const n=s;if(t){const{execFileSync:s}=require("child_process");let i=null,r="user";try{r=s(o,["-e","bash","-c","whoami"],{encoding:"utf8",windowsHide:!0}).trim(),console.log(`üîç WSL user detected: ${r}`)}catch(e){console.warn("‚ö†Ô∏è Could not detect WSL user, using default")}const a=[`/home/${r}/.claude/local/node_modules/.bin/claude`,"~/.npm-global/bin/claude","~/node_modules/.bin/claude","/usr/local/bin/claude","/usr/bin/claude","~/.local/bin/claude"];for(const e of a)try{const t=e.startsWith("~")?`[ -f "${e.replace("~","$HOME")}" ] && echo "exists"`:`[ -f "${e}" ] && echo "exists"`;if("exists"===s(o,["-e","bash","-c",t],{encoding:"utf8",windowsHide:!0}).trim()){if(e.startsWith("~")){const t=s(o,["-e","bash","-c","echo $HOME"],{encoding:"utf8",windowsHide:!0}).trim();i=e.replace("~",t)}else i=e;console.log(`‚úÖ Found Claude at: ${i}`);break}}catch(e){}if(!i)try{const e=s(o,["-e","bash","-c","which claude"],{encoding:"utf8",windowsHide:!0}).trim();e&&(i=e,console.log(`‚úÖ Found Claude via 'which': ${i}`))}catch(e){}i||(i=`/home/${r}/.claude/local/node_modules/.bin/claude`,console.log(`‚ö†Ô∏è Claude not found in WSL, using default path: ${i}`),console.log("‚ö†Ô∏è Please install Claude CLI in WSL: npm install -g @anthropic-ai/claude-cli"));const c=e.map(e=>e.includes(" ")||e.includes(":")||e.includes("(")||e.includes(")")||e.includes(",")?`'${e.replace(/'/g,"'\\''")}'`:e).join(" "),l=`/tmp/yurucode-msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}.txt`,d=`cd "${n}" && echo "${Buffer.from(t).toString("base64")}" | base64 -d > "${l}" && cat "${l}" | ${i} ${c} 2>&1; rm -f "${l}"`;return console.log("üîç WSL script (main message):"),console.log(`  Working dir: ${n}`),console.log(`  Claude path: ${i}`),console.log(`  Args: ${c}`),console.log(`  Message length: ${t.length} chars`),console.log(`  Using temp file: ${l}`),[o,["-e","bash","-c",d],!0]}{const{execFileSync:e}=require("child_process"),s="C:\\Windows\\System32\\wsl.exe";let t=null,o="user";try{o=e(s,["-e","bash","-c","whoami"],{encoding:"utf8",windowsHide:!0}).trim(),console.log(`üîç WSL user detected for title gen: ${o}`)}catch(e){console.warn("‚ö†Ô∏è Could not detect WSL user for title gen, using default")}const n=[`/home/${o}/.claude/local/node_modules/.bin/claude`,"~/.npm-global/bin/claude","~/node_modules/.bin/claude","/usr/local/bin/claude","/usr/bin/claude","~/.local/bin/claude"];for(const o of n)try{const n=o.startsWith("~")?`[ -f "${o.replace("~","$HOME")}" ] && echo "exists"`:`[ -f "${o}" ] && echo "exists"`;if("exists"===e(s,["-e","bash","-c",n],{encoding:"utf8",windowsHide:!0}).trim()){if(o.startsWith("~")){const n=e(s,["-e","bash","-c","echo $HOME"],{encoding:"utf8",windowsHide:!0}).trim();t=o.replace("~",n)}else t=o;break}}catch(e){}if(!t)try{const o=e(s,["-e","bash","-c","which claude"],{encoding:"utf8",windowsHide:!0}).trim();o&&(t=o)}catch(e){}t||(t=`/home/${o}/.claude/local/node_modules/.bin/claude`,console.log(`‚ö†Ô∏è Claude not found for title gen, using default: ${t}`));const i=`cat | ${t} --print --output-format json --model claude-sonnet-4-5-20250929 2>&1`;return console.log("üîç WSL script (title gen)"),[s,["-e","bash","-c",i],!1]}}if(isWindows)console.log("üîç Windows detected, Claude will be invoked through WSL with comprehensive path detection..."),CLAUDE_PATH="WSL_CLAUDE";else{const e=[join(homedir(),".npm-global/bin/claude"),"/opt/homebrew/bin/claude","/usr/local/bin/claude","/usr/bin/claude",process.env.CLAUDE_PATH].filter(Boolean);for(const s of e)try{if(existsSync(s)){CLAUDE_PATH=s,console.log(`‚úÖ Found Claude CLI at: ${CLAUDE_PATH}`);break}}catch(e){}if("claude"===CLAUDE_PATH)try{const e=execSync("which claude",{encoding:"utf8"}).trim();e&&(CLAUDE_PATH=e,console.log(`‚úÖ Found Claude CLI via which: ${CLAUDE_PATH}`))}catch(e){}if("claude"===CLAUDE_PATH)try{const e=execSync("whereis claude",{encoding:"utf8"}).trim().match(/claude:\s+(.+)/);if(e&&e[1]){const s=e[1].split(/\s+/);for(const e of s)if(existsSync(e)){CLAUDE_PATH=e,console.log(`‚úÖ Found Claude CLI via whereis: ${CLAUDE_PATH}`);break}}}catch(e){console.warn("‚ö†Ô∏è Claude CLI not found via whereis. Using 'claude' and hoping for the best.")}}const express=require("express"),cors=require("cors"),net=require("net"),app=express(),httpServer=createServer(app),io=new Server(httpServer,{cors:{origin:"*",methods:["GET","POST"]},transports:["websocket","polling"],pingTimeout:6e5,pingInterval:3e4,upgradeTimeout:6e4,maxHttpBufferSize:5e8,perMessageDeflate:!1,httpCompression:!1});app.use(cors()),app.use(express.json());const PORT=(()=>{if(process.env.PORT){const e=parseInt(process.env.PORT);return console.log(`‚úÖ Using PORT from Rust: ${e}`),e}console.log("üîç Finding available port in range 60000-61000...");let e=6e4+Math.floor(1001*Math.random());for(let s=0;s<100;s++){const t=6e4+(e-6e4+s)%1001,o=net.createServer();try{return o.listen(t,"127.0.0.1"),o.close(),console.log(`‚úÖ Found available port: ${t}`),t}catch(e){}}return console.log("‚ö†Ô∏è Could not find available port, using 3001"),3001})();let sessions=new Map,activeProcesses=new Map,activeProcessStartTimes=new Map,lastAssistantMessageIds=new Map,allAssistantMessageIds=new Map,streamHealthChecks=new Map,streamTimeouts=new Map,isSpawningProcess=!1;const processSpawnQueue=[],spawningProcesses=new Map,pendingInterrupts=new Map,pendingStreamingFalseTimers=new Map,STREAMING_FALSE_DEBOUNCE_MS=600,messageBatches=new Map,BATCH_INTERVAL_MS=16;function queueMessage(e,s,t,o=!1){messageBatches.has(e)||messageBatches.set(e,{messages:[],timer:null,socket:t});const n=messageBatches.get(e);n.socket=t;if(o||"result"===s.type||"error"===s.type||"system"===s.type||!0===s.streaming_end||!1===s.streaming)return flushBatch(e),void t.emit(`message:${e}`,s);n.messages.push(s),n.timer||(n.timer=setTimeout(()=>flushBatch(e),16))}function flushBatch(e){const s=messageBatches.get(e);s&&(s.timer&&(clearTimeout(s.timer),s.timer=null),s.messages.length>0&&s.socket&&(1===s.messages.length?s.socket.emit(`message:${e}`,s.messages[0]):s.socket.emit(`messageBatch:${e}`,s.messages),s.messages=[]))}function cleanupBatch(e){const s=messageBatches.get(e);s&&(s.timer&&clearTimeout(s.timer),messageBatches.delete(e))}function cancelPendingStreamingFalse(e){const s=pendingStreamingFalseTimers.get(e);s&&(clearTimeout(s.timer),pendingStreamingFalseTimers.delete(e),console.log(`üîÑ [${e}] Cancelled pending streaming=false (new process starting)`))}async function generateTitle(e,s,t,o){try{console.log(`üè∑Ô∏è Generating title for session ${e}`),console.log(`üè∑Ô∏è Message preview: "${s}"`);const n=`user message: "${s.substring(0,200)}"\ntask: reply with ONLY 1-3 words describing what user wants. lowercase only. no punctuation. be extremely concise. examples: "echo command", "file search", "debug issue"`,i=["-p",n,"--print","--output-format","json","--model","claude-sonnet-4-5-20250929"];console.log(`üè∑Ô∏è Title prompt: "${n}"`);const r={...process.env},a="/opt/homebrew/bin";r.PATH?.includes(a)||(r.PATH=`${a}:${r.PATH||"/usr/bin:/bin"}`);const c=join(homedir(),".yurucode-title-gen");try{existsSync(c)||(mkdirSync(c,{recursive:!0}),console.log("üìÅ Created title generation directory:",c))}catch(e){console.log("‚ö†Ô∏è Could not create title gen directory, using home:",e.message)}const l=isWindows&&"WSL_CLAUDE"===CLAUDE_PATH?(()=>{const{execSync:e}=require("child_process");let s="user";try{s=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){}const t=`/home/${s}/.yurucode-title-gen`;try{e(`C:\\Windows\\System32\\wsl.exe -e bash -c "mkdir -p ${t}"`,{windowsHide:!0})}catch(e){console.log("‚ö†Ô∏è Could not create WSL title gen directory:",e.message)}const[o,n,a]=createWslClaudeCommand(i,t,null);return spawn(o,n,{cwd:c,env:r,stdio:["pipe","pipe","pipe"],windowsHide:!0,detached:!1})})():spawn(CLAUDE_PATH,i,{cwd:c,env:r,stdio:["pipe","pipe","pipe"],windowsHide:!0,detached:!1});let d="",u="";l.stdout.on("data",e=>{d+=e.toString(),console.log(`üè∑Ô∏è Title generation stdout: ${e.toString()}`)}),l.stderr.on("data",e=>{u+=e.toString(),console.log(`üè∑Ô∏è Title generation stderr: ${e.toString()}`)}),l.on("close",s=>{console.log(`üè∑Ô∏è Title generation process closed with code ${s}`),console.log(`üè∑Ô∏è Full output: "${d}"`),u&&console.log(`üè∑Ô∏è Error output: "${u}"`);try{const s=d.trim().split("\n"),n=s[s.length-1];console.log(`üè∑Ô∏è Parsing last line: "${n}"`);const i=JSON.parse(n),r=i.completion||i.result;if(r){let s=r.toLowerCase().replace(/[^\w\s]/g,"").trim().substring(0,30);if(s&&s.length>2){console.log(`üè∑Ô∏è Generated title: "${s}" - emitting to client`);const n=`title:${e}`;console.log(`üè∑Ô∏è Emitting event: ${n} with data:`,{title:s}),t.emit(n,{title:s}),o&&o()}else console.log(`üè∑Ô∏è Title too short or empty: "${s}"`)}else console.log("üè∑Ô∏è No title text in response:",i)}catch(e){console.error("üè∑Ô∏è Failed to parse title response:",e),console.error("üè∑Ô∏è Raw output was:",d)}}),l.on("error",e=>{console.error("üè∑Ô∏è Failed to spawn title generation process:",e)}),l.stdin.end()}catch(e){console.error("üè∑Ô∏è Failed to generate title:",e)}}const MAX_MESSAGE_HISTORY=1e3,MAX_LINE_BUFFER_SIZE=52428800;app.get("/health",(e,s)=>{s.json({status:"ok",pid:process.pid,service:"yurucode-claude",claudeCodeLoaded:!0,port:PORT,sessions:Object.keys(sessions).length})}),app.delete("/claude-project/:projectPath",async(e,s)=>{try{const{projectPath:t}=e.params,o=join(homedir(),".claude","projects",t);if(console.log("Deleting project:",o),!existsSync(o))return s.status(404).json({error:"project not found"});const{rm:n}=await import("fs/promises");await n(o,{recursive:!0,force:!0}),console.log("Project deleted successfully"),s.json({success:!0})}catch(e){console.error("Error deleting project:",e),s.status(500).json({error:"Failed to delete project",details:e.message})}}),app.delete("/claude-session/:projectPath/:sessionId",async(e,s)=>{try{const{projectPath:t,sessionId:o}=e.params,n=join(homedir(),".claude","projects",t,`${o}.jsonl`);if(console.log("Deleting session:",n),!existsSync(n))return s.status(404).json({error:"session not found"});const{unlink:i}=await import("fs/promises");await i(n),console.log("Session deleted successfully"),s.json({success:!0})}catch(e){console.error("Error deleting session:",e),s.status(500).json({error:"Failed to delete session",details:e.message})}}),app.get("/claude-session/:projectPath/:sessionId",async(e,s)=>{try{const{projectPath:t,sessionId:o}=e.params;if(console.log("Loading session request:"),console.log("  - Raw projectPath:",t),console.log("  - SessionId:",o),console.log("  - Platform:",platform()),isWindows){let e="user";try{const{execSync:s}=require("child_process");e=s('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const n=`/home/${e}/.claude/projects/${t}/${o}.jsonl`;console.log("  - WSL path:",n);try{const{execSync:e}=require("child_process"),i=e(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'cat \\"${n}\\" 2>/dev/null'}"`,{encoding:"utf8",windowsHide:!0,maxBuffer:52428800});console.log("Raw file content:",i.replace(/\n/g,"\\n").replace(/\r/g,"\\r")),console.log("Total file size:",i.length,"characters");const r=i[i.length-1];console.log("File ends with:","\n"===r?"newline":"$"===r?"dollar":"char: "+r);const a=[];let c=0,l=0,d=0,u=0;for(;c<i.length;){for(u++;c<i.length&&/\s/.test(i[c]);)c++;if(c>=i.length)break;if("{"!==i[c]){console.log("Warning: Expected { at position",c,"but found:",i[c]);const e=i.indexOf("\n",c);if(-1===e)break;c=e+1;continue}let e=0,s=!1,t=!1,o=-1;for(let n=c;n<i.length;n++){const r=i[n];if(t)t=!1;else if("\\"!==r)if('"'!==r||t){if(!s)if("{"===r)e++;else if("}"===r&&(e--,0===e)){if(!(n+1<i.length)){o=n+1;break}{const e=i[n+1];if("$"===e||"\n"===e||"\r"===e){o=n+1;break}}}}else s=!s;else t=!0}if(-1===o){console.log("Warning: Could not find end of JSON object starting at position",c);break}const n=i.substring(c,o);try{const e=JSON.parse(n);if("user"===e.role){if(!e.content){c=o,c<i.length&&"$"===i[c]&&c++,c<i.length&&"\n"===i[c]&&c++,c<i.length&&"\r"===i[c]&&c++;continue}if(!("string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.length>0?e.content.map(e=>e.text||"").join(""):"").trim()){c=o,c<i.length&&"$"===i[c]&&c++,c<i.length&&"\n"===i[c]&&c++,c<i.length&&"\r"===i[c]&&c++;continue}}a.push(e),l++,l<=5&&("summary"===e.type?console.log(`Line ${u}: Added summary:`,e.summary||""):"user"===e.type?console.log(`Line ${u}: Added user message`):"assistant"===e.type?console.log(`Line ${u}: Added assistant message`):e.sessionId&&console.log(`Line ${u}: Added session metadata`))}catch(e){d++,d<=5&&(console.log(`Failed to parse JSON at line ${u}, position ${c}:`,e.message),console.log("JSON output:",n))}c=o,c<i.length&&"$"===i[c]&&c++,c<i.length&&"\n"===i[c]&&c++,c<i.length&&"\r"===i[c]&&c++}console.log(`Processed ${u} lines, successfully parsed ${l} JSON objects from session file`);const g=t.replace(/^([A-Z])--/,"$1:/").replace(/^-/,"/").replace(/-/g,"/");console.log(`Loaded session with ${a.length} messages`),console.log(`Converted project path: ${t} -> ${g}`);let p=null;if(a.length>0){const e=a[a.length-1];("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(p=e.title)}if(!p){const e=a.find(e=>"summary"===e.type&&e.summary);e&&(p=e.summary)}if(!p){const e=a.find(e=>"user"===e.role&&e.content);if(e){const s="string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.find(e=>"text"===e.type)?.text||"";s&&(p=s.substring(0,100))}}p||(p="Untitled session"),s.json({sessionId:o,projectPath:g,messages:a,sessionCount:a.length,title:p})}catch(e){console.error("Error reading session file from WSL:",e.message),s.status(404).json({error:"Session not found"})}}else{const e=join(homedir(),".claude","projects",t,`${o}.jsonl`);if(console.log("  - Full path:",e),!existsSync(e))return console.error("Session not found:",e),s.status(404).json({error:"session not found"});const{readFile:n}=await import("fs/promises");try{const i=await n(e,"utf8"),r=[],a=i.split(/\$|\n/).filter(e=>e.trim());for(const e of a)try{const s=JSON.parse(e);if("user"===s.role){if(!s.content)continue;if(!("string"==typeof s.content?s.content:Array.isArray(s.content)&&s.content.length>0?s.content.map(e=>e.text||"").join(""):"").trim())continue}r.push(s)}catch(e){}let c=null;if(r.length>0){const e=r[r.length-1];("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(c=e.title)}if(!c){const e=r.find(e=>"summary"===e.type&&e.summary);e&&(c=e.summary)}if(!c){const e=r.find(e=>"user"===e.role&&e.content);if(e){const s="string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.find(e=>"text"===e.type)?.text||"";s&&(c=s.substring(0,100))}}c||(c="Untitled session");const l=t.replace(/^([A-Z])--/,"$1:/").replace(/^-/,"/").replace(/-/g,"/");s.json({sessionId:o,projectPath:l,messages:r,sessionCount:r.length,title:c})}catch(e){console.error("Error reading session file:",e),s.status(500).json({error:"Failed to read session",details:e.message})}}}catch(e){console.error("Error loading session:",e),s.status(500).json({error:"Failed to load session",details:e.message})}}),app.get("/claude-analytics",async(e,s)=>{console.log("üìä Loading analytics from all Claude sessions...");try{const e={totalSessions:0,totalMessages:0,totalTokens:0,totalCost:0,tokenBreakdown:{input:0,output:0,cacheCreation:0,cacheRead:0},byModel:{opus:{sessions:0,tokens:0,cost:0,tokenBreakdown:{input:0,output:0,cacheCreation:0,cacheRead:0}},sonnet:{sessions:0,tokens:0,cost:0,tokenBreakdown:{input:0,output:0,cacheCreation:0,cacheRead:0}}},byDate:{},byProject:{}},t={sonnet:{input:3e-6,output:15e-6,cacheCreation:375e-8,cacheRead:3e-7},opus:{input:15e-6,output:75e-6,cacheCreation:1875e-8,cacheRead:15e-7}};if(isWindows){const{readdir:s,readFile:o,stat:n}=await import("fs/promises"),i=await import("path"),r=["yuru","muuko",process.env.USER,process.env.USERNAME].filter(Boolean),a=["Ubuntu","Ubuntu-20.04","Ubuntu-22.04","Ubuntu-24.04"],c=["\\\\wsl$","\\\\wsl.localhost"];console.log("üìä Analytics: Searching for WSL Claude projects..."),console.log("  Possible users:",r),console.log("  Possible distros:",a);let l=null,d=0;for(const e of c){for(const s of a){for(const t of r){const o=`${e}\\${s}\\home\\${t}\\.claude\\projects`;d++;try{await n(o),l=o,console.log(`‚úÖ Found WSL Claude projects at: ${o} (attempt ${d})`);break}catch(e){}}if(l)break}if(l)break}if(l||console.log(`‚ùå WSL Claude projects not found after ${d} attempts`),l)try{const r=await s(l);console.log(`Found ${r.length} projects in WSL directory`);const a=10;for(const c of r.slice(0,a)){const r=i.win32.join(l,c);try{if(!(await n(r)).isDirectory())continue;console.log(`Processing WSL project: ${c}`);const a=(await s(r)).filter(e=>e.endsWith(".jsonl"));console.log(`  Found ${a.length} session files`);const l=20;for(const s of a.slice(0,l))try{const a=i.win32.join(r,s),l=await n(a);if(l.size>10485760){console.log(`  Skipping large file: ${s} (${l.size} bytes)`);continue}console.log(`  Reading session: ${s} (${l.size} bytes)`);const d=(await o(a,"utf8")).split("\n").filter(e=>e.trim());console.log(`    Total lines in file: ${d.length}`);let u=0,g=0,p="sonnet",m=(new Date).toISOString().split("T")[0],h=0,f={input:0,output:0,cacheCreation:0,cacheRead:0};for(const e of d)try{const s=JSON.parse(e);if("assistant"===s.type&&s.message&&s.message.usage){h++;const e=s.message.usage,o=e.input_tokens||0,n=e.output_tokens||0,i=e.cache_creation_input_tokens||0,r=e.cache_read_input_tokens||0;u+=o+n+i+r,f.input+=o,f.output+=n,f.cacheCreation+=i,f.cacheRead+=r,s.message.model&&(p=s.message.model.includes("opus")?"opus":"sonnet");let a=0;if(null!=s.costUSD)a=s.costUSD;else{const e=t[p];a=o*e.input+n*e.output+i*e.cacheCreation+r*e.cacheRead}g+=a}"user"===s.type&&h++,s.timestamp&&(m=new Date(s.timestamp).toISOString().split("T")[0])}catch(e){}if(console.log(`    Parsed: ${h} messages, ${u} tokens`),u>0){console.log(`    Session: ${u} tokens, $${g.toFixed(4)}`),e.totalSessions++,e.totalMessages+=2*h,e.totalTokens+=u,e.totalCost+=g,e.tokenBreakdown.input+=f.input,e.tokenBreakdown.output+=f.output,e.tokenBreakdown.cacheCreation+=f.cacheCreation,e.tokenBreakdown.cacheRead+=f.cacheRead;const s="opus"===p?"opus":"sonnet";e.byModel[s].sessions++,e.byModel[s].tokens+=u,e.byModel[s].cost+=g,e.byModel[s].tokenBreakdown.input+=f.input,e.byModel[s].tokenBreakdown.output+=f.output,e.byModel[s].tokenBreakdown.cacheCreation+=f.cacheCreation,e.byModel[s].tokenBreakdown.cacheRead+=f.cacheRead,e.byDate[m]||(e.byDate[m]={sessions:0,messages:0,tokens:0,cost:0,tokenBreakdown:{input:0,output:0,cacheCreation:0,cacheRead:0}}),e.byDate[m].sessions++,e.byDate[m].messages+=2*h,e.byDate[m].tokens+=u,e.byDate[m].cost+=g,e.byDate[m].tokenBreakdown.input+=f.input,e.byDate[m].tokenBreakdown.output+=f.output,e.byDate[m].tokenBreakdown.cacheCreation+=f.cacheCreation,e.byDate[m].tokenBreakdown.cacheRead+=f.cacheRead;const t=c.replace(/-/g,"/");e.byProject[t]||(e.byProject[t]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:l.mtime.getTime()}),e.byProject[t].sessions++,e.byProject[t].messages+=2*h,e.byProject[t].tokens+=u,e.byProject[t].cost+=g}}catch(e){console.error(`  Error processing session ${s}:`,e.message)}}catch(e){console.error(`Error processing project ${c}:`,e.message)}}}catch(e){console.error("Error reading WSL projects directory:",e.message),l=null}if(!l){console.log("WSL mount not accessible, trying Windows path...");const r=i.win32.join(homedir(),".claude","projects");try{const a=await s(r);console.log(`Found ${a.length} projects in Windows directory`);for(const c of a.slice(0,5)){const a=i.win32.join(r,c);if(!(await n(a)).isDirectory())continue;console.log(`Processing Windows project: ${c}`);const l=(await s(a)).filter(e=>e.endsWith(".jsonl"));console.log(`  Found ${l.length} session files`);for(const s of l.slice(0,10))try{const r=i.win32.join(a,s),l=await n(r);if(l.size>10485760){console.log(`  Skipping large file: ${s} (${l.size} bytes)`);continue}console.log(`  Reading session: ${s} (${l.size} bytes)`);const d=(await o(r,"utf8")).split("\n").filter(e=>e.trim());console.log(`    Total lines in file: ${d.length}`);let u=0,g=0,p="sonnet",m=(new Date).toISOString().split("T")[0],h=0,f={input:0,output:0,cacheCreation:0,cacheRead:0};for(const e of d)try{const s=JSON.parse(e);if("assistant"===s.type&&s.message&&s.message.usage){h++;const e=s.message.usage,o=e.input_tokens||0,n=e.output_tokens||0,i=e.cache_creation_input_tokens||0,r=e.cache_read_input_tokens||0;u+=o+n+i+r,f.input+=o,f.output+=n,f.cacheCreation+=i,f.cacheRead+=r,s.message.model&&(p=s.message.model.includes("opus")?"opus":"sonnet");let a=0;if(null!=s.costUSD)a=s.costUSD;else{const e=t[p];a=o*e.input+n*e.output+i*e.cacheCreation+r*e.cacheRead}g+=a}"user"===s.type&&h++,s.timestamp&&(m=new Date(s.timestamp).toISOString().split("T")[0])}catch(e){}if(console.log(`    Parsed: ${h} messages, ${u} tokens`),u>0){console.log(`    Session: ${u} tokens, $${g.toFixed(4)}`),e.totalSessions++,e.totalMessages+=2*h,e.totalTokens+=u,e.totalCost+=g,e.tokenBreakdown.input+=f.input,e.tokenBreakdown.output+=f.output,e.tokenBreakdown.cacheCreation+=f.cacheCreation,e.tokenBreakdown.cacheRead+=f.cacheRead;const s="opus"===p?"opus":"sonnet";e.byModel[s].sessions++,e.byModel[s].tokens+=u,e.byModel[s].cost+=g,e.byModel[s].tokenBreakdown.input+=f.input,e.byModel[s].tokenBreakdown.output+=f.output,e.byModel[s].tokenBreakdown.cacheCreation+=f.cacheCreation,e.byModel[s].tokenBreakdown.cacheRead+=f.cacheRead,e.byDate[m]||(e.byDate[m]={sessions:0,messages:0,tokens:0,cost:0,tokenBreakdown:{input:0,output:0,cacheCreation:0,cacheRead:0}}),e.byDate[m].sessions++,e.byDate[m].messages+=2*h,e.byDate[m].tokens+=u,e.byDate[m].cost+=g,e.byDate[m].tokenBreakdown.input+=f.input,e.byDate[m].tokenBreakdown.output+=f.output,e.byDate[m].tokenBreakdown.cacheCreation+=f.cacheCreation,e.byDate[m].tokenBreakdown.cacheRead+=f.cacheRead;const t=c.replace(/-/g,"/");e.byProject[t]||(e.byProject[t]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:l.mtime.getTime()}),e.byProject[t].sessions++,e.byProject[t].messages+=2*h,e.byProject[t].tokens+=u,e.byProject[t].cost+=g}}catch(e){console.error(`  Error processing session ${s}:`,e.message)}}}catch(e){console.error("Error reading Windows projects:",e.message)}}}else{const{readdir:s,readFile:o,stat:n}=await import("fs/promises"),i=join(homedir(),".claude","projects");try{const r=await s(i);for(const a of r){const r=join(i,a);if(!(await n(r)).isDirectory())continue;const c=(await s(r)).filter(e=>e.endsWith(".jsonl"));for(const s of c)try{const n=join(r,s),i=(await o(n,"utf8")).split("\n").filter(e=>e.trim());let c=0,l=0,d="sonnet",u=(new Date).toISOString().split("T")[0],g=0,p={input:0,output:0,cacheCreation:0,cacheRead:0};for(const e of i)try{const s=JSON.parse(e);if("assistant"===s.type&&s.message&&s.message.usage){g++;const e=s.message.usage,o=e.input_tokens||0,n=e.output_tokens||0,i=e.cache_creation_input_tokens||0,r=e.cache_read_input_tokens||0;c+=o+n+i+r,p.input+=o,p.output+=n,p.cacheCreation+=i,p.cacheRead+=r,s.message.model&&(d=s.message.model.includes("opus")?"opus":"sonnet");let a=0;if(null!=s.costUSD)a=s.costUSD;else{const e=t[d];a=o*e.input+n*e.output+i*e.cacheCreation+r*e.cacheRead}l+=a}"user"===s.type&&g++,s.timestamp&&(u=new Date(s.timestamp).toISOString().split("T")[0])}catch(e){}(c>0||g>0)&&(e.totalSessions++,e.totalMessages+=g,e.totalTokens+=c,e.totalCost+=l,e.tokenBreakdown.input+=p.input,e.tokenBreakdown.output+=p.output,e.tokenBreakdown.cacheCreation+=p.cacheCreation,e.tokenBreakdown.cacheRead+=p.cacheRead,"opus"===d?(e.byModel.opus.sessions++,e.byModel.opus.tokens+=c,e.byModel.opus.cost+=l,e.byModel.opus.tokenBreakdown.input+=p.input,e.byModel.opus.tokenBreakdown.output+=p.output,e.byModel.opus.tokenBreakdown.cacheCreation+=p.cacheCreation,e.byModel.opus.tokenBreakdown.cacheRead+=p.cacheRead):(e.byModel.sonnet.sessions++,e.byModel.sonnet.tokens+=c,e.byModel.sonnet.cost+=l,e.byModel.sonnet.tokenBreakdown.input+=p.input,e.byModel.sonnet.tokenBreakdown.output+=p.output,e.byModel.sonnet.tokenBreakdown.cacheCreation+=p.cacheCreation,e.byModel.sonnet.tokenBreakdown.cacheRead+=p.cacheRead),e.byDate[u]||(e.byDate[u]={sessions:0,messages:0,tokens:0,cost:0,tokenBreakdown:{input:0,output:0,cacheCreation:0,cacheRead:0}}),e.byDate[u].sessions++,e.byDate[u].messages+=2*i.length,e.byDate[u].tokens+=c,e.byDate[u].cost+=l,e.byDate[u].tokenBreakdown.input+=p.input,e.byDate[u].tokenBreakdown.output+=p.output,e.byDate[u].tokenBreakdown.cacheCreation+=p.cacheCreation,e.byDate[u].tokenBreakdown.cacheRead+=p.cacheRead,e.byProject[a]||(e.byProject[a]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:Date.now()}),e.byProject[a].sessions++,e.byProject[a].messages+=g,e.byProject[a].tokens+=c,e.byProject[a].cost+=l)}catch(e){console.error(`Error processing session ${s}:`,e.message)}}}catch(e){console.error("Error reading projects directory:",e)}}console.log(`üìä Analytics loaded: ${e.totalSessions} sessions, ${e.totalTokens} tokens`),s.json(e)}catch(e){console.error("Error loading analytics:",e),s.status(500).json({error:"Failed to load analytics",details:e.message})}}),app.get("/claude-projects-quick",async(e,s)=>{try{const t=parseInt(e.query.limit)||20,o=parseInt(e.query.offset)||0;if(isWindows){console.log("üîç Windows detected - loading projects from WSL");let e="user";try{const{execSync:s}=require("child_process");e=s('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const n=`/home/${e}/.claude/projects`;try{const{execFileSync:e}=require("child_process"),i="C:\\Windows\\System32\\wsl.exe",r=`cd "${n}" && for d in *; do [ -d "$d" ] && echo "$d"; done`;console.log("üìÇ Getting projects from WSL:",n);const a=e(i,["-e","bash","-c",r],{encoding:"utf8",windowsHide:!0}).trim();if(!a)return console.log("‚ùå No projects found in WSL"),s.json({projects:[],count:0});const c=a.split("\n").filter(e=>e.trim()).filter(e=>{const s=e.toLowerCase();return!(s.includes("temp")||s.includes("tmp")||s.includes("yurucode-server")||s.includes("yurucode-title-gen")||"-yurucode-title-gen"===s||s.includes("appdata")||s.includes("-mnt-c-users-")&&s.includes("-appdata-local-temp"))||(console.log(`üö´ Filtering out temp/server/title-gen directory: ${e}`),!1)}),l=[];for(const s of c){let t=0;try{const o=e(i,["-e","bash","-c",`cd ${n}/${s} && ls -t *.jsonl 2>/dev/null | head -1 | xargs -r stat -c %Y 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim();o&&!isNaN(o)&&(t=1e3*parseInt(o))}catch(e){t=0}let o=0;try{const t=e(i,["-e","bash","-c",`ls -1 ${n}/"${s}"/*.jsonl 2>/dev/null | wc -l`],{encoding:"utf8",windowsHide:!0}).trim();o=parseInt(t)||0}catch(e){}0===o&&0===t||l.push({name:s,path:s,lastModified:t,sessionCount:o,sessions:[]})}l.sort((e,s)=>s.lastModified-e.lastModified),console.log(`‚úÖ Found ${l.length} projects in WSL`);const d=l.length,u=l.slice(o,o+t);return console.log(`üìÑ Returning ${u.length} projects (offset: ${o}, limit: ${t}, total: ${d})`),void s.json({projects:u,count:d})}catch(e){return console.error("‚ùå ERROR loading Windows projects:",e.message),console.error("Stack:",e.stack),s.json({projects:[],count:0})}}const n=join(homedir(),".claude","projects");if(console.log("Quick loading project list from:",n),!existsSync(n))return console.log("Claude projects directory not found:",n),s.json({projects:[],count:0});const{readdir:i,stat:r}=await import("fs/promises"),a=(await i(n)).filter(e=>!e.startsWith(".")).map(async e=>{try{const s=join(n,e),t=await r(s);if(!t.isDirectory())return null;const o=(await i(s)).filter(e=>e.endsWith(".jsonl")).length;return{path:e,name:e,sessionCount:isWindows&&0===o?null:o,lastModified:t.mtime.getTime()}}catch{return null}}),c=(await Promise.all(a)).filter(Boolean);c.sort((e,s)=>s.lastModified-e.lastModified);const l=c.length,d=c.slice(o,o+t);console.log(`Quick loaded ${d.length} of ${l} project names (offset: ${o}, limit: ${t})`),s.json({projects:d,count:l})}catch(e){console.error("Error quick loading projects:",e),s.status(500).json({error:"Failed to load projects",details:e.message})}}),app.get("/claude-project-sessions/:projectName",async(e,s)=>{try{const t=decodeURIComponent(e.params.projectName);if(console.log("üìÇ Loading sessions for project:",t),s.writeHead(200,{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"}),isWindows){let e="user";try{const{execSync:s}=require("child_process");e=s('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const o=`/home/${e}/.claude/projects/${t}`;try{console.log("üöÄ Getting session list from WSL:",o);const{execFileSync:e}=require("child_process"),t=e("C:\\Windows\\System32\\wsl.exe",["-e","bash","-c",`cd "${o}" 2>/dev/null && for f in *.jsonl; do [ -f "$f" ] && stat -c "%Y:%n" -- "$f"; done | sort -rn | head -50`],{encoding:"utf8",windowsHide:!0}).trim();if(!t)return console.log("No sessions found"),s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();const n=t.split("\n").filter(e=>e.trim()).map(e=>{const[s,t]=e.split(":");return{filename:t,timestamp:1e3*parseInt(s)}}).sort((e,s)=>s.timestamp-e.timestamp).slice(0,10);if(0===n.length)return console.log("No sessions found"),s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();for(let t=0;t<n.length;t++){const{filename:i,timestamp:r}=n[t];try{if(t>=50)break;const a="C:\\Windows\\System32\\wsl.exe",c=e(a,["-e","bash","-c",`head -n1 "${o}/${i}" 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim(),l=e(a,["-e","bash","-c",`tail -n1 "${o}/${i}" 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim(),d=e(a,["-e","bash","-c",`head -n50 "${o}/${i}" 2>/dev/null | wc -l`],{encoding:"utf8",windowsHide:!0}).trim(),u=i.replace(".jsonl","");let g="Untitled session",p=null;try{const e=JSON.parse(l);("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(p=e.title)}catch(e){}if(!p)try{const e=JSON.parse(c);if(e.summary&&(g=e.summary,p||(p=e.summary)),e.title&&(p=e.title),!p&&"user"===e.role&&e.content)if("string"==typeof e.content)g=e.content.substring(0,100),p=g;else if(Array.isArray(e.content)){const s=e.content.find(e=>"text"===e.type);s&&s.text&&(g=s.text.substring(0,100),p=g)}"summary"===e.type&&e.summary&&(p=e.summary,g=e.summary)}catch(e){console.log(`Could not parse session title from: ${c}`)}const m={id:u,summary:g,title:p,timestamp:r,path:i,messageCount:parseInt(d)||0};s.write(`data: ${JSON.stringify({session:m,index:t,total:n.length})}\n\n`),console.log(`  üìÑ Sent session ${t+1}/${n.length}: ${u}`)}catch(e){console.log(`Error processing ${i}:`,e.message)}}s.write('data: {"done": true}\n\n'),console.log("‚úÖ Streamed all sessions"),s.end()}catch(e){console.error("Error loading sessions:",e.message),s.write('data: {"error": true, "message": "'+e.message+'"}\n\n'),s.end()}}else{const{readdir:e,stat:o,readFile:n}=await import("fs/promises"),i=join(homedir(),".claude","projects"),r=join(i,t);try{if(!existsSync(r))return console.log("Project path not found:",r),s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();const t=(await e(r)).filter(e=>e.endsWith(".jsonl")),i=(await Promise.all(t.map(async e=>{try{const s=join(r,e);return{filename:e,timestamp:(await o(s)).mtimeMs}}catch(e){return null}}))).filter(e=>null!==e).sort((e,s)=>s.timestamp-e.timestamp).slice(0,50);if(0===i.length)return console.log("No sessions found in:",r),s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();for(let e=0;e<i.length;e++){const{filename:t,timestamp:o}=i[e];try{const a=join(r,t),c=(await n(a,"utf8")).trim().split("\n"),l=t.replace(".jsonl","");let d="Untitled session",u=null;if(c.length>0)try{const e=JSON.parse(c[c.length-1]);("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(u=e.title)}catch(e){}if(!u&&c.length>0)try{const e=JSON.parse(c[0]);if(e.summary&&(d=e.summary,u=e.summary),e.title&&(u=e.title),!u&&"user"===e.role&&e.content)if("string"==typeof e.content)d=e.content.substring(0,100),u=d;else if(Array.isArray(e.content)){const s=e.content.find(e=>"text"===e.type);s&&s.text&&(d=s.text.substring(0,100),u=d)}"summary"===e.type&&e.summary&&(u=e.summary,d=e.summary)}catch(e){}const g={id:l,summary:d,title:u,timestamp:o,path:t,messageCount:Math.min(c.length,50)};s.write(`data: ${JSON.stringify({session:g,index:e,total:i.length})}\n\n`),console.log(`  üìÑ Sent session ${e+1}/${i.length}: ${l}`)}catch(e){console.log(`Error processing ${t}:`,e.message)}}s.write('data: {"done": true}\n\n'),console.log("‚úÖ Streamed all sessions"),s.end()}catch(e){console.error("Error loading sessions:",e.message),s.write('data: {"error": true, "message": "'+e.message+'"}\n\n'),s.end()}}}catch(e){console.error("Error loading project sessions:",e);try{s.write(`data: {"error": true, "message": "${e.message}"}\n\n`),s.end()}catch(e){}}}),app.get("/claude-project-date/:projectName",async(e,s)=>{try{const t=decodeURIComponent(e.params.projectName);if(console.log(`üìÖ Getting date for project: ${t}`),isWindows){let e="yuru";try{const{execSync:s}=require("child_process");e=s('powershell.exe -NoProfile -Command "& {wsl.exe whoami}"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){}const o=`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'cd ${`/home/${e}/.claude/projects/${t}`} && ls -t *.jsonl 2>/dev/null | head -1 | xargs -r stat -c %Y 2>/dev/null'}"`,{execSync:n}=require("child_process"),i=n(o,{encoding:"utf8",windowsHide:!0}).trim();let r=Date.now();if(i&&!isNaN(i)){r=1e3*parseInt(i);const e=new Date(r);console.log(`  ‚úÖ ${t}: ${e.toLocaleString()} (${i})`)}else console.log(`  ‚ö†Ô∏è ${t}: No sessions found, using current time`);s.json({projectName:t,lastModified:r})}else s.json({projectName:t,lastModified:Date.now()})}catch(t){console.error("Error getting project date:",t),s.json({projectName:e.params.projectName,lastModified:Date.now()})}}),app.get("/claude-project-session-count/:projectName",async(e,s)=>{try{const t=decodeURIComponent(e.params.projectName);if(isWindows){let e="user";try{const{execSync:s}=require("child_process");e=s('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const o=`/home/${e}/.claude/projects/${t}`;try{const{execSync:e}=require("child_process"),n=e(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'ls -1 ${o}/*.jsonl 2>/dev/null | wc -l'}"`,{encoding:"utf8",windowsHide:!0}).trim(),i=parseInt(n)||0;s.json({projectName:t,sessionCount:i})}catch(e){s.json({projectName:t,sessionCount:0})}}else s.json({projectName:t,sessionCount:0})}catch(e){s.status(500).json({error:"Failed to get session count"})}}),app.get("/claude-projects",async(e,s)=>{try{if(isWindows){console.log("üö® WINDOWS DETECTED - LOADING FROM WSL ONLY!");try{let e="yuru";try{const{execSync:s}=require("child_process");console.log("üîç Detecting WSL user via PowerShell...");const t='powershell.exe -NoProfile -Command "& {wsl.exe whoami}"';console.log("üíª PowerShell command:",t),e=s(t,{encoding:"utf8",windowsHide:!0}).trim(),console.log("‚úÖ WSL user found:",e)}catch(s){console.log("‚ö†Ô∏è Could not detect WSL user, using default:",e),console.log("  Error:",s.message)}const t=`/home/${e}/.claude/projects`;console.log("üìÇ WSL projects directory:",t),console.log("üîç WSL user detected:",e);const{execSync:o}=require("child_process");console.log("üîß Executing WSL command via PowerShell to list projects...");const n=`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'if [ -d ${t} ]; then ls -1 ${t}; else echo NO_PROJECTS_DIR; fi'}"`;console.log("üíª PowerShell command:",n);const i=o(n,{encoding:"utf8",windowsHide:!0}).trim();if(console.log("üìù Raw PowerShell/WSL output:",JSON.stringify(i)),!i||"NO_PROJECTS_DIR"===i||"ECHO is on."===i||i.includes("system cannot find"))return console.log("‚ùå No projects found or WSL error"),s.json({projects:[]});const r=i.split("\n").filter(e=>e&&!e.startsWith(".")&&"NO_DIR"!==e).filter(e=>{const s=e.toLowerCase();return!(s.includes("temp")||s.includes("tmp")||s.includes("yurucode-server")||s.includes("yurucode-title-gen")||"-yurucode-title-gen"===s||s.includes("appdata")||s.includes("-mnt-c-users-")&&s.includes("-appdata-local-temp"))||(console.log(`üö´ Filtering out temp/server/title-gen directory: ${e}`),!1)});console.log(`‚úÖ Found ${r.length} projects in WSL (after filtering):`,r);const a=[];for(const e of r){const s=`${t}/${e}`,n=[];try{const e=o(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'find ${s} -name *.jsonl -type f -exec basename {} .jsonl \\\\; 2>/dev/null'}"`,{encoding:"utf8",windowsHide:!0,shell:!0}).trim();if(e){const t=e.split("\n").filter(e=>e);for(const e of t.slice(0,5)){const t=`${s}/${e}.jsonl`;let i="untitled session",r=0,a=Date.now();try{const e=o(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'wc -l < ${t}'}"`,{encoding:"utf8",windowsHide:!0}).trim();r=parseInt(e)||0;const s=o(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'head -n1 ${t}'}"`,{encoding:"utf8",windowsHide:!0}).trim();if(s)try{const e=JSON.parse(s);e.summary?i=e.summary:"user"===e.role&&e.content&&(i=e.content.slice(0,100),e.content.length>100&&(i+="..."))}catch(e){}const n=o(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'stat -c %Y ${t}'}"`,{encoding:"utf8",windowsHide:!0}).trim();a=1e3*parseInt(n)||Date.now()}catch(e){}n.push({id:e,summary:i,timestamp:a,createdAt:a,path:t,messageCount:r})}}}catch(s){console.log(`Error loading sessions for ${e}:`,s.message)}n.length>0&&(n.sort((e,s)=>s.timestamp-e.timestamp),a.push({path:e,name:e,sessions:n,lastModified:n[0].timestamp,createdAt:Math.min(...n.map(e=>e.timestamp)),sessionCount:n.length,totalMessages:n.reduce((e,s)=>e+s.messageCount,0)}))}return a.sort((e,s)=>s.lastModified-e.lastModified),console.log(`‚úÖ Returning ${a.length} projects from WSL`),console.log("üìä Full projects data:",JSON.stringify(a,null,2).slice(0,500)),s.json({projects:a})}catch(e){return console.error("‚ùå ERROR loading WSL projects:",e.message),console.error("Stack:",e.stack),s.json({projects:[],count:0})}}const e=join(homedir(),".claude","projects");if(console.log("Loading projects from:",e),console.log("Platform:",platform()),!existsSync(e))return console.log("Claude projects directory not found:",e),s.json({projects:[]});const{readdir:t,stat:o,readFile:n}=await import("fs/promises"),i=await t(e);console.log(`Found ${i.length} project directories`);const r=i.filter(e=>!e.startsWith(".")).map(async s=>{try{const i=join(e,s),r=await o(i);if(!r.isDirectory())return null;const a=(await t(i)).filter(e=>e.endsWith(".jsonl")).map(async e=>{try{const s=join(i,e),t=await o(s),r=e.replace(".jsonl","");let a="untitled session",c=0,l="";try{const e=(await n(s,"utf8")).split(/\r?\n/).filter(e=>e.trim());c=e.length;for(let s=0;s<Math.min(5,e.length);s++)try{const t=JSON.parse(e[s]);if(t.summary){a=t.summary;break}"user"===t.role&&t.content&&!l&&(l=t.content.slice(0,100))}catch{}"untitled session"===a&&l&&(a=l+(l.length>=100?"...":""))}catch(e){console.error("Error reading session file:",s,e)}return{id:r,summary:a,timestamp:t.mtime.getTime(),createdAt:t.birthtime?.getTime()||t.ctime?.getTime()||t.mtime.getTime(),path:s,messageCount:c}}catch(s){return console.error("Error processing session:",e,s),null}}),c=(await Promise.all(a)).filter(Boolean);if(0===c.length)return null;c.sort((e,s)=>s.timestamp-e.timestamp);const l=Math.min(...c.map(e=>e.createdAt||e.timestamp));return{path:s,name:s,sessions:c,lastModified:c[0]?.timestamp||r.mtime.getTime(),createdAt:l,sessionCount:c.length,totalMessages:c.reduce((e,s)=>e+(s.messageCount||0),0)}}catch(e){return console.error("Error processing project:",s,e),null}}),a=(await Promise.all(r)).filter(Boolean);a.sort((e,s)=>s.lastModified-e.lastModified),console.log(`Returning ${a.length} projects`),s.json({projects:a})}catch(e){console.error("Error loading projects:",e),s.status(500).json({error:"Failed to load projects",details:e.message})}});const pidFilePath=process.env.ELECTRON_RUN_AS_NODE?join(homedir(),`.yurucode-server-${PORT}.pid`):join(__dirname,`server-${PORT}.pid`);function writePidFile(){try{writeFileSync(pidFilePath,process.pid.toString()),console.log(`üìù Server PID ${process.pid} written to ${pidFilePath}`)}catch(e){console.log("‚ö†Ô∏è Could not write PID file (running from read-only location?):",e.message)}try{const e=join(homedir(),".yurucode");existsSync(e)||mkdirSync(e,{recursive:!0});const s=join(e,"current-port.txt");writeFileSync(s,String(PORT)),console.log(`üìù Server PORT ${PORT} written to ${s}`)}catch(e){console.log("‚ö†Ô∏è Could not write port file:",e.message)}}function removePidFile(){try{fs.existsSync(pidFilePath)&&(fs.unlinkSync(pidFilePath),console.log("üóëÔ∏è Removed PID file"))}catch(e){}}let isShuttingDown=!1;function gracefulShutdown(e){if(isShuttingDown)return;isShuttingDown=!0,console.log(`\nüõë ${e} received - graceful shutdown starting...`);const s=activeProcesses.size;if(s>0){console.log(`üî™ Killing ${s} active Claude process(es)...`);for(const[e,s]of activeProcesses.entries())try{s.kill("SIGTERM"),console.log(`   Killed process for session ${e}`)}catch(e){}activeProcesses.clear(),activeProcessStartTimes.clear()}for(const[e,s]of streamHealthChecks.entries())clearInterval(s);streamHealthChecks.clear();for(const[e,s]of streamTimeouts.entries())clearTimeout(s);streamTimeouts.clear();for(const[e,s]of pendingStreamingFalseTimers.entries())s.timer&&clearTimeout(s.timer);pendingStreamingFalseTimers.clear();for(const[e,s]of messageBatches.entries())s.timer&&clearTimeout(s.timer);messageBatches.clear(),io.disconnectSockets(!0),httpServer.close(()=>{console.log("‚úÖ HTTP server closed")}),removePidFile(),sessions.clear(),lastAssistantMessageIds.clear(),allAssistantMessageIds.clear(),console.log("‚úÖ Graceful shutdown complete"),setTimeout(()=>process.exit(0),100)}function cleanupOldPidFiles(){try{const e=/^(\.yurucode-)?server-\d+\.pid$/,s=homedir();if(fs.existsSync(s)){fs.readdirSync(s).forEach(t=>{if(e.test(t)){const e=join(s,t);if(e!==pidFilePath)try{fs.unlinkSync(e),console.log(`üóëÔ∏è Cleaned up old PID file: ${t}`)}catch(e){}}})}const t=__dirname;if(fs.existsSync(t)){fs.readdirSync(t).forEach(s=>{if(e.test(s)){const e=join(t,s);if(e!==pidFilePath)try{fs.unlinkSync(e),console.log(`üóëÔ∏è Cleaned up old PID file: ${s}`)}catch(e){}}})}const o=process.env.TEMP||process.env.TMP||"/tmp",n=join(o,"yurucode-server");if(fs.existsSync(n)){fs.readdirSync(n).forEach(s=>{if(e.test(s)){const e=join(n,s);if(e!==pidFilePath)try{fs.unlinkSync(e),console.log(`üóëÔ∏è Cleaned up old PID file in temp: ${s}`)}catch(e){}}})}console.log("‚úÖ PID file cleanup complete")}catch(e){console.log("‚ö†Ô∏è PID file cleanup error:",e.message)}}process.on("SIGINT",()=>gracefulShutdown("SIGINT")),process.on("SIGTERM",()=>gracefulShutdown("SIGTERM")),process.on("exit",()=>{removePidFile()}),process.on("uncaughtException",e=>{console.error("üí• Uncaught exception:",e),removePidFile(),process.exit(1)}),process.on("unhandledRejection",(e,s)=>{console.error("üí• Unhandled rejection at:",s,"reason:",e)}),io.on("connection",e=>{function s(){if(processSpawnQueue.length>0){const e=processSpawnQueue.shift();console.log(`üîÑ Processing next spawn request. Remaining in queue: ${processSpawnQueue.length}`),e()}}console.log("üîå Client connected:",e.id),e.on("createSession",async(s,t)=>{try{let o,n=null,i=[],r=null;if(s.existingSessionId&&s.messages){o=s.existingSessionId,r=sessions.get(o),r?.wasCompacted?(n=null,console.log(`üìÇ Loading compacted session: ${o} - ignoring old Claude ID`)):(n=s.claudeSessionId||null,console.log(`üìÇ Loading existing session: ${o} with Claude ID: ${n}`)),i=s.messages||[],console.log(`üìù Loaded ${i.length} existing messages`);const e=calculateAccumulatedTokensFromMessages(i);e>0&&initWrapperSessionWithTokens(o,e)}else o=`session-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,console.log(`‚ú® Creating new session: ${o}`);let a=s.workingDirectory;if(a){const e=a.toLowerCase();(e.includes("\\temp\\")||e.includes("/temp/")||e.includes("\\tmp\\")||e.includes("/tmp/")||e.includes("appdata\\local\\temp")||e.includes("yurucode-server"))&&(console.log(`üö´ Rejecting temp directory as working directory: ${a}`),a=null)}a||(a=homedir(),console.log(`üìÇ Using home directory as fallback: ${a}`));const c={id:o,name:s.name||"new session",socketId:e.id,workingDirectory:a,messages:i,createdAt:Date.now(),claudeSessionId:n,hasGeneratedTitle:i.length>0,wasInterrupted:!1,wasCompacted:r?.wasCompacted||!1};sessions.set(o,c),console.log(`‚úÖ Session ready: ${o}`),console.log(`üìÅ Working directory: ${a}`),t&&t({success:!0,sessionId:o,workingDirectory:a})}catch(e){console.error("‚ùå Error creating session:",e),t&&t({success:!1,error:e.message})}}),e.on("sendMessage",async(t,o)=>{console.log("üö®üö®üö® RUNNING FROM: server-claude-macos.cjs FILE"),console.log("Data received:",{...t,content:t.content?"(content present)":"(no content)"});const{sessionId:n,content:i,model:r,autoGenerateTitle:a}=t,c=sessions.get(n);if(!c)return console.error(`‚ùå Session not found: ${n}`),void(o&&o({success:!1,error:"Session not found"}));if(i&&i.startsWith("$")){console.log(`üêö Executing bash command: ${i}`);const s=i.substring(1).trim(),{exec:t}=require("child_process"),{promisify:r}=require("util"),a=r(t);try{e.emit(`message:${n}`,{type:"user",message:{content:i},timestamp:Date.now()});const t=c.workingDirectory||require("os").homedir();let r;if(console.log(`üêö Executing in directory: ${t}`),"win32"===process.platform){const e="C:\\Windows\\System32\\wsl.exe",o=`cd "${t}" && ${s}`;console.log(`üêö Using WSL to execute: ${o}`),r=await a(`"${e}" -e bash -c "${o.replace(/"/g,'\\"')}"`,{timeout:3e4,maxBuffer:10485760})}else r=await a(s,{cwd:t,timeout:3e4,maxBuffer:10485760});const{stdout:l,stderr:d}=r,u=l||d||"(no output)";e.emit(`message:${n}`,{type:"assistant",message:{content:[{type:"text",text:`\`\`\`\n${u}\n\`\`\``}]},streaming:!1,timestamp:Date.now()}),o&&o({success:!0})}catch(s){console.error("‚ùå Bash command failed:",s);let t="";s.stdout&&(t+=s.stdout),s.stderr&&(t&&(t+="\n"),t+=s.stderr),t||(t=s.message);const i=`‚ùå Command failed with exit code ${s.code||"unknown"}\n\n${t}`;e.emit(`message:${n}`,{type:"assistant",message:{content:[{type:"text",text:`\`\`\`ansi\n${i}\n\`\`\``}]},streaming:!1,timestamp:Date.now()}),o&&o({success:!0})}return}console.log(`[${n}] Using model: ${r} (type: ${typeof r})`);const l=async()=>{try{if(console.log("\nüì® Processing message request:",{sessionId:n,messageLength:i?.length||0,model:r,queueLength:processSpawnQueue.length}),spawningProcesses.has(n)){const t=spawningProcesses.get(n),o=Date.now()-t.startTime;return console.log(`‚è≥ [${n}] Process is currently spawning (${o}ms ago) - queueing message`),e.emit(`message:${n}`,{type:"system",subtype:"info",message:"processing previous message, will send yours next...",timestamp:Date.now()}),void setTimeout(()=>{processSpawnQueue.push(l),s()},1500)}if(activeProcesses.has(n)){const t=activeProcesses.get(n),o=activeProcessStartTimes.get(n)||Date.now(),i=Date.now()-o;if(i<3e3)return console.log(`‚è≥ Process for session ${n} is only ${i}ms old, queueing message instead of killing`),e.emit(`message:${n}`,{type:"system",subtype:"info",message:"processing previous message, will send yours next...",timestamp:Date.now()}),void setTimeout(()=>{processSpawnQueue.push(l),s()},2e3);if(console.log(`‚ö†Ô∏è Killing existing process for session ${n} (PID: ${t.pid}, age: ${i}ms)`),"win32"!==process.platform&&t.pid)try{process.kill(-t.pid,"SIGINT")}catch(e){t.kill("SIGINT")}else t.kill("SIGINT");activeProcesses.delete(n),activeProcessStartTimes.delete(n),c.wasInterrupted=!0,console.log(`üîÑ Marked session ${n} as interrupted (keeping claudeSessionId: ${c.claudeSessionId} for resume)`),await new Promise(e=>setTimeout(e,500)),console.log(`üîÑ Emitting streaming=true after interruption for session ${n}`),e.emit(`message:${n}`,{type:"system",subtype:"streaming_resumed",streaming:!0,timestamp:Date.now()})}let t=c.workingDirectory;if(t){const e=t.toLowerCase();(e.includes("\\temp\\")||e.includes("/temp/")||e.includes("\\tmp\\")||e.includes("/tmp/")||e.includes("appdata\\local\\temp")||e.includes("yurucode-server"))&&(console.log(`üö´ Session has temp directory, using home instead: ${t}`),t=null)}t?console.log(`üìÇ Using working directory: ${t}`):(t=homedir(),console.log(`üìÇ Using home directory as fallback: ${t}`));const d=["--print","--output-format","stream-json","--verbose","--dangerously-skip-permissions","--disallowed-tools","AskUserQuestion,EnterPlanMode,ExitPlanMode","--append-system-prompt","CRITICAL: you are in yurucode ui. ALWAYS: use all lowercase (no capitals ever), be extremely concise, never use formal language, no greetings/pleasantries, straight to the point, code/variables keep proper case, one line answers preferred. !!FOR COMPLEX TASKS: YOU MUST PLAN FIRST use THINK and TODO as MUCH AS POSSIBLE to break down everything, including planning into multiple steps and do edits in small chunks!!"];i&&"/compact"===i.trim()?(d.push("--model","claude-sonnet-4-5-20250929"),console.log("ü§ñ Using model: claude-sonnet-4-5-20250929 (forced for /compact)")):r&&(d.push("--model",r),console.log(`ü§ñ Using model: ${r}`));let u=!1;u=c.claudeSessionId,u?(d.push("--resume",c.claudeSessionId),console.log("üîÑ Using --resume flag with session:",c.claudeSessionId),c.wasInterrupted&&(console.log("üìù Resuming after interrupt"),c.wasInterrupted=!1)):console.log("üìù Starting fresh conversation (no previous session)"),console.log("üöÄ Spawning claude with args:",d),console.log(`üîç Active processes count: ${activeProcesses.size}`);const g={...process.env},p="/opt/homebrew/bin";g.PATH?.includes(p)||(g.PATH=`${p}:${g.PATH||"/usr/bin:/bin"}`,console.log(`üîß Added ${p} to PATH for Claude CLI`)),g.CLAUDE_SESSION_ID=n,g.CLAUDE_INSTANCE=`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,g.PWD=t,g.HOME=homedir(),console.log(`üîß Set PWD=${t} and HOME=${homedir()} in environment`),isSpawningProcess&&(console.log("‚è≥ Waiting for previous Claude process to initialize..."),await new Promise(e=>setTimeout(e,200))),isSpawningProcess=!0,spawningProcesses.set(n,{startTime:Date.now(),aborted:!1}),console.log(`üîÑ Session ${n} marked as spawning`),existsSync(t)||(console.warn(`‚ö†Ô∏è Working directory does not exist: ${t}, using home directory`),t=homedir());const m={cwd:t,env:g,shell:!1,windowsHide:!0,detached:!1,stdio:["pipe","pipe","pipe"]};let h;if(console.log("üöÄ Spawning claude process with options:",{cwd:m.cwd,claudePath:CLAUDE_PATH,args:d}),isWindows&&"WSL_CLAUDE"===CLAUDE_PATH){let e=t;if(t&&t.match(/^[A-Z]:\\/)){const s=t[0].toLowerCase();e=`/mnt/${s}${t.substring(2).replace(/\\/g,"/")}`,console.log(`üìÇ Converted Windows path to WSL: ${t} -> ${e}`)}let s=i;if(c.pendingContextRestore&&c.messages&&c.messages.length>0){console.log("üîÑ Building context for WSL command");let e="Here's our previous conversation context:\\n\\n";const t=c.messages.slice(-10);for(const s of t)if("user"===s.type){const t=s.message?.content||"";let o="";"string"==typeof t?o=t:Array.isArray(t)&&(o=t.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`User: ${o.substring(0,200)}${o.length>200?"...":""}\\n\\n`}else if("assistant"===s.type){const t=s.message?.content||"";let o="";"string"==typeof t?o=t:Array.isArray(t)&&(o=t.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`Assistant: ${o.substring(0,200)}${o.length>200?"...":""}\\n\\n`}e+=`---\\nNow, continuing our conversation: ${i}`,s=e,c.pendingContextRestore=!1}const[o,n,r]=createWslClaudeCommand(d,e,s);if(console.log(`üöÄ Running WSL command: ${o}`),console.log("üöÄ WSL args (first 500 chars):",JSON.stringify(n).substring(0,500)),console.log(`üöÄ Input handled in script: ${r}`),!existsSync(o))throw console.error(`‚ùå WSL.exe not found at: ${o}`),console.error("‚ùå Please ensure WSL is installed on Windows"),new Error("WSL.exe not found. Please install Windows Subsystem for Linux.");h=spawn(o,n,m),h.inputHandled=r}else h=spawn(CLAUDE_PATH,d,m);setTimeout(()=>{isSpawningProcess=!1},500),activeProcesses.set(n,h),activeProcessStartTimes.set(n,Date.now()),cancelPendingStreamingFalse(n);const f=spawningProcesses.get(n);if(spawningProcesses.delete(n),console.log(`‚úÖ Session ${n} spawn complete, process registered (PID: ${h.pid})`),f?.aborted||pendingInterrupts.has(n)){console.log(`üõë Session ${n} was interrupted during spawn - killing immediately`);const s=pendingInterrupts.get(n);if(pendingInterrupts.delete(n),h.pid)try{process.kill(-h.pid,"SIGINT")}catch(e){h.kill("SIGINT")}return activeProcesses.delete(n),activeProcessStartTimes.delete(n),s&&s({success:!0,killedDuringSpawn:!0}),void e.emit(`message:${n}`,{type:"system",subtype:"interrupted",message:"task interrupted by user",timestamp:Date.now()})}if("win32"!==process.platform&&h.unref(),c.pendingContextRestore&&c.messages&&c.messages.length>0){console.log(`üîÑ Restoring context with ${c.messages.length} previous messages`);let e="Here's our previous conversation context:\n\n";const s=c.messages.slice(-10);for(const t of s)if("user"===t.type){const s=t.message?.content||"";let o="";"string"==typeof s?o=s:Array.isArray(s)&&(o=s.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`User: ${o.substring(0,200)}${o.length>200?"...":""}\n\n`}else if("assistant"===t.type){const s=t.message?.content||"";let o="";"string"==typeof s?o=s:Array.isArray(s)&&(o=s.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`Assistant: ${o.substring(0,200)}${o.length>200?"...":""}\n\n`}e+=`---\nNow, continuing our conversation: ${i}`;const t=e+"\n";if(console.log(`üìù Sending context + message to claude (${t.length} chars)`),!h.inputHandled){const e=setTimeout(()=>{console.error("‚ö†Ô∏è Stdin write timeout - forcing close");try{h.stdin.end(),h.stdin.destroy()}catch(e){console.error(`Failed to force close stdin: ${e.message}`)}},1e4);h.stdin.write(t,s=>{clearTimeout(e),s?console.error("‚ùå Error writing to stdin:",s):console.log("‚úÖ Successfully sent context restoration"),h.stdin.end(),console.log("üìù Closed stdin after sending message (--print mode requires this)")})}c.pendingContextRestore=!1}else if(i&&!h.inputHandled){const e=i+"\n";console.log(`üìù Sending message to claude via stdin (${i.length} chars) - resuming=${u}`);const s=setTimeout(()=>{console.error("‚ö†Ô∏è Stdin write timeout - forcing close");try{h.stdin.end(),h.stdin.destroy()}catch(e){console.error(`Failed to force close stdin: ${e.message}`)}},1e4);h.stdin.write(e,e=>{clearTimeout(s),e?console.error("‚ùå Error writing to stdin:",e):console.log("‚úÖ Successfully wrote to stdin"),h.stdin.end(),console.log("üìù Closed stdin after sending message (--print mode requires this)")})}else h.inputHandled?console.log("üìù Message already embedded in WSL script"):i||console.log("üìù No message to send");if(console.log(`üè∑Ô∏è Title check: hasGeneratedTitle=${c.hasGeneratedTitle}, messageLength=${i?.length}, autoGenerateTitle=${a}`),a&&!c.hasGeneratedTitle&&i&&i.length>5){let s=i;try{const e=JSON.parse(i);if(Array.isArray(e)){s=e.filter(e=>"text"===e.type).map(e=>e.text).join(" "),console.log(`üè∑Ô∏è Extracted text from JSON: "${s}"`)}}catch(e){console.log(`üè∑Ô∏è Using plain text content: "${s}"`)}s&&s.trim().length>5?(console.log(`üè∑Ô∏è Calling generateTitle for session ${n}`),generateTitle(n,s,e,()=>{console.log(`üè∑Ô∏è Title successfully generated for session ${n}`),c.hasGeneratedTitle=!0})):console.log(`üè∑Ô∏è Skipping title generation - text too short: "${s}"`)}let y="",w=0,$=0,S=Date.now(),k=Date.now();streamHealthChecks.has(n)&&clearInterval(streamHealthChecks.get(n)),streamTimeouts.has(n)&&clearTimeout(streamTimeouts.get(n));const b=setInterval(()=>{const s=Date.now()-S,t=Date.now()-k;if(debugLog(`ü©∫ [${n}] duration: ${t}ms | since_last: ${s}ms | bytes: ${$} | msgs: ${w} | buffer: ${y.length} | alive: ${activeProcesses.has(n)}`),s>3e4&&(console.error(`‚ö†Ô∏è WARNING: No data received for ${s}ms!`),e.emit(`keepalive:${n}`,{timestamp:Date.now()})),s>45e3&&s<5e4&&(console.warn(`‚ö†Ô∏è Stream stalled for ${s}ms, attempting recovery...`),activeProcesses.has(n))){const e=activeProcesses.get(n);if(e.stdin&&!e.stdin.destroyed)try{e.stdin.write("\n\n"),console.log("üìù Sent newlines to potentially unstick process")}catch(e){console.error(`Failed to write to stdin: ${e.message}`)}}},5e3);streamHealthChecks.set(n,b);const C=setTimeout(()=>{if(console.warn(`‚è∞ Stream timeout reached for session ${n} after 2 hours`),activeProcesses.has(n)){const e=activeProcesses.get(n);console.log(`‚è∞ Terminating long-running process for ${n}`),e.kill("SIGTERM")}},72e5);streamTimeouts.set(n,C);const T=s=>{if(s.trim()){debugLog(`üîπ [${n}] Processing line (${s.length} chars): ${s}`);try{const e=processWrapperLine(s,n);e&&e!==s&&(s=e)}catch(e){console.error("[WRAPPER] Error processing line:",e.message)}if(S=Date.now(),s.includes("No conversation found with session ID")){console.log(`üîÑ [${n}] Resume failed - session not found in Claude storage`),console.log(`üîÑ [${n}] Will create new session with existing context on next message`);const s=sessions.get(n);if(s){s.claudeSessionId=null;const t={id:`result-error-${Date.now()}-${Math.random()}`,type:"result",subtype:"error",is_error:!0,error:"Session not found - restoring from checkpoint",requiresCheckpointRestore:!0,streaming:!1,timestamp:Date.now()},o=`message:${n}`;console.log(`üì§ [${n}] Emitting error result with checkpoint restore flag`),e.emit(o,t),console.log(`üì§ [${n}] Sent checkpoint restore signal`);const i=`system-info-${Date.now()}-${Math.random()}`;e.emit(`message:${n}`,{id:i,type:"system",subtype:"info",message:{content:"session history not found - send message again to continue"},timestamp:Date.now(),streaming:!1}),console.log(`üì§ [${n}] Sent info message ${i} about session not found`),s.isReady=!0,console.log(`‚úÖ [${n}] Session marked as ready after resume failure`)}return}try{const t=JSON.parse(s);console.log(`üì¶ [${n}] Message type: ${t.type}${t.subtype?` (${t.subtype})`:""}`);const o=c?.messages?.filter(e=>"user"===e.role).pop(),i="/compact"===o?.message?.content?.trim()&&"result"===t.type;if(t.session_id&&!i){const e=c.claudeSessionId;if(e&&e!==t.session_id){const s=getWrapperSession(n);console.log(`üîÑ [${n}] Claude session ID changed (${e} ‚Üí ${t.session_id})`),console.log(`üîÑ [${n}] Preserving accumulated tokens: ${s.totalTokens} (history still sent to claude)`)}c.claudeSessionId=t.session_id,console.log(`üìå [${n}] Claude session ID: ${c.claudeSessionId}`)}else i&&t.session_id&&console.log(`üóúÔ∏è [${n}] Ignoring session ID from compact result: ${t.session_id} (not resumable)`);if("system"===t.type&&"init"===t.subtype)e.emit(`message:${n}`,{type:"system",subtype:"init",message:t,timestamp:Date.now()});else if("assistant"===t.type){const s=`assistant-${n}-${Date.now()}-${Math.random()}`;if(t.message?.content){let o=!1,i=[],r=!1;for(const s of t.message.content)if("text"===s.type||"thinking"===s.type)o=!0,i.push(s),"thinking"===s.type&&console.log(`üß† [${n}] Found thinking block: ${(s.thinking||s.text||"").substring(0,100)}...`);else if("tool_use"===s.type){r=!0;let o=s.input;if(("Edit"===s.name||"MultiEdit"===s.name)&&s.input?.file_path)try{const e=s.input.file_path,t=isAbsolute(e)?e:join(c.workingDirectory||process.cwd(),e);if(console.log(`üìç [${n}] Calculating line numbers for ${s.name} on ${t}`),existsSync(t)){const e=readFileSync(t,"utf8"),i=e.split("\n");if(console.log(`üìç [${n}] File has ${i.length} lines`),"Edit"===s.name&&s.input.old_string){const e=s.input.old_string.split("\n");console.log(`üìç [${n}] Looking for ${e.length} line(s) in file`);let t=!1;for(let r=0;r<=i.length-e.length;r++){let a=!0;for(let s=0;s<e.length;s++)if(i[r+s]!==e[s]){a=!1;break}if(a){o={...s.input,lineNumber:r+1,endLineNumber:r+e.length},console.log(`üìç [${n}] Found edit at lines ${r+1}-${r+e.length}`),t=!0;break}}t||console.log(`üìç [${n}] Could not find exact match for old_string in file`)}else if("MultiEdit"===s.name&&s.input.edits){let t=e,r=i;const a=s.input.edits.map((e,s)=>{if(!e.old_string)return e;const o=e.old_string.split("\n");console.log(`üìç [${n}] Edit ${s+1}: Looking for ${o.length} line(s)`);for(let i=0;i<=r.length-o.length;i++){let a=!0;for(let e=0;e<o.length;e++)if(r[i+e]!==o[e]){a=!1;break}if(a){console.log(`üìç [${n}] Edit ${s+1} found at lines ${i+1}-${i+o.length}`);const a=e.new_string.split("\n");return r.splice(i,o.length,...a),t=r.join("\n"),{...e,lineNumber:i+1,endLineNumber:i+o.length}}}return console.log(`üìç [${n}] Edit ${s+1} could not find match`),e});o={...s.input,edits:a}}}else console.log(`üìç [${n}] File not found: ${t}`)}catch(e){console.log(`üìç [${n}] Error calculating line numbers for ${s.name}: ${e.message}`)}const i={type:"tool_use",message:{name:s.name,input:o,id:s.id},timestamp:Date.now(),id:`tool-${n}-${Date.now()}`};t.parent_tool_use_id&&(i.parent_tool_use_id=t.parent_tool_use_id,debugLog(`ü§ñ [${n}] Subagent tool_use (parent: ${t.parent_tool_use_id.substring(0,20)}...): ${s.name}`)),queueMessage(n,i,e,!0)}if(o&&i.length>0){lastAssistantMessageIds.set(n,s),console.log(`üìù [${n}] Emitting assistant message ${s} with streaming=true`),console.log(`üìù [${n}] Content blocks: ${i.length} (types: ${i.map(e=>e.type).join(", ")})`);const o={type:"assistant",id:s,message:{...t.message,content:i},streaming:!0,timestamp:Date.now()};if(t.parent_tool_use_id&&(o.parent_tool_use_id=t.parent_tool_use_id,debugLog(`ü§ñ [${n}] Subagent assistant message (parent: ${t.parent_tool_use_id.substring(0,20)}...)`)),queueMessage(n,o,e),c.messages.push({type:"assistant",message:{content:i},id:s,timestamp:Date.now()}),c.messages.length>1e3){const e=Math.floor(200);c.messages.splice(0,e),console.log(`üßπ Trimmed ${e} old messages from session ${n}`)}w++}else if(r&&!o){lastAssistantMessageIds.set(n,s),allAssistantMessageIds.has(n)||allAssistantMessageIds.set(n,[]),allAssistantMessageIds.get(n).push(s),console.log(`üìù [${n}] Emitting assistant message ${s} (tool-only) with streaming=true`),e.emit(`message:${n}`,{type:"assistant",id:s,message:{...t.message,content:[]},streaming:!0,timestamp:Date.now()});const o=sessions.get(n);o&&o.messages.push({type:"assistant",message:{content:[]},id:s,timestamp:Date.now()}),w++}}}else if("user"===t.type&&t.message?.content){for(const s of t.message.content)if("tool_result"===s.type){let o=s.content;if("string"==typeof s.content&&(s.content.includes("has been updated")||s.content.includes("Applied")&&s.content.includes("edits to"))){const e=s.content.match(/The file (.+?) has been updated/)||s.content.match(/Applied \d+ edits? to (.+?):/);if(e){const t=e[1],i=join(c.workingDirectory||process.cwd(),t);console.log(`üìù [${n}] Attempting to enhance diff for: ${t}`);try{if(existsSync(i)){const e=readFileSync(i,"utf8").split("\n"),t=s.content.split("\n"),r=/^\s*(\d+)‚Üí/,a=new Set;if(t.forEach(e=>{const s=e.match(r);s&&a.add(parseInt(s[1]))}),a.size>0){console.log(`üìù [${n}] Found ${a.size} changed lines, enhancing with context`);const s=3,i=[],r=t.findIndex(e=>e.includes("Here's the result of running"));r>=0&&i.push(...t.slice(0,r+1));const c=Array.from(a).sort((e,s)=>e-s);let l=-999;c.forEach(t=>{const o=Math.max(1,t-s),n=Math.min(e.length,t+s);for(let s=o;s<t;s++)if(s>l){const t=String(s).padStart(6," ");a.has(s)?i.push(`${t}‚Üí${e[s-1]}`):i.push(`${t} ${e[s-1]}`),l=s}const r=String(t).padStart(6," ");t>l&&(i.push(`${r}‚Üí${e[t-1]}`),l=t);for(let s=t+1;s<=n;s++)if(s>l){const t=String(s).padStart(6," ");a.has(s)?i.push(`${t}‚Üí${e[s-1]}`):i.push(`${t} ${e[s-1]}`),l=s}const d=c[c.indexOf(t)+1];d&&d>n+1&&i.push("   ...")}),o=i.join("\n"),console.log(`üìù [${n}] Enhanced diff created with ${i.length} lines`)}else console.log(`üìù [${n}] No line numbers found in diff, keeping original content`)}}catch(e){console.log(`Could not enhance Edit output with context lines: ${e.message}`)}}}const i={type:"tool_result",message:{tool_use_id:s.tool_use_id,content:o,is_error:s.is_error},timestamp:Date.now(),id:`toolresult-${n}-${Date.now()}`};t.parent_tool_use_id&&(i.parent_tool_use_id=t.parent_tool_use_id,console.log(`ü§ñ [${n}] Subagent tool_result (parent: ${t.parent_tool_use_id.substring(0,20)}...)`)),e.emit(`message:${n}`,i)}}else if("content_block_start"===t.type)console.log(`üìù [${n}] Content block starting:`,t.content_block?.type),e.emit(`message:${n}`,{type:"content_block_start",content_block:t.content_block,index:t.index,timestamp:Date.now()});else if("content_block_stop"===t.type)console.log(`üìù [${n}] Content block stopped:`,t.index),e.emit(`message:${n}`,{type:"content_block_stop",index:t.index,timestamp:Date.now()});else if("rate_limit"===t.type)console.log(`‚ö†Ô∏è [${n}] Rate limit:`,t.rate_limit),e.emit(`message:${n}`,{type:"rate_limit",rate_limit:t.rate_limit,timestamp:Date.now()});else if("progress"===t.type)console.log(`‚è≥ [${n}] Progress:`,t.progress),e.emit(`message:${n}`,{type:"progress",progress:t.progress,message:t.message,timestamp:Date.now()});else if("compact"===t.type||"system"===t.type&&"compact"===t.subtype)console.log(`üóúÔ∏è [${n}] Context compacted`),e.emit(`message:${n}`,{type:"system",subtype:"compact",message:{content:"context compressed - usage will reset on next message"},timestamp:Date.now()});else if("ping"===t.type||"pong"===t.type)console.log(`üèì [${n}] ${t.type} received`);else if("metadata"===t.type)console.log(`üìã [${n}] Metadata:`,t),t.title&&e.emit(`title:${n}`,t.title);else if("summary"===t.type)console.log(`üìù [${n}] Summary:`,t.summary),t.summary&&e.emit(`title:${n}`,t.summary);else if("result"===t.type){console.log(`üì¶ [${n}] RESULT MESSAGE RECEIVED!`),console.log(`   ‚úÖ Result: success=${!t.is_error}, duration=${t.duration_ms}ms`),console.log("   üìä Full result data:",JSON.stringify(t,null,2));const s=sessions.get(n),o=s?.messages?.filter(e=>"user"===e.role).pop(),i="/compact"===o?.message?.content?.trim()&&(t.result?.includes("Compacted")||t.result?.includes("compressed")||t.result?.includes("summary")||""===t.result||null===t.result);if(i){if(console.log(`üóúÔ∏è [${n}] Detected /compact command completion`),console.log(`üóúÔ∏è [${n}] Result text: "${t.result}"`),console.log(`üóúÔ∏è [${n}] Session ID in result: ${t.session_id}`),console.log(`üóúÔ∏è [${n}] Usage data:`,t.usage),s){const e=s.claudeSessionId;s.claudeSessionId=null,s.wasCompacted=!0,console.log(`üóúÔ∏è Cleared session ID (was ${e}) - next message will start fresh after compact`),console.log("üóúÔ∏è Marked session as compacted to prevent old ID restoration"),console.log("üóúÔ∏è The compact command has summarized the conversation - continuing with reduced context")}const o=t.usage?{input:t.usage.input_tokens||0,output:t.usage.output_tokens||0,cache_creation:t.usage.cache_creation_input_tokens||0,cache_read:t.usage.cache_read_input_tokens||0,total:(t.usage.input_tokens||0)+(t.usage.output_tokens||0)+(t.usage.cache_creation_input_tokens||0)+(t.usage.cache_read_input_tokens||0)}:null;o&&console.log(`üóúÔ∏è [${n}] Compacted token count: ${o.total} (input: ${o.input}, output: ${o.output})`),e.emit(`message:${n}`,{type:"system",subtype:"compact",session_id:null,message:{content:"context compacted - starting fresh with reduced tokens",compactedTokens:o,compactSummary:t.result||"conversation summarized"},timestamp:Date.now()})}if(t.usage){const e=t.usage.input_tokens||0,s=t.usage.output_tokens||0,o=t.usage.cache_creation_input_tokens||0,i=t.usage.cache_read_input_tokens||0,r=getWrapperSession(n).totalTokens,a=i+o+e+s;console.log("\nüìä TOKEN USAGE BREAKDOWN:"),console.log("   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"),console.log("   ‚îÇ Type            ‚îÇ Input    ‚îÇ Cache Read   ‚îÇ Cache New  ‚îÇ"),console.log("   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"),console.log(`   ‚îÇ User Message    ‚îÇ ${String(e).padEnd(8)} ‚îÇ              ‚îÇ            ‚îÇ`),console.log(`   ‚îÇ Assistant Reply ‚îÇ ${String(s).padEnd(8)} ‚îÇ              ‚îÇ            ‚îÇ`),console.log(`   ‚îÇ Context History ‚îÇ          ‚îÇ ${String(i).padEnd(12)} ‚îÇ            ‚îÇ`),console.log(`   ‚îÇ New Cache       ‚îÇ          ‚îÇ              ‚îÇ ${String(o).padEnd(10)} ‚îÇ`),console.log("   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"),console.log(`   ‚îÇ Subtotal        ‚îÇ ${String(e+s).padEnd(8)} ‚îÇ ${String(i).padEnd(12)} ‚îÇ ${String(o).padEnd(10)} ‚îÇ`),console.log("   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"),console.log(`   API REPORTED: ${a} | TRACKED TOTAL: ${r} / 200000 (${(r/2e3).toFixed(1)}%)`),console.log("   Note: Tracked total persists even when Anthropic's cache expires")}const a=lastAssistantMessageIds.get(n);a&&console.log(`üìã [${n}] Result received with last assistant message ${a} - deferring streaming=false to process exit`),console.log(`‚úÖ [${n}] Sending result message with model: ${r}`);const c={type:"result",...t,streaming:!1,id:`result-${n}-${Date.now()}`,model:r||"unknown"};if(t.usage){c.usage=t.usage;const e=getWrapperSession(n);c.wrapper={tokens:{input:t.usage.input_tokens||0,output:t.usage.output_tokens||0,total:e.totalTokens,cache_read:t.usage.cache_read_input_tokens||0,cache_creation:t.usage.cache_creation_input_tokens||0}},console.log("üìä [WRAPPER-TOKENS] Added both usage and wrapper tokens to result message:",{usage:c.usage,wrapperTokens:c.wrapper.tokens})}else console.log("‚ùå [WRAPPER-TOKENS] No usage data in jsonData, neither usage nor wrapper field added");!i&&s.claudeSessionId&&(c.session_id=s.claudeSessionId),console.log(`   - Model in result message: ${c.model}`),console.log(`   - Session ID in result message: ${c.session_id||"(cleared after compact)"}`),c.usage&&(console.log("   - Usage breakdown (CUMULATIVE for session - NOT current context size):"),console.log(`     ‚Ä¢ input_tokens: ${c.usage.input_tokens||0} (cumulative)`),console.log(`     ‚Ä¢ output_tokens: ${c.usage.output_tokens||0} (cumulative)`),console.log(`     ‚Ä¢ cache_creation: ${c.usage.cache_creation_input_tokens||0} (cumulative)`),console.log(`     ‚Ä¢ cache_read: ${c.usage.cache_read_input_tokens||0} (cumulative sum across turns)`),console.log(`     ‚Ä¢ ACTUAL CURRENT CONTEXT: ${c.wrapper?.tokens?.total||0} (from last assistant message)`)),debugLog("üì§ [EMIT-DEBUG] About to emit result message with wrapper field:",{hasWrapper:!!c.wrapper,wrapperTokens:c.wrapper?.tokens,messageKeys:Object.keys(c),wrapperStructure:c.wrapper?Object.keys(c.wrapper):null}),e.emit(`message:${n}`,c),w++}}catch(e){debugLog(`‚ö†Ô∏è [${n}] Failed to parse JSON, treating as plain text:`,e.message),debugLog(`‚ö†Ô∏è [${n}] Line was: ${s}`)}}else debugLog(`üî∏ [${n}] Empty line received`)};console.log(`üîç [${n}] Process spawned with PID: ${h.pid}`),console.log(`üîç [${n}] Process connected: ${h.connected}`);let P="";h.stderr.on("data",e=>{const s=e.toString();P+=s,console.error(`‚ùå [${n}] STDERR output: ${s}`),(s.includes("command not found")||s.includes("No such file"))&&(console.error(`‚ùå [${n}] WSL PATH ERROR - Claude CLI not found!`),console.error(`‚ùå [${n}] Full stderr: ${P}`)),(s.includes("bash:")||s.includes("sh:"))&&console.error(`‚ùå [${n}] WSL BASH ERROR detected`)});const _=setInterval(()=>{if(y.length>0&&Date.now()-S>5e3&&(console.warn(`‚ö†Ô∏è [${n}] Flushing stale buffer (${y.length} chars)`),y.trim()))try{T(y),y=""}catch(e){console.log(`üìù [${n}] Buffer contains incomplete JSON, waiting for more data`)}},5e3);h.stdout.on("data",e=>{const s=e.toString();if($+=e.length,S=Date.now(),console.log(`üì• [${n}] STDOUT received: ${s.length} bytes (total: ${$})`),console.log(`üì• [${n}] Data preview: ${s.substring(0,200)}...`),y.length>52428800){if(console.error(`‚ö†Ô∏è [${n}] Line buffer overflow (${y.length} bytes), processing and clearing`),y.includes("{")){const e=y.match(/\{[^}]*\}/g);if(e)for(const s of e)try{T(s)}catch(e){console.error(`[${n}] Failed to process JSON chunk:`,e)}}y=""}y+=s;const t=y.split("\n");y=t.pop()||"",debugLog(`üìã [${n}] Split into ${t.length} lines, buffer remaining: ${y.length} chars`);for(let e=0;e<t.length;e++)debugLog(`üìã [${n}] Processing line ${e+1}/${t.length}`),T(t[e])}),h.on("exit",()=>{clearInterval(_)}),h.stderr.on("data",s=>{const t=s.toString();if(console.error(`‚ö†Ô∏è [${n}] Claude stderr (${s.length} bytes):`,t),S=Date.now(),t.includes("No conversation found with session ID")){console.log("üîÑ Resume failed - session not found in Claude storage"),console.log("üîÑ Clearing invalid session ID - will use fresh conversation on next message"),c?.wasCompacted&&console.log("üîÑ This was expected - session was compacted and old ID is no longer valid"),c.claudeSessionId=null,c.wasInterrupted=!1;const s={id:`result-error-${Date.now()}-${Math.random()}`,type:"result",subtype:"error",is_error:!0,error:"Session not found - restoring from checkpoint",requiresCheckpointRestore:!0,streaming:!1,timestamp:Date.now()},t=`message:${n}`;console.log(`üì§ [${n}] Emitting error result with checkpoint restore (stderr)`),e.emit(t,s),console.log(`üì§ [${n}] Sent checkpoint restore signal (stderr)`)}else e.emit(`message:${n}`,{type:"error",error:t,claudeSessionId:c.claudeSessionId,streaming:!1})}),h.on("close",s=>{if(h.stdin&&!h.stdin.destroyed)try{h.stdin.end(),console.log("üìù Closed stdin on process exit")}catch(e){}streamHealthChecks.has(n)&&(clearInterval(streamHealthChecks.get(n)),streamHealthChecks.delete(n)),streamTimeouts.has(n)&&(clearTimeout(streamTimeouts.get(n)),streamTimeouts.delete(n)),clearInterval(b);const t=Date.now()-k;if(console.log(`üëã [${n}] Claude process exited with code ${s}`),console.log(`üìä [${n}] STREAM SUMMARY:`),console.log(`   ‚îú‚îÄ Total duration: ${t}ms`),console.log(`   ‚îú‚îÄ Total bytes: ${$}`),console.log(`   ‚îú‚îÄ Messages: ${w}`),console.log(`   ‚îú‚îÄ Exit code: ${s}`),console.log(`   ‚îú‚îÄ Stderr: ${P||"(empty)"}`),console.log(`   ‚îî‚îÄ Line buffer: ${y||"(empty)"}`),0===$&&(console.error(`‚ùå [${n}] NO OUTPUT RECEIVED FROM CLAUDE!`),console.error(`‚ùå [${n}] This usually means:`),console.error("   1. Claude CLI is not installed in WSL"),console.error("   2. Claude is not in any of the expected paths"),console.error("   3. WSL is not running properly"),console.error("   4. The command syntax is wrong")),activeProcesses.delete(n),activeProcessStartTimes.delete(n),0===s){const e=sessions.get(n);e&&(e.wasInterrupted=!1,console.log(`‚úÖ Marked session ${n} as completed normally`))}else if(1===s){const s=sessions.get(n);if(s&&s.claudeSessionId&&P.includes("No conversation found")){console.log("‚ö†Ô∏è Resume failed - session not found in Claude storage"),console.log("üîÑ Will recreate session with existing context on next attempt"),s.claudeSessionId=null;const t={id:`result-error-${Date.now()}-${Math.random()}`,type:"result",subtype:"error",is_error:!0,error:"Session not found - restoring from checkpoint",requiresCheckpointRestore:!0,streaming:!1,timestamp:Date.now()},o=`message:${n}`;console.log(`üì§ [${n}] Emitting error result with checkpoint restore (exit code 1)`),e.emit(o,t),console.log(`üì§ [${n}] Sent checkpoint restore signal (exit code 1)`);const i=lastAssistantMessageIds.get(n);i&&(console.log(`üî¥ Clearing assistant message ID ${i} after resume failure`),lastAssistantMessageIds.delete(n)),e.emit(`message:${n}`,{type:"system",subtype:"info",message:{content:"continuing conversation (session history not found in claude)"},timestamp:Date.now(),streaming:!1})}}if(y.trim())try{T(y)}catch(e){console.error("Failed to process remaining buffer:",e)}const o=sessions.get(n);if(o?.wasInterrupted)console.log("üîÑ Skipping streaming=false for interrupted process (new process is running)");else{const s=lastAssistantMessageIds.get(n);cancelPendingStreamingFalse(n),console.log(`‚è±Ô∏è [${n}] Scheduling streaming=false with 600ms debounce`);const t=setTimeout(()=>{if(activeProcesses.has(n))return console.log(`üîÑ [${n}] New process started during debounce - skipping streaming=false`),void pendingStreamingFalseTimers.delete(n);const t=sessions.get(n);if(t?.wasInterrupted)return console.log(`üîÑ [${n}] Session interrupted during debounce - skipping streaming=false`),void pendingStreamingFalseTimers.delete(n);if(s){console.log(`üî¥ [${n}] Debounce complete - marking streaming=false for ${s}`);const o=t?.messages.find(e=>e.id===s);e.emit(`message:${n}`,{type:"assistant",id:s,message:o?.message||{content:""},streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(n)}e.emit(`message:${n}`,{type:"system",subtype:"stream_end",streaming:!1,timestamp:Date.now()}),pendingStreamingFalseTimers.delete(n)},600);pendingStreamingFalseTimers.set(n,{timer:t,timestamp:Date.now()})}null===s||-2===s||"SIGKILL"===s?(console.error(`‚ö†Ô∏è Claude process terminated unexpectedly (code: ${s})`),e.emit(`message:${n}`,{type:"error",error:"session terminated unexpectedly. you can resume by sending another message.",streaming:!1,timestamp:Date.now()})):0!==s&&(o.wasInterrupted?(console.log(`Process exited with code ${s} after interruption - not showing error`),o.wasInterrupted=!1):(console.error(`Claude process failed with exit code ${s}`),e.emit(`message:${n}`,{type:"system",subtype:"info",message:`process completed with code ${s}`,timestamp:Date.now()})))}),h.on("error",s=>{streamHealthChecks.has(n)&&(clearInterval(streamHealthChecks.get(n)),streamHealthChecks.delete(n)),streamTimeouts.has(n)&&(clearTimeout(streamTimeouts.get(n)),streamTimeouts.delete(n)),clearInterval(b),console.error(`‚ùå [${n}] Failed to spawn claude:`,s),console.error(`‚ùå [${n}] Error details:`,{message:s.message,code:s.code,syscall:s.syscall,path:s.path}),cancelPendingStreamingFalse(n);const t=lastAssistantMessageIds.get(n);if(t){console.log(`üî¥ Forcing streaming=false for assistant message ${t} on process error`);const s=sessions.get(n),o=s?.messages.find(e=>e.id===t);e.emit(`message:${n}`,{type:"assistant",id:t,message:o?.message||{content:""},streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(n)}e.emit(`message:${n}`,{type:"error",error:`claude process error: ${s.message}. try sending your message again.`,claudeSessionId:c.claudeSessionId,streaming:!1}),activeProcesses.delete(n),activeProcessStartTimes.delete(n),lastAssistantMessageIds.delete(n),o&&o({success:!1,error:s.message})}),o&&o({success:!0})}catch(s){console.error("‚ùå Error in spawnRequest:",s),e.emit(`message:${n}`,{type:"error",error:s.message,claudeSessionId:c.claudeSessionId,streaming:!1}),o&&o({success:!1,error:s.message})}finally{s()}};processSpawnQueue.push(l),console.log(`üìã Added request to queue. Queue length: ${processSpawnQueue.length}`),1===processSpawnQueue.length&&s()}),e.on("interrupt",({sessionId:s},t)=>{const o=activeProcesses.get(s),n=sessions.get(s);console.log(`‚õî Interrupt requested for session ${s}`);const i=processSpawnQueue.length;i>0&&(processSpawnQueue.length=0,console.log(`üßπ Cleared ${i} queued messages after interrupt`));const r=spawningProcesses.get(s);if(r&&!r.aborted)return console.log(`‚ö†Ô∏è Session ${s} is currently spawning - marking for abort`),r.aborted=!0,spawningProcesses.set(s,r),t&&(pendingInterrupts.set(s,t),console.log(`üìù Stored pending interrupt callback for session ${s}`)),void e.emit(`message:${s}`,{type:"system",subtype:"interrupted",message:"stopping task...",timestamp:Date.now()});if(o){if(console.log(`üõë Killing claude process for session ${s} (PID: ${o.pid})`),o.pid)try{process.kill(-o.pid,"SIGINT")}catch(e){o.kill("SIGINT")}else o.kill("SIGINT");activeProcesses.delete(s),activeProcessStartTimes.delete(s),n&&(n.wasInterrupted=!0,console.log(`üîÑ Session ${s} interrupted - marked wasInterrupted=true for followup`));const i=lastAssistantMessageIds.get(s);i&&(e.emit(`message:${s}`,{type:"assistant",id:i,streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(s)),e.emit(`message:${s}`,{type:"system",subtype:"interrupted",message:"task interrupted by user",timestamp:Date.now()}),t&&t({success:!0})}else console.log(`‚ö†Ô∏è No active process found for session ${s} - nothing to interrupt`),spawningProcesses.delete(s),pendingInterrupts.delete(s),e.emit(`message:${s}`,{type:"system",subtype:"interrupted",message:"task stopped",timestamp:Date.now()}),t&&t({success:!0,noProcess:!0})}),e.on("clearSession",({sessionId:s})=>{const t=sessions.get(s);if(!t)return void console.error(`Session not found: ${s}`);const o=activeProcesses.get(s);if(o){if(console.log(`üõë Killing process for cleared session ${s} (PID: ${o.pid})`),o.pid)try{process.kill(-o.pid,"SIGINT")}catch(e){o.kill("SIGINT")}else o.kill("SIGINT");activeProcesses.delete(s),activeProcessStartTimes.delete(s)}t.messages=[],t.claudeSessionId=null,t.hasGeneratedTitle=!1,t.wasInterrupted=!1,t.wasCompacted=!1,lastAssistantMessageIds.delete(s),console.log(`‚úÖ Session ${s} cleared - will start fresh Claude session on next message`),e.emit(`message:${s}`,{type:"system",subtype:"clear",message:"session cleared",timestamp:Date.now()});const n=`title:${s}`;console.log(`üè∑Ô∏è Emitting title reset for cleared session: ${n}`),e.emit(n,{title:"new session"})}),e.on("deleteSession",async(e,s)=>{const{sessionId:t}=e;sessions.delete(t),lastAssistantMessageIds.delete(t),cancelPendingStreamingFalse(t),spawningProcesses.delete(t),s({success:!0})}),e.on("disconnect",()=>{console.log("üîå Client disconnected:",e.id);for(const[s,t]of sessions.entries())if(t.socketId===e.id){streamHealthChecks.has(s)&&(clearInterval(streamHealthChecks.get(s)),streamHealthChecks.delete(s)),streamTimeouts.has(s)&&(clearTimeout(streamTimeouts.get(s)),streamTimeouts.delete(s));const e=activeProcesses.get(s);if(e){if(console.log(`üßπ Cleaning up process for session ${s} (PID: ${e.pid})`),e.pid)try{process.kill(-e.pid,"SIGINT")}catch(s){e.kill("SIGINT")}else e.kill("SIGINT");activeProcesses.delete(s),activeProcessStartTimes.delete(s)}lastAssistantMessageIds.delete(s),cancelPendingStreamingFalse(s),spawningProcesses.delete(s)}})}),cleanupOldPidFiles(),httpServer.listen(PORT,()=>{writePidFile(),console.log(`üöÄ yurucode server running on port ${PORT}`),console.log(`üìÇ Working directory: ${process.cwd()}`),console.log(`üñ•Ô∏è Platform: ${platform()}`),console.log(`üè† Home directory: ${homedir()}`),console.log(`üìÅ Claude projects: ${join(homedir(),".claude","projects")}`);const e=join(homedir(),".claude","projects");if(existsSync(e)){console.log("‚úÖ Claude projects directory exists");try{const s=readdirSync(e);console.log(`üìä Found ${s.length} project directory(s)`),s.length>0&&"win32"===platform()&&(console.log("üîç Sample project paths (first 3):"),s.slice(0,3).forEach(e=>{if(console.log(`  - ${e}`),e.match(/^[A-Z]--/)){const s=e.replace(/^([A-Z])--/,"$1:/").replace(/-/g,"/");console.log(`    ‚Üí Would convert to: ${s}`)}}))}catch(e){console.log("‚ö†Ô∏è Could not list projects:",e.message)}}else console.log("‚ö†Ô∏è Claude projects directory not found at:",e);console.log(`‚úÖ Server configured for ${"win32"===platform()?"Windows":platform()}`),console.log("üî• Warming up bash execution...");const s=spawn("echo",["warmup"],{shell:!1,stdio:"pipe"});s.on("close",()=>{console.log("‚úÖ Bash warmup complete")}),s.on("error",e=>{console.warn("‚ö†Ô∏è Bash warmup failed:",e.message)})}),httpServer.on("error",e=>{if("EADDRINUSE"===e.code){console.error(`‚ùå Port ${PORT} is already in use`),console.log("Attempting to kill existing process and retry...");const{exec:e}=require("child_process");e(`lsof -ti :${PORT} | xargs kill -9`,e=>{e?(console.error("Failed to kill existing process. Please restart the app."),process.exit(1)):(console.log("Killed existing process, retrying in 1 second..."),setTimeout(()=>{httpServer.listen(PORT)},1e3))})}else console.error("Server error:",e),process.exit(1)});