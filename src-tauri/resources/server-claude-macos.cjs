const originalConsole={log:console.log.bind(console),error:console.error.bind(console),warn:console.warn.bind(console),info:console.info.bind(console),debug:console.debug.bind(console)};console.log=function(...e){try{originalConsole.log(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.error=function(...e){try{originalConsole.error(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.warn=function(...e){try{originalConsole.warn(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.info=function(...e){try{originalConsole.info(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.debug=function(...e){try{originalConsole.debug(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}};const DEBUG="true"===process.env.YURUCODE_DEBUG;if(!DEBUG){const e=()=>{};console.log=e,console.info=e,console.debug=e}function debugLog(...e){DEBUG&&console.log(...e)}const wrapperState={sessions:new Map,stats:{apiCalls:0,totalTokens:0,compacts:0}};function getWrapperSession(e){return wrapperState.sessions.has(e)||(wrapperState.sessions.set(e,{id:e,inputTokens:0,outputTokens:0,totalTokens:0,messageCount:0,apiResponses:[],compactCount:0,wasCompacted:!1,tokensSaved:0}),console.log(`‚úÖ [WRAPPER] Created session: ${e}`)),wrapperState.sessions.get(e)}function calculateAccumulatedTokensFromMessages(e){if(!e||0===e.length)return 0;for(let s=e.length-1;s>=0;s--){const o=e[s],t=o.usage||o.message?.usage;if(t){const e=t.cache_read_input_tokens||0,s=t.cache_creation_input_tokens||0,o=t.input_tokens||0,n=t.output_tokens||0,i=e+s+o+n;return console.log(`üìä [WRAPPER] Calculated accumulated tokens from history: ${i} (cache_read=${e}, cache_creation=${s}, input=${o}, output=${n})`),i}}return 0}function initWrapperSessionWithTokens(e,s){const o=getWrapperSession(e);return s>0&&0===o.totalTokens&&(o.totalTokens=s,console.log(`üìä [WRAPPER] Initialized session ${e} with ${s} accumulated tokens from history`)),o}function processWrapperLine(e,s){if(!e||!e.trim())return e;const o=getWrapperSession(s);try{const s=JSON.parse(e);wrapperState.stats.apiCalls++,console.log(`üì° [WRAPPER] API ${s.type} #${wrapperState.stats.apiCalls}`),o.apiResponses.push({timestamp:Date.now(),type:s.type,data:{...s}}),"user"!==s.type&&"assistant"!==s.type||o.messageCount++;const t=s.usage||s.message?.usage;if(t&&"result"!==s.type){const e=t.input_tokens||0,s=t.output_tokens||0,n=t.cache_creation_input_tokens||0,i=t.cache_read_input_tokens||0,r=o.totalTokens;o.inputTokens=e,o.outputTokens=s,o.cacheCreationTokens=n,o.cacheReadTokens=i;const a=i+n+e+s;o.totalTokens=Math.max(o.totalTokens,a);const l=o.totalTokens-r;wrapperState.stats.totalTokens+=l,console.log(`üìä [WRAPPER] TOKENS +${l} ‚Üí ${o.totalTokens}/200000 (${Math.round(o.totalTokens/2e3)}%)`),(n>0||i>0)&&console.log(`   üì¶ Cache: creation=${n}, read=${i}`)}if("result"===s.type&&(!s.usage||0===s.usage.input_tokens&&0===s.usage.output_tokens)&&o.totalTokens>0){const e=o.totalTokens;console.log(`üóúÔ∏è [WRAPPER] COMPACTION DETECTED! Saved ${e} tokens`),o.compactCount++,o.wasCompacted=!0,o.tokensSaved+=e,wrapperState.stats.compacts++,o.inputTokens=0,o.outputTokens=0,o.totalTokens=0,s.result&&""!==s.result||(s.result=`Conversation compacted. Saved ${e.toLocaleString()} tokens.`),s.wrapper_compact={savedTokens:e,totalSaved:o.tokensSaved,compactCount:o.compactCount},console.log("üóúÔ∏è [WRAPPER] Compaction complete")}return s.wrapper={enabled:!0,tokens:{total:o.totalTokens,input:o.inputTokens,output:o.outputTokens},compaction:{count:o.compactCount,wasCompacted:o.wasCompacted,tokensSaved:o.tokensSaved}},JSON.stringify(s)}catch(s){return e}}console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"),console.log("üéØ WRAPPER EMBEDDED - Token tracking and compaction enabled"),console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");const{execSync:execSync,spawn:spawn}=require("child_process"),{existsSync:existsSync,mkdirSync:mkdirSync,readFileSync:readFileSync,writeFileSync:writeFileSync,unlinkSync:unlinkSync}=require("fs"),{dirname:dirname,join:join,isAbsolute:isAbsolute}=require("path"),{createServer:createServer}=require("http"),{Server:Server}=require("socket.io"),{homedir:homedir,platform:platform}=require("os");let CLAUDE_PATH="claude";const isWindows="win32"===platform();function createWslClaudeCommand(e,s,o){const t="C:\\Windows\\System32\\wsl.exe";if(!s)throw new Error("Working directory is required for WSL Claude command");const n=s;if(o){const{execFileSync:s}=require("child_process");let i=null,r="user";try{r=s(t,["-e","bash","-c","whoami"],{encoding:"utf8",windowsHide:!0}).trim(),console.log(`üîç WSL user detected: ${r}`)}catch(e){console.warn("‚ö†Ô∏è Could not detect WSL user, using default")}const a=[`/home/${r}/.claude/local/node_modules/.bin/claude`,"~/.npm-global/bin/claude","~/node_modules/.bin/claude","/usr/local/bin/claude","/usr/bin/claude","~/.local/bin/claude"];for(const o of a)try{if("exists"===s(t,["-e","bash","-c",o.startsWith("~")?`[ -f "${o.replace("~","$HOME")}" ] && echo "exists"`:`[ -f "${o}" ] && echo "exists"`],{encoding:"utf8",windowsHide:!0}).trim()){if(o.startsWith("~")){const e=s(t,["-e","bash","-c","echo $HOME"],{encoding:"utf8",windowsHide:!0}).trim();i=o.replace("~",e)}else i=o;console.log(`‚úÖ Found Claude at: ${i}`);break}}catch(e){}if(!i)try{const e=s(t,["-e","bash","-c","which claude"],{encoding:"utf8",windowsHide:!0}).trim();e&&(i=e,console.log(`‚úÖ Found Claude via 'which': ${i}`))}catch(e){}i||(i=`/home/${r}/.claude/local/node_modules/.bin/claude`,console.log(`‚ö†Ô∏è Claude not found in WSL, using default path: ${i}`),console.log("‚ö†Ô∏è Please install Claude CLI in WSL: npm install -g @anthropic-ai/claude-cli"));const l=e.map(e=>e.includes(" ")||e.includes(":")||e.includes("(")||e.includes(")")||e.includes(",")?`'${e.replace(/'/g,"'\\''")}'`:e).join(" "),c=`/tmp/yurucode-msg-${Date.now()}-${Math.random().toString(36).substr(2,9)}.txt`,d=`cd "${n}" && echo "${Buffer.from(o).toString("base64")}" | base64 -d > "${c}" && cat "${c}" | ${i} ${l} 2>&1; rm -f "${c}"`;return console.log("üîç WSL script (main message):"),console.log(`  Working dir: ${n}`),console.log(`  Claude path: ${i}`),console.log(`  Args: ${l}`),console.log(`  Message length: ${o.length} chars`),console.log(`  Using temp file: ${c}`),[t,["-e","bash","-c",d],!0]}{const{execFileSync:s}=require("child_process"),o="C:\\Windows\\System32\\wsl.exe";let t=null,n="user";try{n=s(o,["-e","bash","-c","whoami"],{encoding:"utf8",windowsHide:!0}).trim(),console.log(`üîç WSL user detected for title gen: ${n}`)}catch(e){console.warn("‚ö†Ô∏è Could not detect WSL user for title gen, using default")}const i=[`/home/${n}/.claude/local/node_modules/.bin/claude`,"~/.npm-global/bin/claude","~/node_modules/.bin/claude","/usr/local/bin/claude","/usr/bin/claude","~/.local/bin/claude"];for(const n of i)try{if("exists"===s(o,["-e","bash","-c",n.startsWith("~")?`[ -f "${n.replace("~","$HOME")}" ] && echo "exists"`:`[ -f "${n}" ] && echo "exists"`],{encoding:"utf8",windowsHide:!0}).trim()){if(n.startsWith("~")){const e=s(o,["-e","bash","-c","echo $HOME"],{encoding:"utf8",windowsHide:!0}).trim();t=n.replace("~",e)}else t=n;break}}catch(e){}if(!t)try{const e=s(o,["-e","bash","-c","which claude"],{encoding:"utf8",windowsHide:!0}).trim();e&&(t=e)}catch(e){}t||(t=`/home/${n}/.claude/local/node_modules/.bin/claude`,console.log(`‚ö†Ô∏è Claude not found for title gen, using default: ${t}`));const r=`cat | ${t} --print --output-format json --model claude-sonnet-4-5-20250929 2>&1`;return console.log("üîç WSL script (title gen)"),[o,["-e","bash","-c",r],!1]}}if(isWindows)console.log("üîç Windows detected, Claude will be invoked through WSL with comprehensive path detection..."),CLAUDE_PATH="WSL_CLAUDE";else{const e=[join(homedir(),".npm-global/bin/claude"),"/opt/homebrew/bin/claude","/usr/local/bin/claude","/usr/bin/claude",process.env.CLAUDE_PATH].filter(Boolean);for(const s of e)try{if(existsSync(s)){CLAUDE_PATH=s,console.log(`‚úÖ Found Claude CLI at: ${CLAUDE_PATH}`);break}}catch(e){}if("claude"===CLAUDE_PATH)try{const e=execSync("which claude",{encoding:"utf8"}).trim();e&&(CLAUDE_PATH=e,console.log(`‚úÖ Found Claude CLI via which: ${CLAUDE_PATH}`))}catch(e){}if("claude"===CLAUDE_PATH)try{const e=execSync("whereis claude",{encoding:"utf8"}).trim().match(/claude:\s+(.+)/);if(e&&e[1]){const s=e[1].split(/\s+/);for(const e of s)if(existsSync(e)){CLAUDE_PATH=e,console.log(`‚úÖ Found Claude CLI via whereis: ${CLAUDE_PATH}`);break}}}catch(e){console.warn("‚ö†Ô∏è Claude CLI not found via whereis. Using 'claude' and hoping for the best.")}}const express=require("express"),cors=require("cors"),net=require("net"),app=express(),httpServer=createServer(app),io=new Server(httpServer,{cors:{origin:"*",methods:["GET","POST"]},transports:["websocket","polling"],pingTimeout:6e5,pingInterval:3e4,upgradeTimeout:6e4,maxHttpBufferSize:5e8,perMessageDeflate:!1,httpCompression:!1});app.use(cors()),app.use(express.json());const PORT=(()=>{if(process.env.PORT){const e=parseInt(process.env.PORT);return console.log(`‚úÖ Using PORT from Rust: ${e}`),e}console.log("üîç Finding available port in range 60000-61000...");let e=6e4+Math.floor(1001*Math.random());for(let s=0;s<100;s++){const o=6e4+(e-6e4+s)%1001,t=net.createServer();try{return t.listen(o,"127.0.0.1"),t.close(),console.log(`‚úÖ Found available port: ${o}`),o}catch(e){}}return console.log("‚ö†Ô∏è Could not find available port, using 3001"),3001})();let sessions=new Map,activeProcesses=new Map,activeProcessStartTimes=new Map,lastAssistantMessageIds=new Map,allAssistantMessageIds=new Map,streamHealthChecks=new Map,streamTimeouts=new Map,isSpawningProcess=!1;const processSpawnQueue=[],spawningProcesses=new Map,pendingInterrupts=new Map,pendingStreamingFalseTimers=new Map,STREAMING_FALSE_DEBOUNCE_MS=600,messageBatches=new Map,BATCH_INTERVAL_MS=16;function queueMessage(e,s,o,t=!1){messageBatches.has(e)||messageBatches.set(e,{messages:[],timer:null,socket:o});const n=messageBatches.get(e);if(n.socket=o,t||"result"===s.type||"error"===s.type||"system"===s.type||!0===s.streaming_end||!1===s.streaming)return flushBatch(e),void o.emit(`message:${e}`,s);n.messages.push(s),n.timer||(n.timer=setTimeout(()=>flushBatch(e),16))}function flushBatch(e){const s=messageBatches.get(e);s&&(s.timer&&(clearTimeout(s.timer),s.timer=null),s.messages.length>0&&s.socket&&(1===s.messages.length?s.socket.emit(`message:${e}`,s.messages[0]):s.socket.emit(`messageBatch:${e}`,s.messages),s.messages=[]))}function cleanupBatch(e){const s=messageBatches.get(e);s&&(s.timer&&clearTimeout(s.timer),messageBatches.delete(e))}function cancelPendingStreamingFalse(e){const s=pendingStreamingFalseTimers.get(e);s&&(clearTimeout(s.timer),pendingStreamingFalseTimers.delete(e),console.log(`üîÑ [${e}] Cancelled pending streaming=false (new process starting)`))}async function generateTitle(e,s,o,t){try{console.log(`üè∑Ô∏è Generating title for session ${e}`),console.log(`üè∑Ô∏è Message preview: "${s}"`);const n=`user message: "${s.substring(0,200)}"\ntask: reply with ONLY 1-3 words describing what user wants. lowercase only. no punctuation. be extremely concise. examples: "echo command", "file search", "debug issue"`,i=["-p",n,"--print","--output-format","json","--model","claude-sonnet-4-5-20250929"];console.log(`üè∑Ô∏è Title prompt: "${n}"`);const r={...process.env},a="/opt/homebrew/bin";r.PATH?.includes(a)||(r.PATH=`${a}:${r.PATH||"/usr/bin:/bin"}`);const l=join(homedir(),".yurucode-title-gen");try{if(!existsSync(l)){const{mkdirSync:e}=require("fs");e(l,{recursive:!0}),console.log("üìÅ Created title generation directory:",l)}}catch(e){console.log("‚ö†Ô∏è Could not create title gen directory, using home:",e.message)}const c=isWindows&&"WSL_CLAUDE"===CLAUDE_PATH?(()=>{const{execSync:e}=require("child_process");let s="user";try{s=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){}const o=`/home/${s}/.yurucode-title-gen`;try{e(`C:\\Windows\\System32\\wsl.exe -e bash -c "mkdir -p ${o}"`,{windowsHide:!0})}catch(e){console.log("‚ö†Ô∏è Could not create WSL title gen directory:",e.message)}const[t,n,a]=createWslClaudeCommand(i,o,null);return spawn(t,n,{cwd:l,env:r,stdio:["pipe","pipe","pipe"],windowsHide:!0,detached:!1})})():spawn(CLAUDE_PATH,i,{cwd:l,env:r,stdio:["pipe","pipe","pipe"],windowsHide:!0,detached:!1});let d="",g="";c.stdout.on("data",e=>{d+=e.toString(),console.log(`üè∑Ô∏è Title generation stdout: ${e.toString()}`)}),c.stderr.on("data",e=>{g+=e.toString(),console.log(`üè∑Ô∏è Title generation stderr: ${e.toString()}`)}),c.on("close",s=>{console.log(`üè∑Ô∏è Title generation process closed with code ${s}`),console.log(`üè∑Ô∏è Full output: "${d}"`),g&&console.log(`üè∑Ô∏è Error output: "${g}"`);try{const s=d.trim().split("\n"),n=s[s.length-1];console.log(`üè∑Ô∏è Parsing last line: "${n}"`);const i=JSON.parse(n),r=i.completion||i.result;if(r){let s=r.toLowerCase().replace(/[^\w\s]/g,"").trim().substring(0,30);if(s&&s.length>2){console.log(`üè∑Ô∏è Generated title: "${s}" - emitting to client`);const n=`title:${e}`;console.log(`üè∑Ô∏è Emitting event: ${n} with data:`,{title:s}),o.emit(n,{title:s}),t&&t()}else console.log(`üè∑Ô∏è Title too short or empty: "${s}"`)}else console.log("üè∑Ô∏è No title text in response:",i)}catch(e){console.error("üè∑Ô∏è Failed to parse title response:",e),console.error("üè∑Ô∏è Raw output was:",d)}}),c.on("error",e=>{console.error("üè∑Ô∏è Failed to spawn title generation process:",e)}),c.stdin.end()}catch(e){console.error("üè∑Ô∏è Failed to generate title:",e)}}const MAX_MESSAGE_HISTORY=1e3,MAX_LINE_BUFFER_SIZE=52428800;app.get("/health",(e,s)=>{s.json({status:"ok",pid:process.pid,service:"yurucode-claude",claudeCodeLoaded:!0,port:PORT,sessions:Object.keys(sessions).length})}),app.delete("/claude-project/:projectPath",async(e,s)=>{try{const{projectPath:o}=e.params,t=join(homedir(),".claude","projects",o);if(console.log("Deleting project:",t),!existsSync(t))return s.status(404).json({error:"project not found"});const{rm:n}=await import("fs/promises");await n(t,{recursive:!0,force:!0}),console.log("Project deleted successfully"),s.json({success:!0})}catch(e){console.error("Error deleting project:",e),s.status(500).json({error:"Failed to delete project",details:e.message})}}),app.delete("/claude-session/:projectPath/:sessionId",async(e,s)=>{try{const{projectPath:o,sessionId:t}=e.params,n=join(homedir(),".claude","projects",o,`${t}.jsonl`);if(console.log("Deleting session:",n),!existsSync(n))return s.status(404).json({error:"session not found"});const{unlink:i}=await import("fs/promises");await i(n),console.log("Session deleted successfully"),s.json({success:!0})}catch(e){console.error("Error deleting session:",e),s.status(500).json({error:"Failed to delete session",details:e.message})}}),app.get("/claude-session/:projectPath/:sessionId",async(e,s)=>{try{const{projectPath:o,sessionId:t}=e.params;if(console.log("Loading session request:"),console.log("  - Raw projectPath:",o),console.log("  - SessionId:",t),console.log("  - Platform:",platform()),isWindows){let n="user";try{const{execSync:e}=require("child_process");n=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const i=`/home/${n}/.claude/projects/${o}/${t}.jsonl`;console.log("  - WSL path:",i);try{const{execSync:n}=require("child_process"),r=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'cat \\"${i}\\" 2>/dev/null'}"`,{encoding:"utf8",windowsHide:!0,maxBuffer:52428800});console.log("Raw file content:",r.replace(/\n/g,"\\n").replace(/\r/g,"\\r")),console.log("Total file size:",r.length,"characters");const a=r[r.length-1];console.log("File ends with:","\n"===a?"newline":"$"===a?"dollar":"char: "+a);const l=[];let c=0,d=0,g=0,u=0;for(;c<r.length;){for(u++;c<r.length&&/\s/.test(r[c]);)c++;if(c>=r.length)break;if("{"!==r[c]){console.log("Warning: Expected { at position",c,"but found:",r[c]);const e=r.indexOf("\n",c);if(-1===e)break;c=e+1;continue}let s=0,o=!1,t=!1,n=-1;for(let e=c;e<r.length;e++){const i=r[e];if(t)t=!1;else if("\\"!==i)if('"'!==i||t){if(!o)if("{"===i)s++;else if("}"===i&&(s--,0===s)){if(!(e+1<r.length)){n=e+1;break}{const s=r[e+1];if("$"===s||"\n"===s||"\r"===s){n=e+1;break}}}}else o=!o;else t=!0}if(-1===n){console.log("Warning: Could not find end of JSON object starting at position",c);break}const i=r.substring(c,n);try{const e=JSON.parse(i);if("user"===e.role){if(!e.content){c=n,c<r.length&&"$"===r[c]&&c++,c<r.length&&"\n"===r[c]&&c++,c<r.length&&"\r"===r[c]&&c++;continue}if(!("string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.length>0?e.content.map(e=>e.text||"").join(""):"").trim()){c=n,c<r.length&&"$"===r[c]&&c++,c<r.length&&"\n"===r[c]&&c++,c<r.length&&"\r"===r[c]&&c++;continue}}l.push(e),d++,d<=5&&("summary"===e.type?console.log(`Line ${u}: Added summary:`,e.summary||""):"user"===e.type?console.log(`Line ${u}: Added user message`):"assistant"===e.type?console.log(`Line ${u}: Added assistant message`):e.sessionId&&console.log(`Line ${u}: Added session metadata`))}catch(e){g++,g<=5&&(console.log(`Failed to parse JSON at line ${u}, position ${c}:`,e.message),console.log("JSON output:",i))}c=n,c<r.length&&"$"===r[c]&&c++,c<r.length&&"\n"===r[c]&&c++,c<r.length&&"\r"===r[c]&&c++}console.log(`Processed ${u} lines, successfully parsed ${d} JSON objects from session file`);const p=o.replace(/^([A-Z])--/,"$1:/").replace(/^-/,"/").replace(/-/g,"/");console.log(`Loaded session with ${l.length} messages`),console.log(`Converted project path: ${o} -> ${p}`);let m=null;if(l.length>0){const e=l[l.length-1];("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(m=e.title)}if(!m){const e=l.find(e=>"summary"===e.type&&e.summary);e&&(m=e.summary)}if(!m){const e=l.find(e=>"user"===e.role&&e.content);if(e){const s="string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.find(e=>"text"===e.type)?.text||"";s&&(m=s.substring(0,100))}}m||(m="Untitled session"),s.json({sessionId:t,projectPath:p,messages:l,sessionCount:l.length,title:m})}catch(e){console.error("Error reading session file from WSL:",e.message),s.status(404).json({error:"Session not found"})}}else{const n=join(homedir(),".claude","projects",o,`${t}.jsonl`);if(console.log("  - Full path:",n),!existsSync(n))return console.error("Session not found:",n),s.status(404).json({error:"session not found"});const{readFile:i}=await import("fs/promises");try{const r=await i(n,"utf8"),a=[],l=r.split(/\$|\n/).filter(e=>e.trim());for(const s of l)try{const e=JSON.parse(s);if("user"===e.role){if(!e.content)continue;if(!("string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.length>0?e.content.map(e=>e.text||"").join(""):"").trim())continue}a.push(e)}catch(e){}let c=null;if(a.length>0){const e=a[a.length-1];("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(c=e.title)}if(!c){const e=a.find(e=>"summary"===e.type&&e.summary);e&&(c=e.summary)}if(!c){const e=a.find(e=>"user"===e.role&&e.content);if(e){const s="string"==typeof e.content?e.content:Array.isArray(e.content)&&e.content.find(e=>"text"===e.type)?.text||"";s&&(c=s.substring(0,100))}}c||(c="Untitled session");const d=o.replace(/^([A-Z])--/,"$1:/").replace(/^-/,"/").replace(/-/g,"/");s.json({sessionId:t,projectPath:d,messages:a,sessionCount:a.length,title:c})}catch(e){console.error("Error reading session file:",e),s.status(500).json({error:"Failed to read session",details:e.message})}}}catch(e){console.error("Error loading session:",e),s.status(500).json({error:"Failed to load session",details:e.message})}}),app.get("/claude-analytics",async(e,s)=>{console.log("üìä Loading analytics from all Claude sessions...");try{const o={totalSessions:0,totalMessages:0,totalTokens:0,totalCost:0,byModel:{opus:{sessions:0,tokens:0,cost:0},sonnet:{sessions:0,tokens:0,cost:0}},byDate:{},byProject:{}};if(isWindows){const{readdir:s,readFile:t,stat:n}=await import("fs/promises"),i=await import("path"),r=["yuru","muuko",process.env.USER,process.env.USERNAME].filter(Boolean),a=["Ubuntu","Ubuntu-20.04","Ubuntu-22.04","Ubuntu-24.04"],l=["\\\\wsl$","\\\\wsl.localhost"];console.log("üìä Analytics: Searching for WSL Claude projects..."),console.log("  Possible users:",r),console.log("  Possible distros:",a);let c=null,d=0;for(const s of l){for(const o of a){for(const t of r){const i=`${s}\\${o}\\home\\${t}\\.claude\\projects`;d++;try{await n(i),c=i,console.log(`‚úÖ Found WSL Claude projects at: ${i} (attempt ${d})`);break}catch(e){}}if(c)break}if(c)break}if(c||console.log(`‚ùå WSL Claude projects not found after ${d} attempts`),c)try{const r=await s(c);console.log(`Found ${r.length} projects in WSL directory`);const a=10;for(const l of r.slice(0,a)){const r=i.win32.join(c,l);try{if(!(await n(r)).isDirectory())continue;console.log(`Processing WSL project: ${l}`);const a=(await s(r)).filter(e=>e.endsWith(".jsonl"));console.log(`  Found ${a.length} session files`);const c=20;for(const s of a.slice(0,c))try{const a=i.win32.join(r,s),c=await n(a);if(c.size>10485760){console.log(`  Skipping large file: ${s} (${c.size} bytes)`);continue}console.log(`  Reading session: ${s} (${c.size} bytes)`);const d=(await t(a,"utf8")).split("\n").filter(e=>e.trim());console.log(`    Total lines in file: ${d.length}`);let g=0,u=0,p="sonnet",m=(new Date).toISOString().split("T")[0],f=0;for(const s of d)try{const e=JSON.parse(s);if("assistant"===e.type&&e.message&&e.message.usage){f++;const s=e.message.usage,o=s.input_tokens||0,t=s.output_tokens||0;g+=o+t+(s.cache_creation_input_tokens||0)+(s.cache_read_input_tokens||0),e.message.model&&(p=e.message.model.includes("opus")?"opus":"sonnet");const n="opus"===p;u+=o*(n?15e-6:3e-6)+t*(n?75e-6:15e-6)}"user"===e.type&&f++,e.timestamp&&(m=new Date(e.timestamp).toISOString().split("T")[0])}catch(e){}if(console.log(`    Parsed: ${f} messages, ${g} tokens`),g>0){console.log(`    Session: ${g} tokens, $${u.toFixed(4)}`),o.totalSessions++,o.totalMessages+=2*f,o.totalTokens+=g,o.totalCost+=u;const e="opus"===p?"opus":"sonnet";o.byModel[e].sessions++,o.byModel[e].tokens+=g,o.byModel[e].cost+=u,o.byDate[m]||(o.byDate[m]={sessions:0,messages:0,tokens:0,cost:0}),o.byDate[m].sessions++,o.byDate[m].messages+=2*f,o.byDate[m].tokens+=g,o.byDate[m].cost+=u;const s=l.replace(/-/g,"/");o.byProject[s]||(o.byProject[s]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:c.mtime.getTime()}),o.byProject[s].sessions++,o.byProject[s].messages+=2*f,o.byProject[s].tokens+=g,o.byProject[s].cost+=u}}catch(e){console.error(`  Error processing session ${s}:`,e.message)}}catch(e){console.error(`Error processing project ${l}:`,e.message)}}}catch(e){console.error("Error reading WSL projects directory:",e.message),c=null}if(!c){console.log("WSL mount not accessible, trying Windows path...");const r=i.win32.join(homedir(),".claude","projects");try{const a=await s(r);console.log(`Found ${a.length} projects in Windows directory`);for(const l of a.slice(0,5)){const a=i.win32.join(r,l);if(!(await n(a)).isDirectory())continue;console.log(`Processing Windows project: ${l}`);const c=(await s(a)).filter(e=>e.endsWith(".jsonl"));console.log(`  Found ${c.length} session files`);for(const s of c.slice(0,10))try{const r=i.win32.join(a,s),c=await n(r);if(c.size>10485760){console.log(`  Skipping large file: ${s} (${c.size} bytes)`);continue}console.log(`  Reading session: ${s} (${c.size} bytes)`);const d=(await t(r,"utf8")).split("\n").filter(e=>e.trim());console.log(`    Total lines in file: ${d.length}`);let g=0,u=0,p="sonnet",m=(new Date).toISOString().split("T")[0],f=0;for(const s of d)try{const e=JSON.parse(s);if("assistant"===e.type&&e.message&&e.message.usage){f++;const s=e.message.usage,o=s.input_tokens||0,t=s.output_tokens||0;g+=o+t+(s.cache_creation_input_tokens||0)+(s.cache_read_input_tokens||0),e.message.model&&(p=e.message.model.includes("opus")?"opus":"sonnet");const n="opus"===p;u+=o*(n?15e-6:3e-6)+t*(n?75e-6:15e-6)}"user"===e.type&&f++,e.timestamp&&(m=new Date(e.timestamp).toISOString().split("T")[0])}catch(e){}if(console.log(`    Parsed: ${f} messages, ${g} tokens`),g>0){console.log(`    Session: ${g} tokens, $${u.toFixed(4)}`),o.totalSessions++,o.totalMessages+=2*f,o.totalTokens+=g,o.totalCost+=u;const e="opus"===p?"opus":"sonnet";o.byModel[e].sessions++,o.byModel[e].tokens+=g,o.byModel[e].cost+=u,o.byDate[m]||(o.byDate[m]={sessions:0,messages:0,tokens:0,cost:0}),o.byDate[m].sessions++,o.byDate[m].messages+=2*f,o.byDate[m].tokens+=g,o.byDate[m].cost+=u;const s=l.replace(/-/g,"/");o.byProject[s]||(o.byProject[s]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:c.mtime.getTime()}),o.byProject[s].sessions++,o.byProject[s].messages+=2*f,o.byProject[s].tokens+=g,o.byProject[s].cost+=u}}catch(e){console.error(`  Error processing session ${s}:`,e.message)}}}catch(e){console.error("Error reading Windows projects:",e.message)}}}else{const{readdir:s,readFile:t,stat:n}=await import("fs/promises"),i=join(homedir(),".claude","projects");try{const r=await s(i);for(const a of r){const r=join(i,a);if(!(await n(r)).isDirectory())continue;const l=(await s(r)).filter(e=>e.endsWith(".jsonl"));for(const s of l)try{const n=join(r,s),i=(await t(n,"utf8")).split("\n").filter(e=>e.trim());let l=0,c=0,d="sonnet",g=(new Date).toISOString().split("T")[0],u=0;for(const s of i)try{const e=JSON.parse(s);if("assistant"===e.type&&e.message&&e.message.usage){u++;const s=e.message.usage,o=s.input_tokens||0,t=s.output_tokens||0;l+=o+t+(s.cache_creation_input_tokens||0)+(s.cache_read_input_tokens||0),e.message.model&&(d=e.message.model.includes("opus")?"opus":"sonnet");const n="opus"===d;c+=o*(n?15e-6:3e-6)+t*(n?75e-6:15e-6)}"user"===e.type&&u++,e.timestamp&&(g=new Date(e.timestamp).toISOString().split("T")[0])}catch(e){}(l>0||u>0)&&(o.totalSessions++,o.totalMessages+=u,o.totalTokens+=l,o.totalCost+=c,"opus"===d?(o.byModel.opus.sessions++,o.byModel.opus.tokens+=l,o.byModel.opus.cost+=c):(o.byModel.sonnet.sessions++,o.byModel.sonnet.tokens+=l,o.byModel.sonnet.cost+=c),o.byDate[g]||(o.byDate[g]={sessions:0,messages:0,tokens:0,cost:0}),o.byDate[g].sessions++,o.byDate[g].messages+=2*i.length,o.byDate[g].tokens+=l,o.byDate[g].cost+=c,o.byProject[a]||(o.byProject[a]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:Date.now()}),o.byProject[a].sessions++,o.byProject[a].messages+=u,o.byProject[a].tokens+=l,o.byProject[a].cost+=c)}catch(e){console.error(`Error processing session ${s}:`,e.message)}}}catch(e){console.error("Error reading projects directory:",e)}}console.log(`üìä Analytics loaded: ${o.totalSessions} sessions, ${o.totalTokens} tokens`),s.json(o)}catch(e){console.error("Error loading analytics:",e),s.status(500).json({error:"Failed to load analytics",details:e.message})}}),app.get("/claude-projects-quick",async(e,s)=>{try{const o=parseInt(e.query.limit)||20,t=parseInt(e.query.offset)||0;if(isWindows){console.log("üîç Windows detected - loading projects from WSL");let n="user";try{const{execSync:e}=require("child_process");n=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const i=`/home/${n}/.claude/projects`;try{const{execFileSync:n}=require("child_process"),r="C:\\Windows\\System32\\wsl.exe",a=`cd "${i}" && for d in *; do [ -d "$d" ] && echo "$d"; done`;console.log("üìÇ Getting projects from WSL:",i);const l=n(r,["-e","bash","-c",a],{encoding:"utf8",windowsHide:!0}).trim();if(!l)return console.log("‚ùå No projects found in WSL"),s.json({projects:[],count:0});const c=l.split("\n").filter(e=>e.trim()).filter(e=>{const s=e.toLowerCase();return!(s.includes("temp")||s.includes("tmp")||s.includes("yurucode-server")||s.includes("yurucode-title-gen")||"-yurucode-title-gen"===s||s.includes("appdata")||s.includes("-mnt-c-users-")&&s.includes("-appdata-local-temp"))||(console.log(`üö´ Filtering out temp/server/title-gen directory: ${e}`),!1)}),d=[];for(const s of c){let o=0;try{const e=n(r,["-e","bash","-c",`cd ${i}/${s} && ls -t *.jsonl 2>/dev/null | head -1 | xargs -r stat -c %Y 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim();e&&!isNaN(e)&&(o=1e3*parseInt(e))}catch(e){o=0}let t=0;try{const e=n(r,["-e","bash","-c",`ls -1 ${i}/"${s}"/*.jsonl 2>/dev/null | wc -l`],{encoding:"utf8",windowsHide:!0}).trim();t=parseInt(e)||0}catch(e){}0===t&&0===o||d.push({name:s,path:s,lastModified:o,sessionCount:t,sessions:[]})}d.sort((e,s)=>s.lastModified-e.lastModified),console.log(`‚úÖ Found ${d.length} projects in WSL`);const g=d.length,u=d.slice(t,t+o);return console.log(`üìÑ Returning ${u.length} projects (offset: ${t}, limit: ${o}, total: ${g})`),void s.json({projects:u,count:g})}catch(e){return console.error("‚ùå ERROR loading Windows projects:",e.message),console.error("Stack:",e.stack),s.json({projects:[],count:0})}}const n=join(homedir(),".claude","projects");if(console.log("Quick loading project list from:",n),!existsSync(n))return console.log("Claude projects directory not found:",n),s.json({projects:[],count:0});const{readdir:i,stat:r}=await import("fs/promises"),a=(await i(n)).filter(e=>!e.startsWith(".")).map(async e=>{try{const s=join(n,e),o=await r(s);if(!o.isDirectory())return null;const t=(await i(s)).filter(e=>e.endsWith(".jsonl")).length;return{path:e,name:e,sessionCount:isWindows&&0===t?null:t,lastModified:o.mtime.getTime()}}catch{return null}}),l=(await Promise.all(a)).filter(Boolean);l.sort((e,s)=>s.lastModified-e.lastModified);const c=l.length,d=l.slice(t,t+o);console.log(`Quick loaded ${d.length} of ${c} project names (offset: ${t}, limit: ${o})`),s.json({projects:d,count:c})}catch(e){console.error("Error quick loading projects:",e),s.status(500).json({error:"Failed to load projects",details:e.message})}}),app.get("/claude-project-sessions/:projectName",async(e,s)=>{try{const o=decodeURIComponent(e.params.projectName);if(console.log("üìÇ Loading sessions for project:",o),s.writeHead(200,{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"}),isWindows){let t="user";try{const{execSync:e}=require("child_process");t=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const n=`/home/${t}/.claude/projects/${o}`;try{console.log("üöÄ Getting session list from WSL:",n);const{execFileSync:o}=require("child_process"),t=o("C:\\Windows\\System32\\wsl.exe",["-e","bash","-c",`cd "${n}" 2>/dev/null && for f in *.jsonl; do [ -f "$f" ] && stat -c "%Y:%n" -- "$f"; done | sort -rn | head -50`],{encoding:"utf8",windowsHide:!0}).trim();if(!t)return console.log("No sessions found"),s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();const i=t.split("\n").filter(e=>e.trim()).map(e=>{const[s,o]=e.split(":");return{filename:o,timestamp:1e3*parseInt(s)}}).sort((e,s)=>s.timestamp-e.timestamp).slice(0,10);if(0===i.length)return console.log("No sessions found"),s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();for(let t=0;t<i.length;t++){const{filename:r,timestamp:a}=i[t];try{if(t>=50)break;const l="C:\\Windows\\System32\\wsl.exe",c=o(l,["-e","bash","-c",`head -n1 "${n}/${r}" 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim(),d=o(l,["-e","bash","-c",`tail -n1 "${n}/${r}" 2>/dev/null`],{encoding:"utf8",windowsHide:!0}).trim(),g=o(l,["-e","bash","-c",`head -n50 "${n}/${r}" 2>/dev/null | wc -l`],{encoding:"utf8",windowsHide:!0}).trim(),u=r.replace(".jsonl","");let p="Untitled session",m=null;try{const e=JSON.parse(d);("title"===e.type&&e.title||"metadata"===e.type&&e.title||e.title&&!e.role)&&(m=e.title)}catch(e){}if(!m)try{const e=JSON.parse(c);if(e.summary&&(p=e.summary,m||(m=e.summary)),e.title&&(m=e.title),!m&&"user"===e.role&&e.content)if("string"==typeof e.content)p=e.content.substring(0,100),m=p;else if(Array.isArray(e.content)){const s=e.content.find(e=>"text"===e.type);s&&s.text&&(p=s.text.substring(0,100),m=p)}"summary"===e.type&&e.summary&&(m=e.summary,p=e.summary)}catch(e){console.log(`Could not parse session title from: ${c}`)}const f={id:u,summary:p,title:m,timestamp:a,path:r,messageCount:parseInt(g)||0};s.write(`data: ${JSON.stringify({session:f,index:t,total:i.length})}\n\n`),console.log(`  üìÑ Sent session ${t+1}/${i.length}: ${u}`)}catch(e){console.log(`Error processing ${r}:`,e.message)}}s.write('data: {"done": true}\n\n'),console.log("‚úÖ Streamed all sessions"),s.end()}catch(e){console.error("Error loading sessions:",e.message),s.write('data: {"error": true, "message": "'+e.message+'"}\n\n'),s.end()}}else s.json({sessions:[]})}catch(e){console.error("Error loading project sessions:",e),s.status(500).json({error:"Failed to load sessions"})}}),app.get("/claude-project-date/:projectName",async(e,s)=>{try{const o=decodeURIComponent(e.params.projectName);if(console.log(`üìÖ Getting date for project: ${o}`),isWindows){let t="yuru";try{const{execSync:e}=require("child_process");t=e('powershell.exe -NoProfile -Command "& {wsl.exe whoami}"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){}const n=`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'cd /home/${t}/.claude/projects/${o} && ls -t *.jsonl 2>/dev/null | head -1 | xargs -r stat -c %Y 2>/dev/null'}"`,{execSync:i}=require("child_process"),r=i(n,{encoding:"utf8",windowsHide:!0}).trim();let a=Date.now();if(r&&!isNaN(r)){a=1e3*parseInt(r);const e=new Date(a);console.log(`  ‚úÖ ${o}: ${e.toLocaleString()} (${r})`)}else console.log(`  ‚ö†Ô∏è ${o}: No sessions found, using current time`);s.json({projectName:o,lastModified:a})}else s.json({projectName:o,lastModified:Date.now()})}catch(o){console.error("Error getting project date:",o),s.json({projectName:e.params.projectName,lastModified:Date.now()})}}),app.get("/claude-project-session-count/:projectName",async(e,s)=>{try{const o=decodeURIComponent(e.params.projectName);if(isWindows){let t="user";try{const{execSync:e}=require("child_process");t=e('C:\\Windows\\System32\\wsl.exe -e bash -c "whoami"',{encoding:"utf8",windowsHide:!0}).trim()}catch(e){console.warn("Could not detect WSL user, using default")}const n=`/home/${t}/.claude/projects/${o}`;try{const{execSync:e}=require("child_process"),t=e(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'ls -1 ${n}/*.jsonl 2>/dev/null | wc -l'}"`,{encoding:"utf8",windowsHide:!0}).trim(),i=parseInt(t)||0;s.json({projectName:o,sessionCount:i})}catch(e){s.json({projectName:o,sessionCount:0})}}else s.json({projectName:o,sessionCount:0})}catch(e){s.status(500).json({error:"Failed to get session count"})}}),app.get("/claude-projects",async(e,s)=>{try{if(isWindows){console.log("üö® WINDOWS DETECTED - LOADING FROM WSL ONLY!");try{let o="yuru";try{const{execSync:e}=require("child_process");console.log("üîç Detecting WSL user via PowerShell...");const s='powershell.exe -NoProfile -Command "& {wsl.exe whoami}"';console.log("üíª PowerShell command:",s),o=e(s,{encoding:"utf8",windowsHide:!0}).trim(),console.log("‚úÖ WSL user found:",o)}catch(s){console.log("‚ö†Ô∏è Could not detect WSL user, using default:",o),console.log("  Error:",s.message)}const t=`/home/${o}/.claude/projects`;console.log("üìÇ WSL projects directory:",t),console.log("üîç WSL user detected:",o);const{execSync:n}=require("child_process");console.log("üîß Executing WSL command via PowerShell to list projects...");const i=`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'if [ -d ${t} ]; then ls -1 ${t}; else echo NO_PROJECTS_DIR; fi'}"`;console.log("üíª PowerShell command:",i);const r=n(i,{encoding:"utf8",windowsHide:!0}).trim();if(console.log("üìù Raw PowerShell/WSL output:",JSON.stringify(r)),!r||"NO_PROJECTS_DIR"===r||"ECHO is on."===r||r.includes("system cannot find"))return console.log("‚ùå No projects found or WSL error"),s.json({projects:[]});const a=r.split("\n").filter(e=>e&&!e.startsWith(".")&&"NO_DIR"!==e).filter(e=>{const s=e.toLowerCase();return!(s.includes("temp")||s.includes("tmp")||s.includes("yurucode-server")||s.includes("yurucode-title-gen")||"-yurucode-title-gen"===s||s.includes("appdata")||s.includes("-mnt-c-users-")&&s.includes("-appdata-local-temp"))||(console.log(`üö´ Filtering out temp/server/title-gen directory: ${e}`),!1)});console.log(`‚úÖ Found ${a.length} projects in WSL (after filtering):`,a);const l=[];for(const o of a){const i=`${t}/${o}`,r=[];try{const s=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'find ${i} -name *.jsonl -type f -exec basename {} .jsonl \\\\; 2>/dev/null'}"`,{encoding:"utf8",windowsHide:!0,shell:!0}).trim();if(s){const o=s.split("\n").filter(e=>e);for(const s of o.slice(0,5)){const o=`${i}/${s}.jsonl`;let t="untitled session",a=0,l=Date.now();try{const s=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'wc -l < ${o}'}"`,{encoding:"utf8",windowsHide:!0}).trim();a=parseInt(s)||0;const i=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'head -n1 ${o}'}"`,{encoding:"utf8",windowsHide:!0}).trim();if(i)try{const e=JSON.parse(i);e.summary?t=e.summary:"user"===e.role&&e.content&&(t=e.content.slice(0,100),e.content.length>100&&(t+="..."))}catch(e){}const r=n(`powershell.exe -NoProfile -Command "& {wsl.exe -e bash -c 'stat -c %Y ${o}'}"`,{encoding:"utf8",windowsHide:!0}).trim();l=1e3*parseInt(r)||Date.now()}catch(e){}r.push({id:s,summary:t,timestamp:l,createdAt:l,path:o,messageCount:a})}}}catch(s){console.log(`Error loading sessions for ${o}:`,s.message)}r.length>0&&(r.sort((e,s)=>s.timestamp-e.timestamp),l.push({path:o,name:o,sessions:r,lastModified:r[0].timestamp,createdAt:Math.min(...r.map(e=>e.timestamp)),sessionCount:r.length,totalMessages:r.reduce((e,s)=>e+s.messageCount,0)}))}return l.sort((e,s)=>s.lastModified-e.lastModified),console.log(`‚úÖ Returning ${l.length} projects from WSL`),console.log("üìä Full projects data:",JSON.stringify(l,null,2).slice(0,500)),s.json({projects:l})}catch(e){return console.error("‚ùå ERROR loading WSL projects:",e.message),console.error("Stack:",e.stack),s.json({projects:[],count:0})}}const o=join(homedir(),".claude","projects");if(console.log("Loading projects from:",o),console.log("Platform:",platform()),!existsSync(o))return console.log("Claude projects directory not found:",o),s.json({projects:[]});const{readdir:t,stat:n,readFile:i}=await import("fs/promises"),r=await t(o);console.log(`Found ${r.length} project directories`);const a=r.filter(e=>!e.startsWith(".")).map(async e=>{try{const s=join(o,e),r=await n(s);if(!r.isDirectory())return null;const a=(await t(s)).filter(e=>e.endsWith(".jsonl")).map(async e=>{try{const o=join(s,e),t=await n(o),r=e.replace(".jsonl","");let a="untitled session",l=0,c="";try{const e=(await i(o,"utf8")).split(/\r?\n/).filter(e=>e.trim());l=e.length;for(let s=0;s<Math.min(5,e.length);s++)try{const o=JSON.parse(e[s]);if(o.summary){a=o.summary;break}"user"===o.role&&o.content&&!c&&(c=o.content.slice(0,100))}catch{}"untitled session"===a&&c&&(a=c+(c.length>=100?"...":""))}catch(e){console.error("Error reading session file:",o,e)}return{id:r,summary:a,timestamp:t.mtime.getTime(),createdAt:t.birthtime?.getTime()||t.ctime?.getTime()||t.mtime.getTime(),path:o,messageCount:l}}catch(s){return console.error("Error processing session:",e,s),null}}),l=(await Promise.all(a)).filter(Boolean);if(0===l.length)return null;l.sort((e,s)=>s.timestamp-e.timestamp);const c=Math.min(...l.map(e=>e.createdAt||e.timestamp));return{path:e,name:e,sessions:l,lastModified:l[0]?.timestamp||r.mtime.getTime(),createdAt:c,sessionCount:l.length,totalMessages:l.reduce((e,s)=>e+(s.messageCount||0),0)}}catch(s){return console.error("Error processing project:",e,s),null}}),l=(await Promise.all(a)).filter(Boolean);l.sort((e,s)=>s.lastModified-e.lastModified),console.log(`Returning ${l.length} projects`),s.json({projects:l})}catch(e){console.error("Error loading projects:",e),s.status(500).json({error:"Failed to load projects",details:e.message})}});const pidFilePath=process.env.ELECTRON_RUN_AS_NODE?join(homedir(),`.yurucode-server-${PORT}.pid`):join(__dirname,`server-${PORT}.pid`);function writePidFile(){try{writeFileSync(pidFilePath,process.pid.toString()),console.log(`üìù Server PID ${process.pid} written to ${pidFilePath}`)}catch(e){console.log("‚ö†Ô∏è Could not write PID file (running from read-only location?):",e.message)}try{const e=join(homedir(),".yurucode");existsSync(e)||mkdirSync(e,{recursive:!0});const s=join(e,"current-port.txt");writeFileSync(s,String(PORT)),console.log(`üìù Server PORT ${PORT} written to ${s}`)}catch(e){console.log("‚ö†Ô∏è Could not write port file:",e.message)}}function removePidFile(){try{fs.existsSync(pidFilePath)&&(fs.unlinkSync(pidFilePath),console.log("üóëÔ∏è Removed PID file"))}catch(e){}}function cleanupOldPidFiles(){try{const e=/^(\.yurucode-)?server-\d+\.pid$/,s=homedir();fs.existsSync(s)&&fs.readdirSync(s).forEach(o=>{if(e.test(o)){const e=join(s,o);if(e!==pidFilePath)try{fs.unlinkSync(e),console.log(`üóëÔ∏è Cleaned up old PID file: ${o}`)}catch(e){}}});const o=__dirname;fs.existsSync(o)&&fs.readdirSync(o).forEach(s=>{if(e.test(s)){const e=join(o,s);if(e!==pidFilePath)try{fs.unlinkSync(e),console.log(`üóëÔ∏è Cleaned up old PID file: ${s}`)}catch(e){}}});const t=process.env.TEMP||process.env.TMP||"/tmp",n=join(t,"yurucode-server");fs.existsSync(n)&&fs.readdirSync(n).forEach(s=>{if(e.test(s)){const e=join(n,s);if(e!==pidFilePath)try{fs.unlinkSync(e),console.log(`üóëÔ∏è Cleaned up old PID file in temp: ${s}`)}catch(e){}}}),console.log("‚úÖ PID file cleanup complete")}catch(e){console.log("‚ö†Ô∏è PID file cleanup error:",e.message)}}process.on("SIGINT",()=>{console.log("\nüõë Server shutting down..."),removePidFile(),process.exit(0)}),process.on("SIGTERM",()=>{console.log("\nüõë Server terminated"),removePidFile(),process.exit(0)}),process.on("exit",()=>{removePidFile()}),process.on("uncaughtException",e=>{console.error("üí• Uncaught exception:",e),removePidFile(),process.exit(1)}),process.on("unhandledRejection",(e,s)=>{console.error("üí• Unhandled rejection at:",s,"reason:",e),removePidFile(),process.exit(1)}),io.on("connection",e=>{function s(){if(processSpawnQueue.length>0){const e=processSpawnQueue.shift();console.log(`üîÑ Processing next spawn request. Remaining in queue: ${processSpawnQueue.length}`),e()}}console.log("üîå Client connected:",e.id),e.on("createSession",async(s,o)=>{try{let t,n=null,i=[],r=null;if(s.existingSessionId&&s.messages){t=s.existingSessionId,r=sessions.get(t),r?.wasCompacted?(n=null,console.log(`üìÇ Loading compacted session: ${t} - ignoring old Claude ID`)):(n=s.claudeSessionId||null,console.log(`üìÇ Loading existing session: ${t} with Claude ID: ${n}`)),i=s.messages||[],console.log(`üìù Loaded ${i.length} existing messages`);const e=calculateAccumulatedTokensFromMessages(i);e>0&&initWrapperSessionWithTokens(t,e)}else t=`session-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,console.log(`‚ú® Creating new session: ${t}`);let a=s.workingDirectory;if(a){const e=a.toLowerCase();(e.includes("\\temp\\")||e.includes("/temp/")||e.includes("\\tmp\\")||e.includes("/tmp/")||e.includes("appdata\\local\\temp")||e.includes("yurucode-server"))&&(console.log(`üö´ Rejecting temp directory as working directory: ${a}`),a=null)}a||(a=homedir(),console.log(`üìÇ Using home directory as fallback: ${a}`));const l={id:t,name:s.name||"new session",socketId:e.id,workingDirectory:a,messages:i,createdAt:Date.now(),claudeSessionId:n,hasGeneratedTitle:i.length>0,wasInterrupted:!1,wasCompacted:r?.wasCompacted||!1};sessions.set(t,l),console.log(`‚úÖ Session ready: ${t}`),console.log(`üìÅ Working directory: ${a}`),o&&o({success:!0,sessionId:t,workingDirectory:a})}catch(e){console.error("‚ùå Error creating session:",e),o&&o({success:!1,error:e.message})}}),e.on("sendMessage",async(o,t)=>{console.log("üö®üö®üö® RUNNING FROM: server-claude-macos.cjs FILE"),console.log("Data received:",{...o,content:o.content?"(content present)":"(no content)"});const{sessionId:n,content:i,model:r,autoGenerateTitle:a}=o,l=sessions.get(n);if(!l)return console.error(`‚ùå Session not found: ${n}`),void(t&&t({success:!1,error:"Session not found"}));if(i&&i.startsWith("$")){console.log(`üêö Executing bash command: ${i}`);const s=i.substring(1).trim(),{exec:o}=require("child_process"),{promisify:r}=require("util"),a=r(o);try{e.emit(`message:${n}`,{type:"user",message:{content:i},timestamp:Date.now()});const o=l.workingDirectory||require("os").homedir();let r;if(console.log(`üêö Executing in directory: ${o}`),"win32"===process.platform){const e="C:\\Windows\\System32\\wsl.exe",t=`cd "${o}" && ${s}`;console.log(`üêö Using WSL to execute: ${t}`),r=await a(`"${e}" -e bash -c "${t.replace(/"/g,'\\"')}"`,{timeout:3e4,maxBuffer:10485760})}else r=await a(s,{cwd:o,timeout:3e4,maxBuffer:10485760});const{stdout:c,stderr:d}=r,g=c||d||"(no output)";e.emit(`message:${n}`,{type:"assistant",message:{content:[{type:"text",text:`\`\`\`\n${g}\n\`\`\``}]},streaming:!1,timestamp:Date.now()}),t&&t({success:!0})}catch(s){console.error("‚ùå Bash command failed:",s);let o="";s.stdout&&(o+=s.stdout),s.stderr&&(o&&(o+="\n"),o+=s.stderr),o||(o=s.message);const i=`‚ùå Command failed with exit code ${s.code||"unknown"}\n\n${o}`;e.emit(`message:${n}`,{type:"assistant",message:{content:[{type:"text",text:`\`\`\`ansi\n${i}\n\`\`\``}]},streaming:!1,timestamp:Date.now()}),t&&t({success:!0})}return}console.log(`[${n}] Using model: ${r} (type: ${typeof r})`);const c=async()=>{try{if(console.log("\nüì® Processing message request:",{sessionId:n,messageLength:i?.length||0,model:r,queueLength:processSpawnQueue.length}),spawningProcesses.has(n)){const o=spawningProcesses.get(n),t=Date.now()-o.startTime;return console.log(`‚è≥ [${n}] Process is currently spawning (${t}ms ago) - queueing message`),e.emit(`message:${n}`,{type:"system",subtype:"info",message:"processing previous message, will send yours next...",timestamp:Date.now()}),void setTimeout(()=>{processSpawnQueue.push(c),s()},1500)}if(activeProcesses.has(n)){const o=activeProcesses.get(n),t=activeProcessStartTimes.get(n)||Date.now(),i=Date.now()-t;if(i<3e3)return console.log(`‚è≥ Process for session ${n} is only ${i}ms old, queueing message instead of killing`),e.emit(`message:${n}`,{type:"system",subtype:"info",message:"processing previous message, will send yours next...",timestamp:Date.now()}),void setTimeout(()=>{processSpawnQueue.push(c),s()},2e3);if(console.log(`‚ö†Ô∏è Killing existing process for session ${n} (PID: ${o.pid}, age: ${i}ms)`),"win32"!==process.platform&&o.pid)try{process.kill(-o.pid,"SIGINT")}catch(e){o.kill("SIGINT")}else o.kill("SIGINT");activeProcesses.delete(n),activeProcessStartTimes.delete(n),l.wasInterrupted=!0,console.log(`üîÑ Marked session ${n} as interrupted (keeping claudeSessionId: ${l.claudeSessionId} for resume)`),await new Promise(e=>setTimeout(e,500)),console.log(`üîÑ Emitting streaming=true after interruption for session ${n}`),e.emit(`message:${n}`,{type:"system",subtype:"streaming_resumed",streaming:!0,timestamp:Date.now()})}let o=l.workingDirectory;if(o){const e=o.toLowerCase();(e.includes("\\temp\\")||e.includes("/temp/")||e.includes("\\tmp\\")||e.includes("/tmp/")||e.includes("appdata\\local\\temp")||e.includes("yurucode-server"))&&(console.log(`üö´ Session has temp directory, using home instead: ${o}`),o=null)}o?console.log(`üìÇ Using working directory: ${o}`):(o=homedir(),console.log(`üìÇ Using home directory as fallback: ${o}`));const d=["--print","--output-format","stream-json","--verbose","--dangerously-skip-permissions","--disallowed-tools","AskUserQuestion,EnterPlanMode,ExitPlanMode","--append-system-prompt","CRITICAL: you are in yurucode ui. ALWAYS: use all lowercase (no capitals ever), be extremely concise, never use formal language, no greetings/pleasantries, straight to the point, code/variables keep proper case, one line answers preferred. !!FOR COMPLEX TASKS: YOU MUST PLAN FIRST use THINK and TODO as MUCH AS POSSIBLE to break down everything, including planning into multiple steps and do edits in small chunks!!"];i&&"/compact"===i.trim()?(d.push("--model","claude-sonnet-4-5-20250929"),console.log("ü§ñ Using model: claude-sonnet-4-5-20250929 (forced for /compact)")):r&&(d.push("--model",r),console.log(`ü§ñ Using model: ${r}`));let g=!1;g=l.claudeSessionId,g?(d.push("--resume",l.claudeSessionId),console.log("üîÑ Using --resume flag with session:",l.claudeSessionId),l.wasInterrupted&&(console.log("üìù Resuming after interrupt"),l.wasInterrupted=!1)):console.log("üìù Starting fresh conversation (no previous session)"),console.log("üöÄ Spawning claude with args:",d),console.log(`üîç Active processes count: ${activeProcesses.size}`);const u={...process.env},p="/opt/homebrew/bin";u.PATH?.includes(p)||(u.PATH=`${p}:${u.PATH||"/usr/bin:/bin"}`,console.log(`üîß Added ${p} to PATH for Claude CLI`)),u.CLAUDE_SESSION_ID=n,u.CLAUDE_INSTANCE=`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,u.PWD=o,u.HOME=homedir(),console.log(`üîß Set PWD=${o} and HOME=${homedir()} in environment`),isSpawningProcess&&(console.log("‚è≥ Waiting for previous Claude process to initialize..."),await new Promise(e=>setTimeout(e,200))),isSpawningProcess=!0,spawningProcesses.set(n,{startTime:Date.now(),aborted:!1}),console.log(`üîÑ Session ${n} marked as spawning`),existsSync(o)||(console.warn(`‚ö†Ô∏è Working directory does not exist: ${o}, using home directory`),o=homedir());const m={cwd:o,env:u,shell:!1,windowsHide:!0,detached:!1,stdio:["pipe","pipe","pipe"]};let f;if(console.log("üöÄ Spawning claude process with options:",{cwd:m.cwd,claudePath:CLAUDE_PATH,args:d}),isWindows&&"WSL_CLAUDE"===CLAUDE_PATH){let e=o;o&&o.match(/^[A-Z]:\\/)&&(e=`/mnt/${o[0].toLowerCase()}${o.substring(2).replace(/\\/g,"/")}`,console.log(`üìÇ Converted Windows path to WSL: ${o} -> ${e}`));let s=i;if(l.pendingContextRestore&&l.messages&&l.messages.length>0){console.log("üîÑ Building context for WSL command");let e="Here's our previous conversation context:\\n\\n";const o=l.messages.slice(-10);for(const s of o)if("user"===s.type){const o=s.message?.content||"";let t="";"string"==typeof o?t=o:Array.isArray(o)&&(t=o.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`User: ${t.substring(0,200)}${t.length>200?"...":""}\\n\\n`}else if("assistant"===s.type){const o=s.message?.content||"";let t="";"string"==typeof o?t=o:Array.isArray(o)&&(t=o.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`Assistant: ${t.substring(0,200)}${t.length>200?"...":""}\\n\\n`}e+=`---\\nNow, continuing our conversation: ${i}`,s=e,l.pendingContextRestore=!1}const[t,n,r]=createWslClaudeCommand(d,e,s);if(console.log(`üöÄ Running WSL command: ${t}`),console.log("üöÄ WSL args (first 500 chars):",JSON.stringify(n).substring(0,500)),console.log(`üöÄ Input handled in script: ${r}`),!existsSync(t))throw console.error(`‚ùå WSL.exe not found at: ${t}`),console.error("‚ùå Please ensure WSL is installed on Windows"),new Error("WSL.exe not found. Please install Windows Subsystem for Linux.");f=spawn(t,n,m),f.inputHandled=r}else f=spawn(CLAUDE_PATH,d,m);setTimeout(()=>{isSpawningProcess=!1},500),activeProcesses.set(n,f),activeProcessStartTimes.set(n,Date.now()),cancelPendingStreamingFalse(n);const h=spawningProcesses.get(n);if(spawningProcesses.delete(n),console.log(`‚úÖ Session ${n} spawn complete, process registered (PID: ${f.pid})`),h?.aborted||pendingInterrupts.has(n)){console.log(`üõë Session ${n} was interrupted during spawn - killing immediately`);const s=pendingInterrupts.get(n);if(pendingInterrupts.delete(n),f.pid)try{process.kill(-f.pid,"SIGINT")}catch(e){f.kill("SIGINT")}return activeProcesses.delete(n),activeProcessStartTimes.delete(n),s&&s({success:!0,killedDuringSpawn:!0}),void e.emit(`message:${n}`,{type:"system",subtype:"interrupted",message:"task interrupted by user",timestamp:Date.now()})}if("win32"!==process.platform&&f.unref(),l.pendingContextRestore&&l.messages&&l.messages.length>0){console.log(`üîÑ Restoring context with ${l.messages.length} previous messages`);let e="Here's our previous conversation context:\n\n";const s=l.messages.slice(-10);for(const o of s)if("user"===o.type){const s=o.message?.content||"";let t="";"string"==typeof s?t=s:Array.isArray(s)&&(t=s.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`User: ${t.substring(0,200)}${t.length>200?"...":""}\n\n`}else if("assistant"===o.type){const s=o.message?.content||"";let t="";"string"==typeof s?t=s:Array.isArray(s)&&(t=s.filter(e=>"text"===e.type).map(e=>e.text).join("")),e+=`Assistant: ${t.substring(0,200)}${t.length>200?"...":""}\n\n`}e+=`---\nNow, continuing our conversation: ${i}`;const o=e+"\n";if(console.log(`üìù Sending context + message to claude (${o.length} chars)`),!f.inputHandled){const e=setTimeout(()=>{console.error("‚ö†Ô∏è Stdin write timeout - forcing close");try{f.stdin.end(),f.stdin.destroy()}catch(e){console.error(`Failed to force close stdin: ${e.message}`)}},1e4);f.stdin.write(o,s=>{clearTimeout(e),s?console.error("‚ùå Error writing to stdin:",s):console.log("‚úÖ Successfully sent context restoration"),f.stdin.end(),console.log("üìù Closed stdin after sending message (--print mode requires this)")})}l.pendingContextRestore=!1}else if(i&&!f.inputHandled){const e=i+"\n";console.log(`üìù Sending message to claude via stdin (${i.length} chars) - resuming=${g}`);const s=setTimeout(()=>{console.error("‚ö†Ô∏è Stdin write timeout - forcing close");try{f.stdin.end(),f.stdin.destroy()}catch(e){console.error(`Failed to force close stdin: ${e.message}`)}},1e4);f.stdin.write(e,e=>{clearTimeout(s),e?console.error("‚ùå Error writing to stdin:",e):console.log("‚úÖ Successfully wrote to stdin"),f.stdin.end(),console.log("üìù Closed stdin after sending message (--print mode requires this)")})}else f.inputHandled?console.log("üìù Message already embedded in WSL script"):i||console.log("üìù No message to send");if(console.log(`üè∑Ô∏è Title check: hasGeneratedTitle=${l.hasGeneratedTitle}, messageLength=${i?.length}, autoGenerateTitle=${a}`),a&&!l.hasGeneratedTitle&&i&&i.length>5){let s=i;try{const e=JSON.parse(i);Array.isArray(e)&&(s=e.filter(e=>"text"===e.type).map(e=>e.text).join(" "),console.log(`üè∑Ô∏è Extracted text from JSON: "${s}"`))}catch(e){console.log(`üè∑Ô∏è Using plain text content: "${s}"`)}s&&s.trim().length>5?(console.log(`üè∑Ô∏è Calling generateTitle for session ${n}`),generateTitle(n,s,e,()=>{console.log(`üè∑Ô∏è Title successfully generated for session ${n}`),l.hasGeneratedTitle=!0})):console.log(`üè∑Ô∏è Skipping title generation - text too short: "${s}"`)}let y="",$=0,w=0,S=Date.now(),k=Date.now();streamHealthChecks.has(n)&&clearInterval(streamHealthChecks.get(n)),streamTimeouts.has(n)&&clearTimeout(streamTimeouts.get(n));const b=setInterval(()=>{const s=Date.now()-S,o=Date.now()-k;if(debugLog(`ü©∫ [${n}] duration: ${o}ms | since_last: ${s}ms | bytes: ${w} | msgs: ${$} | buffer: ${y.length} | alive: ${activeProcesses.has(n)}`),s>3e4&&(console.error(`‚ö†Ô∏è WARNING: No data received for ${s}ms!`),e.emit(`keepalive:${n}`,{timestamp:Date.now()})),s>45e3&&s<5e4&&(console.warn(`‚ö†Ô∏è Stream stalled for ${s}ms, attempting recovery...`),activeProcesses.has(n))){const e=activeProcesses.get(n);if(e.stdin&&!e.stdin.destroyed)try{e.stdin.write("\n\n"),console.log("üìù Sent newlines to potentially unstick process")}catch(e){console.error(`Failed to write to stdin: ${e.message}`)}}},5e3);streamHealthChecks.set(n,b);const _=setTimeout(()=>{if(console.warn(`‚è∞ Stream timeout reached for session ${n} after 2 hours`),activeProcesses.has(n)){const e=activeProcesses.get(n);console.log(`‚è∞ Terminating long-running process for ${n}`),e.kill("SIGTERM")}},72e5);streamTimeouts.set(n,_);const C=s=>{if(s.trim()){debugLog(`üîπ [${n}] Processing line (${s.length} chars): ${s}`);try{const e=processWrapperLine(s,n);e&&e!==s&&(s=e)}catch(e){console.error("[WRAPPER] Error processing line:",e.message)}if(S=Date.now(),s.includes("No conversation found with session ID")){console.log(`üîÑ [${n}] Resume failed - session not found in Claude storage`),console.log(`üîÑ [${n}] Will create new session with existing context on next message`);const s=sessions.get(n);if(s){s.claudeSessionId=null;const o={id:`result-error-${Date.now()}-${Math.random()}`,type:"result",subtype:"error",is_error:!0,error:"Session not found - restoring from checkpoint",requiresCheckpointRestore:!0,streaming:!1,timestamp:Date.now()},t=`message:${n}`;console.log(`üì§ [${n}] Emitting error result with checkpoint restore flag`),e.emit(t,o),console.log(`üì§ [${n}] Sent checkpoint restore signal`);const i=`system-info-${Date.now()}-${Math.random()}`;e.emit(`message:${n}`,{id:i,type:"system",subtype:"info",message:{content:"session history not found - send message again to continue"},timestamp:Date.now(),streaming:!1}),console.log(`üì§ [${n}] Sent info message ${i} about session not found`),s.isReady=!0,console.log(`‚úÖ [${n}] Session marked as ready after resume failure`)}return}try{const o=JSON.parse(s);console.log(`üì¶ [${n}] Message type: ${o.type}${o.subtype?` (${o.subtype})`:""}`);const t=l?.messages?.filter(e=>"user"===e.role).pop(),i="/compact"===t?.message?.content?.trim()&&"result"===o.type;if(o.session_id&&!i){const e=l.claudeSessionId;if(e&&e!==o.session_id){const s=getWrapperSession(n);console.log(`üîÑ [${n}] Claude session ID changed (${e} ‚Üí ${o.session_id})`),console.log(`üîÑ [${n}] Preserving accumulated tokens: ${s.totalTokens} (history still sent to claude)`)}l.claudeSessionId=o.session_id,console.log(`üìå [${n}] Claude session ID: ${l.claudeSessionId}`)}else i&&o.session_id&&console.log(`üóúÔ∏è [${n}] Ignoring session ID from compact result: ${o.session_id} (not resumable)`);if("system"===o.type&&"init"===o.subtype)e.emit(`message:${n}`,{type:"system",subtype:"init",message:o,timestamp:Date.now()});else if("assistant"===o.type){const s=`assistant-${n}-${Date.now()}-${Math.random()}`;if(o.message?.content){let t=!1,i=[],r=!1;for(const s of o.message.content)if("text"===s.type||"thinking"===s.type)t=!0,i.push(s),"thinking"===s.type&&console.log(`üß† [${n}] Found thinking block: ${(s.thinking||s.text||"").substring(0,100)}...`);else if("tool_use"===s.type){r=!0;let t=s.input;if(("Edit"===s.name||"MultiEdit"===s.name)&&s.input?.file_path)try{const e=s.input.file_path,o=isAbsolute(e)?e:join(l.workingDirectory||process.cwd(),e);if(console.log(`üìç [${n}] Calculating line numbers for ${s.name} on ${o}`),existsSync(o)){const e=readFileSync(o,"utf8"),i=e.split("\n");if(console.log(`üìç [${n}] File has ${i.length} lines`),"Edit"===s.name&&s.input.old_string){const e=s.input.old_string.split("\n");console.log(`üìç [${n}] Looking for ${e.length} line(s) in file`);let o=!1;for(let r=0;r<=i.length-e.length;r++){let a=!0;for(let s=0;s<e.length;s++)if(i[r+s]!==e[s]){a=!1;break}if(a){t={...s.input,lineNumber:r+1,endLineNumber:r+e.length},console.log(`üìç [${n}] Found edit at lines ${r+1}-${r+e.length}`),o=!0;break}}o||console.log(`üìç [${n}] Could not find exact match for old_string in file`)}else if("MultiEdit"===s.name&&s.input.edits){let o=e,r=i;const a=s.input.edits.map((e,s)=>{if(!e.old_string)return e;const t=e.old_string.split("\n");console.log(`üìç [${n}] Edit ${s+1}: Looking for ${t.length} line(s)`);for(let i=0;i<=r.length-t.length;i++){let a=!0;for(let e=0;e<t.length;e++)if(r[i+e]!==t[e]){a=!1;break}if(a){console.log(`üìç [${n}] Edit ${s+1} found at lines ${i+1}-${i+t.length}`);const a=e.new_string.split("\n");return r.splice(i,t.length,...a),o=r.join("\n"),{...e,lineNumber:i+1,endLineNumber:i+t.length}}}return console.log(`üìç [${n}] Edit ${s+1} could not find match`),e});t={...s.input,edits:a}}}else console.log(`üìç [${n}] File not found: ${o}`)}catch(e){console.log(`üìç [${n}] Error calculating line numbers for ${s.name}: ${e.message}`)}const i={type:"tool_use",message:{name:s.name,input:t,id:s.id},timestamp:Date.now(),id:`tool-${n}-${Date.now()}`};o.parent_tool_use_id&&(i.parent_tool_use_id=o.parent_tool_use_id,debugLog(`ü§ñ [${n}] Subagent tool_use (parent: ${o.parent_tool_use_id.substring(0,20)}...): ${s.name}`)),queueMessage(n,i,e,!0)}if(t&&i.length>0){lastAssistantMessageIds.set(n,s),console.log(`üìù [${n}] Emitting assistant message ${s} with streaming=true`),console.log(`üìù [${n}] Content blocks: ${i.length} (types: ${i.map(e=>e.type).join(", ")})`);const t={type:"assistant",id:s,message:{...o.message,content:i},streaming:!0,timestamp:Date.now()};if(o.parent_tool_use_id&&(t.parent_tool_use_id=o.parent_tool_use_id,debugLog(`ü§ñ [${n}] Subagent assistant message (parent: ${o.parent_tool_use_id.substring(0,20)}...)`)),queueMessage(n,t,e),l.messages.push({type:"assistant",message:{content:i},id:s,timestamp:Date.now()}),l.messages.length>1e3){const e=Math.floor(200);l.messages.splice(0,e),console.log(`üßπ Trimmed ${e} old messages from session ${n}`)}$++}else if(r&&!t){lastAssistantMessageIds.set(n,s),allAssistantMessageIds.has(n)||allAssistantMessageIds.set(n,[]),allAssistantMessageIds.get(n).push(s),console.log(`üìù [${n}] Emitting assistant message ${s} (tool-only) with streaming=true`),e.emit(`message:${n}`,{type:"assistant",id:s,message:{...o.message,content:[]},streaming:!0,timestamp:Date.now()});const t=sessions.get(n);t&&t.messages.push({type:"assistant",message:{content:[]},id:s,timestamp:Date.now()}),$++}}}else if("user"===o.type&&o.message?.content){for(const s of o.message.content)if("tool_result"===s.type){let t=s.content;if("string"==typeof s.content&&(s.content.includes("has been updated")||s.content.includes("Applied")&&s.content.includes("edits to"))){const e=s.content.match(/The file (.+?) has been updated/)||s.content.match(/Applied \d+ edits? to (.+?):/);if(e){const o=e[1],i=join(l.workingDirectory||process.cwd(),o);console.log(`üìù [${n}] Attempting to enhance diff for: ${o}`);try{if(existsSync(i)){const e=readFileSync(i,"utf8").split("\n"),o=s.content.split("\n"),r=/^\s*(\d+)‚Üí/,a=new Set;if(o.forEach(e=>{const s=e.match(r);s&&a.add(parseInt(s[1]))}),a.size>0){console.log(`üìù [${n}] Found ${a.size} changed lines, enhancing with context`);const s=3,i=[],r=o.findIndex(e=>e.includes("Here's the result of running"));r>=0&&i.push(...o.slice(0,r+1));const l=Array.from(a).sort((e,s)=>e-s);let c=-999;l.forEach(o=>{const t=Math.max(1,o-s),n=Math.min(e.length,o+s);for(let s=t;s<o;s++)if(s>c){const o=String(s).padStart(6," ");a.has(s)?i.push(`${o}‚Üí${e[s-1]}`):i.push(`${o} ${e[s-1]}`),c=s}const r=String(o).padStart(6," ");o>c&&(i.push(`${r}‚Üí${e[o-1]}`),c=o);for(let s=o+1;s<=n;s++)if(s>c){const o=String(s).padStart(6," ");a.has(s)?i.push(`${o}‚Üí${e[s-1]}`):i.push(`${o} ${e[s-1]}`),c=s}const d=l[l.indexOf(o)+1];d&&d>n+1&&i.push("   ...")}),t=i.join("\n"),console.log(`üìù [${n}] Enhanced diff created with ${i.length} lines`)}else console.log(`üìù [${n}] No line numbers found in diff, keeping original content`)}}catch(e){console.log(`Could not enhance Edit output with context lines: ${e.message}`)}}}const i={type:"tool_result",message:{tool_use_id:s.tool_use_id,content:t,is_error:s.is_error},timestamp:Date.now(),id:`toolresult-${n}-${Date.now()}`};o.parent_tool_use_id&&(i.parent_tool_use_id=o.parent_tool_use_id,console.log(`ü§ñ [${n}] Subagent tool_result (parent: ${o.parent_tool_use_id.substring(0,20)}...)`)),e.emit(`message:${n}`,i)}}else if("content_block_start"===o.type)console.log(`üìù [${n}] Content block starting:`,o.content_block?.type),e.emit(`message:${n}`,{type:"content_block_start",content_block:o.content_block,index:o.index,timestamp:Date.now()});else if("content_block_stop"===o.type)console.log(`üìù [${n}] Content block stopped:`,o.index),e.emit(`message:${n}`,{type:"content_block_stop",index:o.index,timestamp:Date.now()});else if("rate_limit"===o.type)console.log(`‚ö†Ô∏è [${n}] Rate limit:`,o.rate_limit),e.emit(`message:${n}`,{type:"rate_limit",rate_limit:o.rate_limit,timestamp:Date.now()});else if("progress"===o.type)console.log(`‚è≥ [${n}] Progress:`,o.progress),e.emit(`message:${n}`,{type:"progress",progress:o.progress,message:o.message,timestamp:Date.now()});else if("compact"===o.type||"system"===o.type&&"compact"===o.subtype)console.log(`üóúÔ∏è [${n}] Context compacted`),e.emit(`message:${n}`,{type:"system",subtype:"compact",message:{content:"context compressed - usage will reset on next message"},timestamp:Date.now()});else if("ping"===o.type||"pong"===o.type)console.log(`üèì [${n}] ${o.type} received`);else if("metadata"===o.type)console.log(`üìã [${n}] Metadata:`,o),o.title&&e.emit(`title:${n}`,o.title);else if("summary"===o.type)console.log(`üìù [${n}] Summary:`,o.summary),o.summary&&e.emit(`title:${n}`,o.summary);else if("result"===o.type){console.log(`üì¶ [${n}] RESULT MESSAGE RECEIVED!`),console.log(`   ‚úÖ Result: success=${!o.is_error}, duration=${o.duration_ms}ms`),console.log("   üìä Full result data:",JSON.stringify(o,null,2));const s=sessions.get(n),t=s?.messages?.filter(e=>"user"===e.role).pop(),i="/compact"===t?.message?.content?.trim()&&(o.result?.includes("Compacted")||o.result?.includes("compressed")||o.result?.includes("summary")||""===o.result||null===o.result);if(i){if(console.log(`üóúÔ∏è [${n}] Detected /compact command completion`),console.log(`üóúÔ∏è [${n}] Result text: "${o.result}"`),console.log(`üóúÔ∏è [${n}] Session ID in result: ${o.session_id}`),console.log(`üóúÔ∏è [${n}] Usage data:`,o.usage),s){const e=s.claudeSessionId;s.claudeSessionId=null,s.wasCompacted=!0,console.log(`üóúÔ∏è Cleared session ID (was ${e}) - next message will start fresh after compact`),console.log("üóúÔ∏è Marked session as compacted to prevent old ID restoration"),console.log("üóúÔ∏è The compact command has summarized the conversation - continuing with reduced context")}const t=o.usage?{input:o.usage.input_tokens||0,output:o.usage.output_tokens||0,cache_creation:o.usage.cache_creation_input_tokens||0,cache_read:o.usage.cache_read_input_tokens||0,total:(o.usage.input_tokens||0)+(o.usage.output_tokens||0)+(o.usage.cache_creation_input_tokens||0)+(o.usage.cache_read_input_tokens||0)}:null;t&&console.log(`üóúÔ∏è [${n}] Compacted token count: ${t.total} (input: ${t.input}, output: ${t.output})`),e.emit(`message:${n}`,{type:"system",subtype:"compact",session_id:null,message:{content:"context compacted - starting fresh with reduced tokens",compactedTokens:t,compactSummary:o.result||"conversation summarized"},timestamp:Date.now()})}if(o.usage){const e=o.usage.input_tokens||0,s=o.usage.output_tokens||0,t=o.usage.cache_creation_input_tokens||0,i=o.usage.cache_read_input_tokens||0,r=getWrapperSession(n).totalTokens,a=i+t+e+s;console.log("\nüìä TOKEN USAGE BREAKDOWN:"),console.log("   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"),console.log("   ‚îÇ Type            ‚îÇ Input    ‚îÇ Cache Read   ‚îÇ Cache New  ‚îÇ"),console.log("   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"),console.log(`   ‚îÇ User Message    ‚îÇ ${String(e).padEnd(8)} ‚îÇ              ‚îÇ            ‚îÇ`),console.log(`   ‚îÇ Assistant Reply ‚îÇ ${String(s).padEnd(8)} ‚îÇ              ‚îÇ            ‚îÇ`),console.log(`   ‚îÇ Context History ‚îÇ          ‚îÇ ${String(i).padEnd(12)} ‚îÇ            ‚îÇ`),console.log(`   ‚îÇ New Cache       ‚îÇ          ‚îÇ              ‚îÇ ${String(t).padEnd(10)} ‚îÇ`),console.log("   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"),console.log(`   ‚îÇ Subtotal        ‚îÇ ${String(e+s).padEnd(8)} ‚îÇ ${String(i).padEnd(12)} ‚îÇ ${String(t).padEnd(10)} ‚îÇ`),console.log("   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"),console.log(`   API REPORTED: ${a} | TRACKED TOTAL: ${r} / 200000 (${(r/2e3).toFixed(1)}%)`),console.log("   Note: Tracked total persists even when Anthropic's cache expires")}const a=lastAssistantMessageIds.get(n);a&&console.log(`üìã [${n}] Result received with last assistant message ${a} - deferring streaming=false to process exit`),console.log(`‚úÖ [${n}] Sending result message with model: ${r}`);const l={type:"result",...o,streaming:!1,id:`result-${n}-${Date.now()}`,model:r||"unknown"};if(o.usage){l.usage=o.usage;const e=getWrapperSession(n);l.wrapper={tokens:{input:o.usage.input_tokens||0,output:o.usage.output_tokens||0,total:e.totalTokens,cache_read:o.usage.cache_read_input_tokens||0,cache_creation:o.usage.cache_creation_input_tokens||0}},console.log("üìä [WRAPPER-TOKENS] Added both usage and wrapper tokens to result message:",{usage:l.usage,wrapperTokens:l.wrapper.tokens})}else console.log("‚ùå [WRAPPER-TOKENS] No usage data in jsonData, neither usage nor wrapper field added");!i&&s.claudeSessionId&&(l.session_id=s.claudeSessionId),console.log(`   - Model in result message: ${l.model}`),console.log(`   - Session ID in result message: ${l.session_id||"(cleared after compact)"}`),l.usage&&(console.log("   - Usage breakdown (CUMULATIVE for session - NOT current context size):"),console.log(`     ‚Ä¢ input_tokens: ${l.usage.input_tokens||0} (cumulative)`),console.log(`     ‚Ä¢ output_tokens: ${l.usage.output_tokens||0} (cumulative)`),console.log(`     ‚Ä¢ cache_creation: ${l.usage.cache_creation_input_tokens||0} (cumulative)`),console.log(`     ‚Ä¢ cache_read: ${l.usage.cache_read_input_tokens||0} (cumulative sum across turns)`),console.log(`     ‚Ä¢ ACTUAL CURRENT CONTEXT: ${l.wrapper?.tokens?.total||0} (from last assistant message)`)),debugLog("üì§ [EMIT-DEBUG] About to emit result message with wrapper field:",{hasWrapper:!!l.wrapper,wrapperTokens:l.wrapper?.tokens,messageKeys:Object.keys(l),wrapperStructure:l.wrapper?Object.keys(l.wrapper):null}),e.emit(`message:${n}`,l),$++}}catch(e){debugLog(`‚ö†Ô∏è [${n}] Failed to parse JSON, treating as plain text:`,e.message),debugLog(`‚ö†Ô∏è [${n}] Line was: ${s}`)}}else debugLog(`üî∏ [${n}] Empty line received`)};console.log(`üîç [${n}] Process spawned with PID: ${f.pid}`),console.log(`üîç [${n}] Process connected: ${f.connected}`);let P="";f.stderr.on("data",e=>{const s=e.toString();P+=s,console.error(`‚ùå [${n}] STDERR output: ${s}`),(s.includes("command not found")||s.includes("No such file"))&&(console.error(`‚ùå [${n}] WSL PATH ERROR - Claude CLI not found!`),console.error(`‚ùå [${n}] Full stderr: ${P}`)),(s.includes("bash:")||s.includes("sh:"))&&console.error(`‚ùå [${n}] WSL BASH ERROR detected`)});const T=setInterval(()=>{if(y.length>0&&Date.now()-S>5e3&&(console.warn(`‚ö†Ô∏è [${n}] Flushing stale buffer (${y.length} chars)`),y.trim()))try{C(y),y=""}catch(e){console.log(`üìù [${n}] Buffer contains incomplete JSON, waiting for more data`)}},5e3);f.stdout.on("data",e=>{const s=e.toString();if(w+=e.length,S=Date.now(),console.log(`üì• [${n}] STDOUT received: ${s.length} bytes (total: ${w})`),console.log(`üì• [${n}] Data preview: ${s.substring(0,200)}...`),y.length>52428800){if(console.error(`‚ö†Ô∏è [${n}] Line buffer overflow (${y.length} bytes), processing and clearing`),y.includes("{")){const s=y.match(/\{[^}]*\}/g);if(s)for(const o of s)try{C(o)}catch(e){console.error(`[${n}] Failed to process JSON chunk:`,e)}}y=""}y+=s;const o=y.split("\n");y=o.pop()||"",debugLog(`üìã [${n}] Split into ${o.length} lines, buffer remaining: ${y.length} chars`);for(let e=0;e<o.length;e++)debugLog(`üìã [${n}] Processing line ${e+1}/${o.length}`),C(o[e])}),f.on("exit",()=>{clearInterval(T)}),f.stderr.on("data",s=>{const o=s.toString();if(console.error(`‚ö†Ô∏è [${n}] Claude stderr (${s.length} bytes):`,o),S=Date.now(),o.includes("No conversation found with session ID")){console.log("üîÑ Resume failed - session not found in Claude storage"),console.log("üîÑ Clearing invalid session ID - will use fresh conversation on next message"),l?.wasCompacted&&console.log("üîÑ This was expected - session was compacted and old ID is no longer valid"),l.claudeSessionId=null,l.wasInterrupted=!1;const s={id:`result-error-${Date.now()}-${Math.random()}`,type:"result",subtype:"error",is_error:!0,error:"Session not found - restoring from checkpoint",requiresCheckpointRestore:!0,streaming:!1,timestamp:Date.now()},o=`message:${n}`;console.log(`üì§ [${n}] Emitting error result with checkpoint restore (stderr)`),e.emit(o,s),console.log(`üì§ [${n}] Sent checkpoint restore signal (stderr)`)}else e.emit(`message:${n}`,{type:"error",error:o,claudeSessionId:l.claudeSessionId,streaming:!1})}),f.on("close",s=>{if(f.stdin&&!f.stdin.destroyed)try{f.stdin.end(),console.log("üìù Closed stdin on process exit")}catch(e){}streamHealthChecks.has(n)&&(clearInterval(streamHealthChecks.get(n)),streamHealthChecks.delete(n)),streamTimeouts.has(n)&&(clearTimeout(streamTimeouts.get(n)),streamTimeouts.delete(n)),clearInterval(b);const o=Date.now()-k;if(console.log(`üëã [${n}] Claude process exited with code ${s}`),console.log(`üìä [${n}] STREAM SUMMARY:`),console.log(`   ‚îú‚îÄ Total duration: ${o}ms`),console.log(`   ‚îú‚îÄ Total bytes: ${w}`),console.log(`   ‚îú‚îÄ Messages: ${$}`),console.log(`   ‚îú‚îÄ Exit code: ${s}`),console.log(`   ‚îú‚îÄ Stderr: ${P||"(empty)"}`),console.log(`   ‚îî‚îÄ Line buffer: ${y||"(empty)"}`),0===w&&(console.error(`‚ùå [${n}] NO OUTPUT RECEIVED FROM CLAUDE!`),console.error(`‚ùå [${n}] This usually means:`),console.error("   1. Claude CLI is not installed in WSL"),console.error("   2. Claude is not in any of the expected paths"),console.error("   3. WSL is not running properly"),console.error("   4. The command syntax is wrong")),activeProcesses.delete(n),activeProcessStartTimes.delete(n),0===s){const e=sessions.get(n);e&&(e.wasInterrupted=!1,console.log(`‚úÖ Marked session ${n} as completed normally`))}else if(1===s){const s=sessions.get(n);if(s&&s.claudeSessionId&&P.includes("No conversation found")){console.log("‚ö†Ô∏è Resume failed - session not found in Claude storage"),console.log("üîÑ Will recreate session with existing context on next attempt"),s.claudeSessionId=null;const o={id:`result-error-${Date.now()}-${Math.random()}`,type:"result",subtype:"error",is_error:!0,error:"Session not found - restoring from checkpoint",requiresCheckpointRestore:!0,streaming:!1,timestamp:Date.now()},t=`message:${n}`;console.log(`üì§ [${n}] Emitting error result with checkpoint restore (exit code 1)`),e.emit(t,o),console.log(`üì§ [${n}] Sent checkpoint restore signal (exit code 1)`);const i=lastAssistantMessageIds.get(n);i&&(console.log(`üî¥ Clearing assistant message ID ${i} after resume failure`),lastAssistantMessageIds.delete(n)),e.emit(`message:${n}`,{type:"system",subtype:"info",message:{content:"continuing conversation (session history not found in claude)"},timestamp:Date.now(),streaming:!1})}}if(y.trim())try{C(y)}catch(e){console.error("Failed to process remaining buffer:",e)}const t=sessions.get(n);if(t?.wasInterrupted)console.log("üîÑ Skipping streaming=false for interrupted process (new process is running)");else{const s=lastAssistantMessageIds.get(n);cancelPendingStreamingFalse(n),console.log(`‚è±Ô∏è [${n}] Scheduling streaming=false with 600ms debounce`);const o=setTimeout(()=>{if(activeProcesses.has(n))return console.log(`üîÑ [${n}] New process started during debounce - skipping streaming=false`),void pendingStreamingFalseTimers.delete(n);const o=sessions.get(n);if(o?.wasInterrupted)return console.log(`üîÑ [${n}] Session interrupted during debounce - skipping streaming=false`),void pendingStreamingFalseTimers.delete(n);if(s){console.log(`üî¥ [${n}] Debounce complete - marking streaming=false for ${s}`);const t=o?.messages.find(e=>e.id===s);e.emit(`message:${n}`,{type:"assistant",id:s,message:t?.message||{content:""},streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(n)}e.emit(`message:${n}`,{type:"system",subtype:"stream_end",streaming:!1,timestamp:Date.now()}),pendingStreamingFalseTimers.delete(n)},600);pendingStreamingFalseTimers.set(n,{timer:o,timestamp:Date.now()})}null===s||-2===s||"SIGKILL"===s?(console.error(`‚ö†Ô∏è Claude process terminated unexpectedly (code: ${s})`),e.emit(`message:${n}`,{type:"error",error:"session terminated unexpectedly. you can resume by sending another message.",streaming:!1,timestamp:Date.now()})):0!==s&&(t.wasInterrupted?(console.log(`Process exited with code ${s} after interruption - not showing error`),t.wasInterrupted=!1):(console.error(`Claude process failed with exit code ${s}`),e.emit(`message:${n}`,{type:"system",subtype:"info",message:`process completed with code ${s}`,timestamp:Date.now()})))}),f.on("error",s=>{streamHealthChecks.has(n)&&(clearInterval(streamHealthChecks.get(n)),streamHealthChecks.delete(n)),streamTimeouts.has(n)&&(clearTimeout(streamTimeouts.get(n)),streamTimeouts.delete(n)),clearInterval(b),console.error(`‚ùå [${n}] Failed to spawn claude:`,s),console.error(`‚ùå [${n}] Error details:`,{message:s.message,code:s.code,syscall:s.syscall,path:s.path}),cancelPendingStreamingFalse(n);const o=lastAssistantMessageIds.get(n);if(o){console.log(`üî¥ Forcing streaming=false for assistant message ${o} on process error`);const s=sessions.get(n),t=s?.messages.find(e=>e.id===o);e.emit(`message:${n}`,{type:"assistant",id:o,message:t?.message||{content:""},streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(n)}e.emit(`message:${n}`,{type:"error",error:`claude process error: ${s.message}. try sending your message again.`,claudeSessionId:l.claudeSessionId,streaming:!1}),activeProcesses.delete(n),activeProcessStartTimes.delete(n),lastAssistantMessageIds.delete(n),t&&t({success:!1,error:s.message})}),t&&t({success:!0})}catch(s){console.error("‚ùå Error in spawnRequest:",s),e.emit(`message:${n}`,{type:"error",error:s.message,claudeSessionId:l.claudeSessionId,streaming:!1}),t&&t({success:!1,error:s.message})}finally{s()}};processSpawnQueue.push(c),console.log(`üìã Added request to queue. Queue length: ${processSpawnQueue.length}`),1===processSpawnQueue.length&&s()}),e.on("interrupt",({sessionId:s},o)=>{const t=activeProcesses.get(s),n=sessions.get(s);console.log(`‚õî Interrupt requested for session ${s}`);const i=processSpawnQueue.length;i>0&&(processSpawnQueue.length=0,console.log(`üßπ Cleared ${i} queued messages after interrupt`));const r=spawningProcesses.get(s);if(r&&!r.aborted)return console.log(`‚ö†Ô∏è Session ${s} is currently spawning - marking for abort`),r.aborted=!0,spawningProcesses.set(s,r),o&&(pendingInterrupts.set(s,o),console.log(`üìù Stored pending interrupt callback for session ${s}`)),void e.emit(`message:${s}`,{type:"system",subtype:"interrupted",message:"stopping task...",timestamp:Date.now()});if(t){if(console.log(`üõë Killing claude process for session ${s} (PID: ${t.pid})`),t.pid)try{process.kill(-t.pid,"SIGINT")}catch(e){t.kill("SIGINT")}else t.kill("SIGINT");activeProcesses.delete(s),activeProcessStartTimes.delete(s),n&&(n.wasInterrupted=!0,console.log(`üîÑ Session ${s} interrupted - marked wasInterrupted=true for followup`));const i=lastAssistantMessageIds.get(s);i&&(e.emit(`message:${s}`,{type:"assistant",id:i,streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(s)),e.emit(`message:${s}`,{type:"system",subtype:"interrupted",message:"task interrupted by user",timestamp:Date.now()}),o&&o({success:!0})}else console.log(`‚ö†Ô∏è No active process found for session ${s} - nothing to interrupt`),spawningProcesses.delete(s),pendingInterrupts.delete(s),e.emit(`message:${s}`,{type:"system",subtype:"interrupted",message:"task stopped",timestamp:Date.now()}),o&&o({success:!0,noProcess:!0})}),e.on("clearSession",({sessionId:s})=>{const o=sessions.get(s);if(!o)return void console.error(`Session not found: ${s}`);const t=activeProcesses.get(s);if(t){if(console.log(`üõë Killing process for cleared session ${s} (PID: ${t.pid})`),t.pid)try{process.kill(-t.pid,"SIGINT")}catch(e){t.kill("SIGINT")}else t.kill("SIGINT");activeProcesses.delete(s),activeProcessStartTimes.delete(s)}o.messages=[],o.claudeSessionId=null,o.hasGeneratedTitle=!1,o.wasInterrupted=!1,o.wasCompacted=!1,lastAssistantMessageIds.delete(s),console.log(`‚úÖ Session ${s} cleared - will start fresh Claude session on next message`),e.emit(`message:${s}`,{type:"system",subtype:"clear",message:"session cleared",timestamp:Date.now()});const n=`title:${s}`;console.log(`üè∑Ô∏è Emitting title reset for cleared session: ${n}`),e.emit(n,{title:"new session"})}),e.on("deleteSession",async(e,s)=>{const{sessionId:o}=e;sessions.delete(o),lastAssistantMessageIds.delete(o),cancelPendingStreamingFalse(o),spawningProcesses.delete(o),s({success:!0})}),e.on("disconnect",()=>{console.log("üîå Client disconnected:",e.id);for(const[s,o]of sessions.entries())if(o.socketId===e.id){streamHealthChecks.has(s)&&(clearInterval(streamHealthChecks.get(s)),streamHealthChecks.delete(s)),streamTimeouts.has(s)&&(clearTimeout(streamTimeouts.get(s)),streamTimeouts.delete(s));const e=activeProcesses.get(s);if(e){if(console.log(`üßπ Cleaning up process for session ${s} (PID: ${e.pid})`),e.pid)try{process.kill(-e.pid,"SIGINT")}catch(s){e.kill("SIGINT")}else e.kill("SIGINT");activeProcesses.delete(s),activeProcessStartTimes.delete(s)}lastAssistantMessageIds.delete(s),cancelPendingStreamingFalse(s),spawningProcesses.delete(s)}})}),cleanupOldPidFiles(),httpServer.listen(PORT,()=>{writePidFile(),console.log(`üöÄ yurucode server running on port ${PORT}`),console.log(`üìÇ Working directory: ${process.cwd()}`),console.log(`üñ•Ô∏è Platform: ${platform()}`),console.log(`üè† Home directory: ${homedir()}`),console.log(`üìÅ Claude projects: ${join(homedir(),".claude","projects")}`);const e=join(homedir(),".claude","projects");if(existsSync(e)){console.log("‚úÖ Claude projects directory exists");try{const{readdirSync:s}=require("fs"),o=s(e);console.log(`üìä Found ${o.length} project directory(s)`),o.length>0&&"win32"===platform()&&(console.log("üîç Sample project paths (first 3):"),o.slice(0,3).forEach(e=>{if(console.log(`  - ${e}`),e.match(/^[A-Z]--/)){const s=e.replace(/^([A-Z])--/,"$1:/").replace(/-/g,"/");console.log(`    ‚Üí Would convert to: ${s}`)}}))}catch(e){console.log("‚ö†Ô∏è Could not list projects:",e.message)}}else console.log("‚ö†Ô∏è Claude projects directory not found at:",e);console.log(`‚úÖ Server configured for ${"win32"===platform()?"Windows":platform()}`),console.log("üî• Warming up bash execution...");const s=spawn("echo",["warmup"],{shell:!1,stdio:"pipe"});s.on("close",()=>{console.log("‚úÖ Bash warmup complete")}),s.on("error",e=>{console.warn("‚ö†Ô∏è Bash warmup failed:",e.message)})}),httpServer.on("error",e=>{if("EADDRINUSE"===e.code){console.error(`‚ùå Port ${PORT} is already in use`),console.log("Attempting to kill existing process and retry...");const{exec:e}=require("child_process");e(`lsof -ti :${PORT} | xargs kill -9`,e=>{e?(console.error("Failed to kill existing process. Please restart the app."),process.exit(1)):(console.log("Killed existing process, retrying in 1 second..."),setTimeout(()=>{httpServer.listen(PORT)},1e3))})}else console.error("Server error:",e),process.exit(1)});