const originalConsole={log:console.log.bind(console),error:console.error.bind(console),warn:console.warn.bind(console),info:console.info.bind(console),debug:console.debug.bind(console)};console.log=function(...e){try{originalConsole.log(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.error=function(...e){try{originalConsole.error(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.warn=function(...e){try{originalConsole.warn(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.info=function(...e){try{originalConsole.info(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}},console.debug=function(...e){try{originalConsole.debug(...e)}catch(e){if("EBADF"!==e.code&&"EPIPE"!==e.code)throw e}};const{execSync:execSync,spawn:spawn}=require("child_process"),{existsSync:existsSync,mkdirSync:mkdirSync,readFileSync:readFileSync,writeFileSync:writeFileSync,unlinkSync:unlinkSync}=require("fs"),{dirname:dirname,join:join}=require("path"),{createServer:createServer}=require("http"),{Server:Server}=require("socket.io"),{homedir:homedir,platform:platform}=require("os");let CLAUDE_PATH="claude";const isWindows="win32"===platform();function checkWslAvailable(){if(!isWindows)return!1;try{return execSync("wsl --list",{encoding:"utf8",stdio:"pipe",windowsHide:!0}),console.log("‚úÖ WSL is available"),!0}catch(e){return console.log("‚ö†Ô∏è WSL not available:",e.message),!1}}const WSL_AVAILABLE=checkWslAvailable();function createWslClaudeCommand(e,s){const o=e.map(e=>e.includes(" ")||e.includes('"')||e.includes("'")||e.includes("$")||e.includes("\\")||e.includes("\n")?"'"+e.replace(/'/g,"'\\''")+"'":e).join(" ");return["C:\\Windows\\System32\\wsl.exe",["-e","bash","-c",`\n    claude_paths=(\n      "/usr/local/bin/claude"\n      "/usr/bin/claude"\n      "$HOME/.local/bin/claude"\n      "$HOME/.npm-global/bin/claude"\n      "$HOME/node_modules/.bin/claude"\n      "$HOME/.claude/local/claude"\n      "/opt/claude/bin/claude"\n    )\n    \n    # Check each user's .npm-global\n    for user_home in /home/*; do\n      if [ -d "$user_home" ]; then\n        claude_paths+=("$user_home/.npm-global/bin/claude")\n        claude_paths+=("$user_home/node_modules/.bin/claude")\n        claude_paths+=("$user_home/.local/bin/claude")\n      fi\n    done\n    \n    # Check nvm installations\n    if [ -d "$HOME/.nvm" ]; then\n      for nvm_path in $HOME/.nvm/versions/node/*/bin/claude; do\n        [ -x "$nvm_path" ] && claude_paths+=("$nvm_path")\n      done\n    fi\n    \n    # Try to find claude in PATH first\n    if command -v claude &>/dev/null; then\n      claude_cmd="claude"\n    else\n      # Check all known paths\n      claude_cmd=""\n      for path in "\${claude_paths[@]}"; do\n        if [ -x "$path" ]; then\n          claude_cmd="$path"\n          break\n        fi\n      done\n    fi\n    \n    if [ -z "$claude_cmd" ]; then\n      echo "Claude CLI not found in WSL. Searched all common paths including npm global installations." >&2\n      exit 127\n    fi\n    \n    ${s?`cd '${s.replace(/'/g,"'\\''")}'`:":"}\n    exec "$claude_cmd" ${o}\n  `.trim()]]}if(isWindows)WSL_AVAILABLE?(console.log("üîç Windows detected, Claude will be invoked through WSL with comprehensive path detection..."),CLAUDE_PATH="WSL_CLAUDE"):(console.log("‚ö†Ô∏è Windows detected but WSL is not available. Claude CLI requires WSL on Windows."),CLAUDE_PATH="WSL_CLAUDE");else{const e=[join(homedir(),".npm-global/bin/claude"),"/opt/homebrew/bin/claude","/usr/local/bin/claude","/usr/bin/claude",process.env.CLAUDE_PATH].filter(Boolean);for(const s of e)try{if(existsSync(s)){CLAUDE_PATH=s,console.log(`‚úÖ Found Claude CLI at: ${CLAUDE_PATH}`);break}}catch(e){}if("claude"===CLAUDE_PATH)try{const e=execSync("which claude",{encoding:"utf8"}).trim();e&&(CLAUDE_PATH=e,console.log(`‚úÖ Found Claude CLI via which: ${CLAUDE_PATH}`))}catch(e){}if("claude"===CLAUDE_PATH)try{const e=execSync("whereis claude",{encoding:"utf8"}).trim().match(/claude:\s+(.+)/);if(e&&e[1]){const s=e[1].split(/\s+/);for(const e of s)if(existsSync(e)){CLAUDE_PATH=e,console.log(`‚úÖ Found Claude CLI via whereis: ${CLAUDE_PATH}`);break}}}catch(e){console.warn("‚ö†Ô∏è Claude CLI not found via whereis. Using 'claude' and hoping for the best.")}}const express=require("express"),cors=require("cors"),net=require("net"),app=express(),httpServer=createServer(app),io=new Server(httpServer,{cors:{origin:"*",methods:["GET","POST"]},transports:["websocket","polling"],pingTimeout:6e5,pingInterval:3e4,upgradeTimeout:6e4,maxHttpBufferSize:5e8,perMessageDeflate:!1,httpCompression:!1});app.use(cors()),app.use(express.json());const PORT=(()=>{if(process.env.PORT){const e=parseInt(process.env.PORT);return console.log(`‚úÖ Using PORT from Rust: ${e}`),e}console.log("üîç Finding available port in range 60000-61000...");let e=6e4+Math.floor(1001*Math.random());for(let s=0;s<100;s++){const o=6e4+(e-6e4+s)%1001,t=net.createServer();try{return t.listen(o,"127.0.0.1"),t.close(),console.log(`‚úÖ Found available port: ${o}`),o}catch(e){}}return console.log("‚ö†Ô∏è Could not find available port, using 3001"),3001})();let sessions=new Map,activeProcesses=new Map,activeProcessStartTimes=new Map,lastAssistantMessageIds=new Map,allAssistantMessageIds=new Map,streamHealthChecks=new Map,streamTimeouts=new Map,activeFileOperations=new Map;class SessionPersistence{constructor(){this.sessionDir=join(homedir(),".yurucode","sessions"),this.ensureDirectory()}ensureDirectory(){existsSync(this.sessionDir)||(mkdirSync(this.sessionDir,{recursive:!0}),console.log(`üìÅ Created session directory: ${this.sessionDir}`))}saveSession(e,s){try{const o=join(this.sessionDir,`${e}.json`);writeFileSync(o,JSON.stringify(s,null,2)),console.log(`üíæ Saved session to disk: ${e}`)}catch(s){console.error(`‚ùå Failed to save session ${e}:`,s.message)}}loadSession(e){try{const s=join(this.sessionDir,`${e}.json`);if(existsSync(s)){const o=JSON.parse(readFileSync(s,"utf8"));return console.log(`üìÇ Loaded session from disk: ${e}`),o}}catch(s){console.error(`‚ùå Failed to load session ${e}:`,s.message)}return null}deleteSession(e){try{const s=join(this.sessionDir,`${e}.json`);existsSync(s)&&(unlinkSync(s),console.log(`üóëÔ∏è Deleted session file: ${e}`))}catch(s){console.error(`‚ùå Failed to delete session ${e}:`,s.message)}}}const sessionPersistence=new SessionPersistence;let isSpawningProcess=!1;const processSpawnQueue=[];async function generateTitle(e,s,o,t){try{console.log(`üè∑Ô∏è Generating title for session ${e}`),console.log(`üè∑Ô∏è Message preview: "${s.substring(0,100)}..."`);const n=["--print","--output-format","json","--model","claude-sonnet-4-5-20250929"],r=`user message: "${s.substring(0,200)}"\ntask: reply with ONLY 1-3 words describing what user wants. lowercase only. no punctuation. be extremely concise. examples: "echo command", "file search", "debug issue"`;console.log(`üè∑Ô∏è Title prompt: "${r}"`);const i={...process.env},a="/opt/homebrew/bin";i.PATH?.includes(a)||(i.PATH=`${a}:${i.PATH||"/usr/bin:/bin"}`);const l=isWindows&&"WSL_CLAUDE"===CLAUDE_PATH?(()=>{if(!WSL_AVAILABLE){const e=require("events"),s=new e;return s.stdout=new e,s.stderr=new e,s.stdin={write:()=>{},end:()=>{}},s.kill=()=>{},setTimeout(()=>{s.stderr.emit("data","WSL not available"),s.emit("close",1)},0),s}const[e,s]=createWslClaudeCommand(n,null);return spawn(e,s,{cwd:process.cwd(),env:i,stdio:["pipe","pipe","pipe"],shell:!0,windowsHide:!0,detached:!1})})():spawn(CLAUDE_PATH,n,{cwd:process.cwd(),env:i,stdio:["pipe","pipe","pipe"],windowsHide:!0,detached:!1});let c="",d="";l.stdout.on("data",e=>{c+=e.toString(),console.log(`üè∑Ô∏è Title generation stdout: ${e.toString()}`)}),l.stderr.on("data",e=>{d+=e.toString(),console.log(`üè∑Ô∏è Title generation stderr: ${e.toString()}`)}),l.on("close",s=>{console.log(`üè∑Ô∏è Title generation process closed with code ${s}`),console.log(`üè∑Ô∏è Full output: "${c}"`),d&&console.log(`üè∑Ô∏è Error output: "${d}"`);try{const s=c.trim().split("\n"),n=s[s.length-1];console.log(`üè∑Ô∏è Parsing last line: "${n}"`);const r=JSON.parse(n),i=r.completion||r.result;if(i){let s=i.toLowerCase().replace(/[^\w\s]/g,"").trim().substring(0,30);if(s&&s.length>2){console.log(`üè∑Ô∏è Generated title: "${s}" - emitting to client`);const n=`title:${e}`;console.log(`üè∑Ô∏è Emitting event: ${n} with data:`,{title:s}),o.emit(n,{title:s}),t&&t()}else console.log(`üè∑Ô∏è Title too short or empty: "${s}"`)}else console.log("üè∑Ô∏è No title text in response:",r)}catch(e){console.error("üè∑Ô∏è Failed to parse title response:",e),console.error("üè∑Ô∏è Raw output was:",c)}}),l.on("error",e=>{console.error("üè∑Ô∏è Failed to spawn title generation process:",e)}),console.log("üè∑Ô∏è Writing prompt to stdin"),l.stdin.write(r),l.stdin.end()}catch(e){console.error("üè∑Ô∏è Failed to generate title:",e)}}const MAX_MESSAGE_HISTORY=1e3,MAX_LINE_BUFFER_SIZE=52428800;app.get("/health",(e,s)=>{s.json({status:"ok",pid:process.pid,service:"yurucode-claude",claudeCodeLoaded:!0})}),app.delete("/claude-project/:projectPath",async(e,s)=>{try{const{projectPath:o}=e.params,t=join(homedir(),".claude","projects",o);if(console.log("Deleting project:",t),!existsSync(t))return s.status(404).json({error:"project not found"});const{rm:n}=await import("fs/promises");await n(t,{recursive:!0,force:!0}),console.log("Project deleted successfully"),s.json({success:!0})}catch(e){console.error("Error deleting project:",e),s.status(500).json({error:"Failed to delete project",details:e.message})}}),app.delete("/claude-session/:projectPath/:sessionId",async(e,s)=>{try{const{projectPath:o,sessionId:t}=e.params,n=join(homedir(),".claude","projects",o,`${t}.jsonl`);if(console.log("Deleting session:",n),!existsSync(n))return s.status(404).json({error:"session not found"});const{unlink:r}=await import("fs/promises");await r(n),console.log("Session deleted successfully"),s.json({success:!0})}catch(e){console.error("Error deleting session:",e),s.status(500).json({error:"Failed to delete session",details:e.message})}}),app.get("/claude-session/:projectPath/:sessionId",async(e,s)=>{try{const{projectPath:o,sessionId:t}=e.params,n=join(homedir(),".claude","projects",o,`${t}.jsonl`);if(console.log("Loading session request:"),console.log("  - Raw projectPath:",o),console.log("  - SessionId:",t),console.log("  - Full path:",n),console.log("  - Platform:",platform()),!existsSync(n))return console.error("Session not found:",n),s.status(404).json({error:"session not found"});const{readFile:r}=await import("fs/promises");try{const i=await r(n,"utf8");console.log("Raw file content preview (first 200 chars):",i.substring(0,200).replace(/\n/g,"\\n").replace(/\r/g,"\\r")),console.log("Total file size:",i.length,"characters");const a=i[i.length-1];console.log("File ends with:","\n"===a?"newline":"$"===a?"dollar":"char: "+a);const l=[];let c=0,d=0,g=0,u=0;for(;c<i.length;){for(u++;c<i.length&&/\s/.test(i[c]);)c++;if(c>=i.length)break;if("{"!==i[c]){console.log("Warning: Expected { at position",c,"but found:",i[c]);const e=i.indexOf("\n",c);if(-1===e)break;c=e+1;continue}let s=0,o=!1,t=!1,n=-1;for(let e=c;e<i.length;e++){const r=i[e];if(t)t=!1;else if("\\"!==r)if('"'!==r||t){if(!o)if("{"===r)s++;else if("}"===r&&(s--,0===s)){if(!(e+1<i.length)){n=e+1;break}{const s=i[e+1];if("$"===s||"\n"===s||"\r"===s){n=e+1;break}}}}else o=!o;else t=!0}if(-1===n){console.log("Warning: Could not find end of JSON object starting at position",c);break}const r=i.substring(c,n);try{const e=JSON.parse(r);l.push(e),d++,d<=5&&("summary"===e.type?console.log(`Line ${u}: Added summary:`,(e.summary||"").substring(0,50)):"user"===e.type?console.log(`Line ${u}: Added user message`):"assistant"===e.type?console.log(`Line ${u}: Added assistant message`):e.sessionId&&console.log(`Line ${u}: Added session metadata`))}catch(e){g++,g<=5&&(console.log(`Failed to parse JSON at line ${u}, position ${c}:`,e.message),console.log("JSON preview:",r.substring(0,100)))}c=n,c<i.length&&"$"===i[c]&&c++,c<i.length&&"\n"===i[c]&&c++,c<i.length&&"\r"===i[c]&&c++}console.log(`Processed ${u} lines, successfully parsed ${d} JSON objects from session file`);const p=o.replace(/^([A-Z])--/,"$1:/").replace(/^-/,"/").replace(/-/g,"/");console.log(`Loaded session with ${l.length} messages`),console.log(`Converted project path: ${o} -> ${p}`),s.json({sessionId:t,projectPath:p,messages:l,sessionCount:l.length})}catch(e){console.error("Error reading session file:",e),s.status(500).json({error:"Failed to read session",details:e.message})}}catch(e){console.error("Error loading session:",e),s.status(500).json({error:"Failed to load session",details:e.message})}}),app.get("/claude-projects",async(e,s)=>{try{const e=join(homedir(),".claude","projects");if(console.log("Loading projects from:",e),console.log("Platform:",platform()),!existsSync(e))return console.log("Claude projects directory not found:",e),s.json({projects:[]});const{readdir:o,stat:t,readFile:n}=await import("fs/promises"),r=await o(e);console.log(`Found ${r.length} project directories`);const i=r.filter(e=>!e.startsWith(".")).map(async s=>{try{const r=join(e,s),i=await t(r);if(!i.isDirectory())return null;const a=(await o(r)).filter(e=>e.endsWith(".jsonl")).map(async e=>{try{const s=join(r,e),o=await t(s),i=e.replace(".jsonl","");let a="untitled session",l=0,c="";try{const e=(await n(s,"utf8")).split(/\r?\n/).filter(e=>e.trim());l=e.length;for(let s=0;s<Math.min(5,e.length);s++)try{const o=JSON.parse(e[s]);if(o.summary){a=o.summary;break}"user"===o.role&&o.content&&!c&&(c=o.content.slice(0,100))}catch{}"untitled session"===a&&c&&(a=c+(c.length>=100?"...":""))}catch(e){console.error("Error reading session file:",s,e)}return{id:i,summary:a,timestamp:o.mtime.getTime(),createdAt:o.birthtime?.getTime()||o.ctime?.getTime()||o.mtime.getTime(),path:s,messageCount:l}}catch(s){return console.error("Error processing session:",e,s),null}}),l=(await Promise.all(a)).filter(Boolean);if(0===l.length)return null;l.sort((e,s)=>s.timestamp-e.timestamp);const c=Math.min(...l.map(e=>e.createdAt||e.timestamp));return{path:s,name:s,sessions:l,lastModified:l[0]?.timestamp||i.mtime.getTime(),createdAt:c,sessionCount:l.length,totalMessages:l.reduce((e,s)=>e+(s.messageCount||0),0)}}catch(e){return console.error("Error processing project:",s,e),null}}),a=(await Promise.all(i)).filter(Boolean);a.sort((e,s)=>s.lastModified-e.lastModified),console.log(`Returning ${a.length} projects`),s.json({projects:a})}catch(e){console.error("Error loading projects:",e),s.status(500).json({error:"Failed to load projects",details:e.message})}}),app.get("/claude-projects-quick",async(e,s)=>{try{const o=parseInt(e.query.limit)||20,t=parseInt(e.query.offset)||0,n=join(homedir(),".claude","projects");if(console.log("Quick loading project list from:",n),!existsSync(n))return console.log("Claude projects directory not found:",n),s.json({projects:[],count:0});const{readdir:r,stat:i}=await import("fs/promises"),a=(await r(n)).filter(e=>!e.startsWith(".")).map(async e=>{try{const s=join(n,e),o=await i(s);return o.isDirectory()?{path:e,name:e,sessionCount:(await r(s)).filter(e=>e.endsWith(".jsonl")).length,lastModified:o.mtime.getTime()}:null}catch{return null}}),l=(await Promise.all(a)).filter(Boolean);l.sort((e,s)=>s.lastModified-e.lastModified);const c=l.length,d=l.slice(t,t+o);console.log(`Quick loaded ${d.length} of ${c} project names (offset: ${t}, limit: ${o})`),s.json({projects:d,count:c})}catch(e){console.error("Error quick loading projects:",e),s.status(500).json({error:"Failed to load projects",details:e.message})}}),app.get("/claude-project-sessions/:projectName",async(e,s)=>{const o=parseInt(e.query.offset)||0,t=parseInt(e.query.limit)||10;try{const n=decodeURIComponent(e.params.projectName);console.log("üìÇ Loading sessions for project:",n),s.writeHead(200,{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"});const r=join(homedir(),".claude","projects"),i=join(r,n);if(!existsSync(i))return s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();const{readdir:a,stat:l,readFile:c}=await import("fs/promises"),d=(await a(i)).filter(e=>e.endsWith(".jsonl")).slice(0,50);if(0===d.length)return s.write('data: {"done": true, "sessions": []}\n\n'),void s.end();const g=await Promise.all(d.map(async e=>{const s=join(i,e);return{filename:e,path:s,timestamp:(await l(s)).mtime.getTime()}}));g.sort((e,s)=>s.timestamp-e.timestamp);const u=g.slice(o,o+t);for(let n=0;n<u.length;n++){const{filename:r,path:i,timestamp:a}=u[n];try{const e=r.replace(".jsonl","");let l="Untitled session",d=null,u=0;const p=(await c(i,"utf8")).split(/\r?\n/).filter(e=>e.trim());u=p.length;for(let e=0;e<Math.min(5,p.length);e++)try{const s=JSON.parse(p[e]);if(s.summary){l=s.summary;break}s.title&&(d=s.title),"user"===s.role&&s.content&&"Untitled session"===l&&(l=s.content.slice(0,100),s.content.length>100&&(l+="..."))}catch{}if(p.length>0)try{const e=JSON.parse(p[p.length-1]);e.title&&(d=e.title)}catch{}const m={id:e,summary:l,title:d,timestamp:a,path:r,messageCount:Math.min(u,50)};s.write(`data: ${JSON.stringify({session:m,index:o+n,total:g.length,hasMore:o+t<g.length})}\n\n`),console.log(`  üìÑ Sent session ${o+n+1}/${g.length}: ${e}`)}catch(e){console.log(`Error processing ${r}:`,e.message)}}s.write(`data: ${JSON.stringify({done:!0,totalCount:g.length,hasMore:o+t<g.length})}\n\n`),console.log(`‚úÖ Streamed ${u.length} sessions (offset: ${o}, total: ${g.length})`),s.end()}catch(e){console.error("Error loading project sessions:",e),s.write(`data: {"error": true, "message": "${e.message}"}\n\n`),s.end()}}),app.get("/claude-project-date/:projectName",async(e,s)=>{try{const o=decodeURIComponent(e.params.projectName);console.log(`üìÖ Getting date for project: ${o}`);const t=join(homedir(),".claude","projects"),n=join(t,o);if(!existsSync(n))return s.json({projectName:o,lastModified:Date.now()});const{readdir:r,stat:i}=await import("fs/promises"),a=(await r(n)).filter(e=>e.endsWith(".jsonl"));if(0===a.length){const e=await i(n);return s.json({projectName:o,lastModified:e.mtime.getTime()})}const l=await Promise.all(a.map(async e=>{const s=join(n,e);return(await i(s)).mtime.getTime()})),c=Math.max(...l),d=new Date(c);console.log(`  ‚úÖ ${o}: ${d.toLocaleString()}`),s.json({projectName:o,lastModified:c})}catch(o){console.error("Error getting project date:",o),s.json({projectName:e.params.projectName,lastModified:Date.now()})}}),app.get("/claude-project-session-count/:projectName",async(e,s)=>{try{const o=decodeURIComponent(e.params.projectName),t=join(homedir(),".claude","projects"),n=join(t,o);if(!existsSync(n))return s.json({projectName:o,sessionCount:0});const{readdir:r}=await import("fs/promises"),i=(await r(n)).filter(e=>e.endsWith(".jsonl")).length;s.json({projectName:o,sessionCount:i})}catch(o){console.error("Error getting session count:",o),s.json({projectName:e.params.projectName,sessionCount:0})}}),app.get("/claude-analytics",async(e,s)=>{console.log("üìä Loading analytics from all Claude sessions...");try{const o={totalSessions:0,totalMessages:0,totalTokens:0,totalCost:0,byModel:{opus:{sessions:0,tokens:0,cost:0},sonnet:{sessions:0,tokens:0,cost:0}},byDate:{},byProject:{}},{readdir:t,readFile:n,stat:r}=await import("fs/promises"),i=join(homedir(),".claude","projects");try{const s=await t(i);for(const a of s){const s=join(i,a);if(!(await r(s)).isDirectory())continue;const l=(await t(s)).filter(e=>e.endsWith(".jsonl"));for(const t of l)try{const r=join(s,t),i=(await n(r,"utf8")).split("\n").filter(e=>e.trim());let l=0,c=0,d="sonnet",g=(new Date).toISOString().split("T")[0],u=0;for(const s of i)try{const e=JSON.parse(s);if("assistant"===e.type&&e.message&&e.message.usage){u++;const s=e.message.usage,o=s.input_tokens||0,t=s.output_tokens||0;l+=o+t,e.message.model&&(d=e.message.model.includes("opus")?"opus":"sonnet");const n="opus"===d;c+=o*(n?15e-6:3e-6)+t*(n?75e-6:15e-6)}"user"===e.type&&u++,e.timestamp&&(g=new Date(e.timestamp).toISOString().split("T")[0])}catch(e){}if(l>0||u>0){o.totalSessions++,o.totalMessages+=u,o.totalTokens+=l,o.totalCost+=c,"opus"===d?(o.byModel.opus.sessions++,o.byModel.opus.tokens+=l,o.byModel.opus.cost+=c):(o.byModel.sonnet.sessions++,o.byModel.sonnet.tokens+=l,o.byModel.sonnet.cost+=c),o.byDate[g]||(o.byDate[g]={sessions:0,messages:0,tokens:0,cost:0}),o.byDate[g].sessions++,o.byDate[g].messages+=u,o.byDate[g].tokens+=l,o.byDate[g].cost+=c;const e=a.replace(/-\d{4}-\d{2}-\d{2}.*$/,"");o.byProject[e]||(o.byProject[e]={sessions:0,messages:0,tokens:0,cost:0,lastUsed:Date.now()}),o.byProject[e].sessions++,o.byProject[e].messages+=u,o.byProject[e].tokens+=l,o.byProject[e].cost+=c}}catch(e){console.error(`Error processing session ${t}:`,e.message)}}}catch(e){console.error("Error reading projects directory:",e.message)}console.log(`üìä Analytics loaded: ${o.totalSessions} sessions, ${o.totalTokens} tokens`),s.json(o)}catch(e){console.error("Error loading analytics:",e),s.status(500).json({error:"Failed to load analytics",details:e.message})}});const pidFilePath=process.env.ELECTRON_RUN_AS_NODE?join(homedir(),`.yurucode-server-${PORT}.pid`):join(__dirname,`server-${PORT}.pid`);function writePidFile(){try{writeFileSync(pidFilePath,process.pid.toString()),console.log(`üìù Server PID ${process.pid} written to ${pidFilePath}`)}catch(e){console.log("‚ö†Ô∏è Could not write PID file (running from read-only location?):",e.message)}}function removePidFile(){try{fs.existsSync(pidFilePath)&&(fs.unlinkSync(pidFilePath),console.log("üóëÔ∏è Removed PID file"))}catch(e){}}process.on("SIGINT",()=>{console.log("\nüõë Server shutting down..."),removePidFile(),process.exit(0)}),process.on("SIGTERM",()=>{console.log("\nüõë Server terminated"),removePidFile(),process.exit(0)}),process.on("exit",()=>{removePidFile()}),process.on("uncaughtException",e=>{console.error("üí• Uncaught exception:",e),removePidFile(),process.exit(1)}),process.on("unhandledRejection",(e,s)=>{console.error("üí• Unhandled rejection at:",s,"reason:",e),removePidFile(),process.exit(1)}),io.on("connection",e=>{function s(){if(processSpawnQueue.length>0){const e=processSpawnQueue.shift();console.log(`üîÑ Processing next spawn request. Remaining in queue: ${processSpawnQueue.length}`),e()}}console.log("üîå Client connected:",e.id),e.on("createSession",async(s,o)=>{try{const t=`session-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;console.log(`‚ú® Creating new session: ${t}`);const n=join(homedir(),".yurucode","sandbox",t);mkdirSync(n,{recursive:!0});const r=s.workingDirectory||n,i={id:t,name:s.name||"new session",socketId:e.id,workingDirectory:r,messages:[],createdAt:Date.now(),claudeSessionId:null,hasGeneratedTitle:!1,wasInterrupted:!1};sessions.set(t,i),console.log(`‚úÖ Session ready: ${t}`),console.log(`üìÅ Working directory: ${r}`),o&&o({success:!0,sessionId:t,workingDirectory:r})}catch(e){console.error("‚ùå Error creating session:",e),o&&o({success:!1,error:e.message})}}),e.on("sendMessage",async(o,t)=>{const{sessionId:n,content:r,model:i}=o;console.log(`üì® sendMessage called for session: ${n}`),console.log(`üìä Current sessions in memory: ${sessions.size}`),console.log("üîç Available session IDs:",Array.from(sessions.keys()));let a=sessions.get(n);if(!a)return console.error(`‚ùå Session not found: ${n}`),void(t&&t({success:!1,error:"Session not found"}));console.log(`[${n}] Using model: ${i} (type: ${typeof i})`);const l=async()=>{try{if(console.log("\nüì® Processing message request:",{sessionId:n,messageLength:r?.length||0,model:i,queueLength:processSpawnQueue.length}),activeProcesses.has(n)){const o=activeProcesses.get(n),t=activeProcessStartTimes.get(n)||Date.now(),r=Date.now()-t;if(r<3e3)return console.log(`‚è≥ Process for session ${n} is only ${r}ms old, queueing message instead of killing`),e.emit(`message:${n}`,{type:"system",subtype:"info",message:"processing previous message, will send yours next...",timestamp:Date.now()}),void setTimeout(()=>{processSpawnQueue.push(l),s()},2e3);if(console.log(`‚ö†Ô∏è Killing existing process for session ${n} (PID: ${o.pid}, age: ${r}ms)`),"win32"!==process.platform&&o.pid)try{process.kill(-o.pid,"SIGINT")}catch(e){o.kill("SIGINT")}else o.kill("SIGINT");activeProcesses.delete(n),activeProcessStartTimes.delete(n),a.wasInterrupted=!0,console.log(`üîÑ Marked session ${n} as interrupted but keeping claudeSessionId=${a.claudeSessionId} for resume`),await new Promise(e=>setTimeout(e,500))}let o=a.workingDirectory||join(homedir(),".yurucode","sandbox",n);console.log(`üìÇ Using working directory: ${o}`);const c=["--print","--output-format","stream-json","--verbose","--dangerously-skip-permissions","--append-system-prompt","CRITICAL: you are in yurucode ui. ALWAYS: use all lowercase (no capitals ever), be extremely concise, never use formal language, no greetings/pleasantries, straight to the point, code/variables keep proper case, one line answers preferred. !!YOU MUST PLAN FIRST use THINK and TODO as MUCH AS POSSIBLE to break down everything, including planning into multiple steps and do edits in small chunks!!"];i&&(c.push("--model",i),console.log(`ü§ñ Using model: ${i}`)),console.log(`üîç Session state check: claudeSessionId=${a.claudeSessionId}, wasInterrupted=${a.wasInterrupted}`),a.claudeSessionId?(c.push("--resume",a.claudeSessionId),console.log("üîÑ Using --resume flag with session:",a.claudeSessionId),a.wasInterrupted&&(console.log("üìù Resuming after interrupt"),a.wasInterrupted=!1)):console.log("üìù Starting fresh conversation (no previous session)"),console.log("üöÄ Spawning claude with args:",c),console.log(`üîç Active processes count: ${activeProcesses.size}`);const d={...process.env},g="/opt/homebrew/bin";if(d.PATH?.includes(g)||(d.PATH=`${g}:${d.PATH||"/usr/bin:/bin"}`,console.log(`üîß Added ${g} to PATH for Claude CLI`)),d.CLAUDE_SESSION_ID=n,d.CLAUDE_INSTANCE=`${Date.now()}-${Math.random().toString(36).substr(2,9)}`,d.PWD=o,d.HOME=homedir(),console.log(`üîß Set PWD=${o} and HOME=${homedir()} in environment`),isSpawningProcess&&(console.log("‚è≥ Waiting for previous Claude process to initialize..."),await new Promise(e=>setTimeout(e,200))),isSpawningProcess=!0,!existsSync(o)){console.warn(`‚ö†Ô∏è Working directory does not exist: ${o}, creating safe sandbox`);const e=join(homedir(),".yurucode","sandbox",n);mkdirSync(e,{recursive:!0}),o=e}const u={cwd:o,env:d,shell:!0,windowsHide:!0,detached:!0,stdio:["pipe","pipe","pipe"]};console.log("üöÄ Spawning claude process with options:",{cwd:u.cwd,claudePath:CLAUDE_PATH,args:c});const p=isWindows&&"WSL_CLAUDE"===CLAUDE_PATH?(()=>{if(!WSL_AVAILABLE){console.error("‚ùå WSL is not available on this system. Please install WSL or Claude CLI for Windows.");const s=new(require("events").EventEmitter);return s.stdin={write:()=>{},end:()=>{}},s.stdout=new(require("events").EventEmitter),s.stderr=new(require("events").EventEmitter),s.pid=-1,s.kill=()=>{},setTimeout(()=>{const o=new Error("WSL is not installed. Please install WSL and Claude CLI in WSL, or install Claude CLI for Windows.");e.emit(`error:${n}`,{error:o.message,sessionId:n,timestamp:Date.now()}),s.emit("error",o),s.emit("exit",1)},100),s}let s=o;o&&o.match(/^[A-Z]:\\/)&&(s=`/mnt/${o[0].toLowerCase()}${o.substring(2).replace(/\\/g,"/")}`,console.log(`üìÇ Converted Windows path to WSL: ${o} -> ${s}`));const[t,r]=createWslClaudeCommand(c,s);return console.log(`üöÄ Running WSL: ${t}`),console.log("üöÄ WSL args:",r),spawn(t,r,u)})():spawn(CLAUDE_PATH,c,u);if(setTimeout(()=>{isSpawningProcess=!1},500),activeProcesses.set(n,p),activeProcessStartTimes.set(n,Date.now()),"win32"!==process.platform&&p.unref(),r){let e=r;if("ultrathink"!==r.trim().toLowerCase()&&"ultrathink."!==r.trim().toLowerCase()||(e='I need you to engage in deep, extended thinking about a complex problem. Show your complete thought process.\n\nThink step by step through this problem:\n"What are the most interesting and non-obvious connections between quantum mechanics, consciousness, and information theory? Explore multiple perspectives and challenge conventional assumptions."\n\nUse <thinking> tags extensively to show your reasoning process.',console.log("üß† ULTRATHINK mode activated - triggering extended thinking demonstration")),e+="\n",console.log(`üìù Sending message to claude (${e.length} chars)`),isWindows&&"WSL_CLAUDE"===CLAUDE_PATH){const s=4096;let o=0;const t=()=>{if(o<e.length){const n=e.substring(o,o+s);p.stdin.write(n,e=>{e?(console.error("‚ùå Error writing to stdin:",e),p.stdin.end()):(o+=s,setTimeout(t,10))})}else p.stdin.end()};setTimeout(t,500)}else p.stdin.write(e),p.stdin.end()}if(console.log(`üè∑Ô∏è Title check: hasGeneratedTitle=${a.hasGeneratedTitle}, messageLength=${r?.length}`),!a.hasGeneratedTitle&&r&&r.length>5){let s=r;try{const e=JSON.parse(r);if(Array.isArray(e)){const o=e.filter(e=>"text"===e.type);s=o.map(e=>e.text).join(" "),console.log(`üè∑Ô∏è Extracted text from JSON: "${s.substring(0,50)}..."`)}}catch(e){console.log(`üè∑Ô∏è Using plain text content: "${s.substring(0,50)}..."`)}s&&s.trim().length>5?(console.log(`üè∑Ô∏è Calling generateTitle for session ${n}`),generateTitle(n,s,e,()=>{console.log(`üè∑Ô∏è Title successfully generated for session ${n}`),a.hasGeneratedTitle=!0}),setTimeout(()=>{a.hasGeneratedTitle||(console.log(`üè∑Ô∏è Retrying title generation for session ${n}`),generateTitle(n,s,e,()=>{a.hasGeneratedTitle=!0}))},5e3)):console.log(`üè∑Ô∏è Skipping title generation - text too short: "${s}"`)}let m="",h=0,f=0,y=Date.now(),$=Date.now();streamHealthChecks.has(n)&&clearInterval(streamHealthChecks.get(n)),streamTimeouts.has(n)&&clearTimeout(streamTimeouts.get(n));const w=setInterval(()=>{const s=Date.now()-y,o=Date.now()-$;console.log(`ü©∫ [${n}] duration: ${o}ms | since_last: ${s}ms | bytes: ${f} | msgs: ${h} | buffer: ${m.length} | alive: ${activeProcesses.has(n)}`),s>3e4&&(console.error(`‚ö†Ô∏è WARNING: No data received for ${s}ms!`),e.emit(`keepalive:${n}`,{timestamp:Date.now()})),s>3e5&&(console.error(`üíÄ Stream appears dead after ${s}ms, cleaning up`),activeProcesses.has(n)&&(activeProcesses.get(n).kill("SIGTERM"),activeProcesses.delete(n),activeProcessStartTimes.delete(n)),clearInterval(w))},5e3);streamHealthChecks.set(n,w);let S=!1;const v=setTimeout(()=>{if(console.warn(`‚è∞ Stream timeout reached for session ${n} after 10 minutes`),activeProcesses.has(n)){const e=activeProcesses.get(n);console.log(`‚è∞ Terminating long-running process for ${n}`),e.kill("SIGTERM")}},6e5);streamTimeouts.set(n,v);const I=s=>{if(S)console.log(`üî∏ [${n}] Skipping line processing - retry in progress`);else if(s.trim()){console.log(`üîπ [${n}] Processing line (${s.length} chars): ${s.substring(0,100)}...`);try{const o=JSON.parse(s);if(console.log(`üì¶ [${n}] Message type: ${o.type}${o.subtype?` (${o.subtype})`:""}`),o.session_id&&(a.claudeSessionId=o.session_id,console.log(`üìå [${n}] Claude session ID: ${a.claudeSessionId}`)),"system"===o.type&&"init"===o.subtype)e.emit(`message:${n}`,{type:"system",subtype:"init",message:o,timestamp:Date.now()});else if("assistant"===o.type){const s=`assistant-${n}-${Date.now()}-${Math.random()}`;if(o.message?.content){let t=!1,r=[],i=!1;for(const s of o.message.content)"text"===s.type||"thinking"===s.type?(t=!0,r.push(s)):"tool_use"===s.type&&(i=!0,["Edit","Write","MultiEdit","NotebookEdit"].includes(s.name)&&(activeFileOperations.has(n)||activeFileOperations.set(n,new Set),activeFileOperations.get(n).add(s.id),console.log(`üìù [${n}] Started file operation: ${s.name} (${s.id})`)),e.emit(`message:${n}`,{type:"tool_use",message:{name:s.name,input:s.input,id:s.id},timestamp:Date.now(),id:`tool-${n}-${Date.now()}`}));if(t&&r.length>0){lastAssistantMessageIds.set(n,s);const o=sessions.get(n);if(o?.pendingInterrupt){console.log(`üîÑ [${n}] Claude started responding - executing queued interrupt`);const s=o.interruptCallback;return o.pendingInterrupt=!1,o.interruptCallback=null,void setTimeout(()=>{console.log(`üõë [${n}] Executing queued interrupt now`);const process=activeProcesses.get(n);if(process){if("win32"!==process.platform&&process.pid)try{process.kill(-process.pid,"SIGINT")}catch(e){process.kill("SIGINT")}else process.kill("SIGINT");activeProcesses.delete(n),activeProcessStartTimes.delete(n),lastAssistantMessageIds.delete(n),o&&(o.wasInterrupted=!0),e.emit(`message:${n}`,{type:"system",subtype:"interrupted",message:"task interrupted by user",timestamp:Date.now()}),s&&s({success:!0})}},100)}if(allAssistantMessageIds.has(n)||allAssistantMessageIds.set(n,[]),allAssistantMessageIds.get(n).push(s),console.log(`üìù [${n}] Emitting assistant message ${s} with streaming=true`),console.log(`üìù [${n}] Content blocks: ${r.length} (types: ${r.map(e=>e.type).join(", ")})`),e.emit(`message:${n}`,{type:"assistant",message:{content:r},streaming:!0,id:s,timestamp:Date.now()}),o.messages.push({type:"assistant",message:{content:r},id:s,timestamp:Date.now()}),o.messages.length>1e3){const e=Math.floor(200);o.messages.splice(0,e),console.log(`üßπ Trimmed ${e} old messages from session ${n}`)}h++}else i&&!t&&console.log("Assistant message with only tool uses, skipping text message")}}else if("user"===o.type&&o.message?.content){for(const s of o.message.content)if("tool_result"===s.type){if(activeFileOperations.has(n)){const e=activeFileOperations.get(n);e.has(s.tool_use_id)&&(e.delete(s.tool_use_id),console.log(`‚úÖ [${n}] Completed file operation: ${s.tool_use_id}`),0===e.size&&activeFileOperations.delete(n))}e.emit(`message:${n}`,{type:"tool_result",message:{tool_use_id:s.tool_use_id,content:s.content,is_error:s.is_error},timestamp:Date.now(),id:`toolresult-${n}-${Date.now()}`})}}else if("result"===o.type){console.log("üì¶ Message type: result"),console.log(`   ‚úÖ Result: success=${!o.is_error}, duration=${o.duration_ms}ms`),o.usage&&(console.log("\nüìä TOKEN USAGE FROM CLAUDE CLI:"),console.log(`   input_tokens: ${o.usage.input_tokens||0}`),console.log(`   output_tokens: ${o.usage.output_tokens||0}`),console.log(`   cache_creation_input_tokens: ${o.usage.cache_creation_input_tokens||0}`),console.log(`   cache_read_input_tokens: ${o.usage.cache_read_input_tokens||0}`));const s=allAssistantMessageIds.get(n)||[];if(s.length>0){console.log(`‚úÖ Marking ${s.length} assistant messages as streaming=false (result received)`);const o=sessions.get(n);s.forEach(s=>{const t=o?.messages.find(e=>e.id===s);console.log(`‚úÖ Marking assistant message ${s} as streaming=false`),e.emit(`message:${n}`,{type:"assistant",id:s,message:t?.message||{content:""},streaming:!1,timestamp:Date.now()})}),allAssistantMessageIds.delete(n),lastAssistantMessageIds.delete(n),allAssistantMessageIds.delete(n)}console.log(`‚úÖ [${n}] Sending result message with model: ${i}`);const t={type:"result",...o,streaming:!1,id:`result-${n}-${Date.now()}`,model:i||"unknown"};console.log(`   - Model in result message: ${t.model}`),e.emit(`message:${n}`,t),h++}}catch(e){console.log(`‚ö†Ô∏è [${n}] Failed to parse JSON, treating as plain text:`,e.message),console.log(`‚ö†Ô∏è [${n}] Line was: ${s}`)}}else console.log(`üî∏ [${n}] Empty line received`)};p.stdout.on("data",e=>{const s=e.toString();if(f+=e.length,y=Date.now(),console.log(`üì• [${n}] STDOUT received: ${s.length} bytes (total: ${f})`),console.log(`üì• [${n}] Data preview: ${s.substring(0,200).replace(/\n/g,"\\n")}...`),m.length>52428800){console.error(`‚ö†Ô∏è [${n}] Line buffer overflow (${m.length} bytes), processing and clearing`);const s=m.split("\n");console.log(`‚ö†Ô∏è [${n}] Processing ${s.length} buffered lines`);for(const o of s)if(o.trim())try{I(o)}catch(e){console.error(`[${n}] Failed to process line during overflow:`,e)}m=""}m+=s;const o=m.split("\n");m=o.pop()||"",console.log(`üìã [${n}] Split into ${o.length} lines, buffer remaining: ${m.length} chars`);for(let e=0;e<o.length;e++)console.log(`üìã [${n}] Processing line ${e+1}/${o.length}`),I(o[e])}),p.stderr.on("data",s=>{const o=s.toString();if(console.error(`‚ö†Ô∏è [${n}] Claude stderr (${s.length} bytes):`,o),y=Date.now(),o.includes("No conversation found with session ID")&&!S){S=!0,console.log("üîÑ Resume failed - session not found in Claude storage"),console.log("üîÑ Clearing invalid session ID - will use fresh conversation on next message"),a.claudeSessionId=null,a.wasInterrupted=!1,p&&!p.killed&&(console.log(`üõë Killing failed resume process (PID: ${p.pid})`),p.stdout.removeAllListeners(),p.stderr.removeAllListeners(),p.removeAllListeners(),p.kill("SIGINT")),activeProcesses.delete(n),activeProcessStartTimes.delete(n),streamHealthChecks.has(n)&&(clearInterval(streamHealthChecks.get(n)),streamHealthChecks.delete(n)),streamTimeouts.has(n)&&(clearTimeout(streamTimeouts.get(n)),streamTimeouts.delete(n));const s={id:`result-error-${Date.now()}-${Math.random()}`,type:"result",subtype:"error",is_error:!0,error:"Session not found - please try sending your message again",requiresCheckpointRestore:!0,streaming:!1,timestamp:Date.now()},o=`message:${n}`;return console.log(`üì§ [${n}] Emitting error result with checkpoint restore flag`),e.emit(o,s),void console.log(`üì§ [${n}] Sent checkpoint restore signal - frontend should resend message`)}e.emit(`message:${n}`,{type:"error",error:o,claudeSessionId:a.claudeSessionId,streaming:!1})}),p.on("close",s=>{streamHealthChecks.has(n)&&(clearInterval(streamHealthChecks.get(n)),streamHealthChecks.delete(n));const o=sessions.get(n);o?.pendingInterrupt&&(console.log(`üßπ [${n}] Cleaning up pending interrupt on process close`),o.interruptCallback&&o.interruptCallback({success:!1,error:"Process ended before interrupt could execute"}),o.pendingInterrupt=!1,o.interruptCallback=null),streamTimeouts.has(n)&&(clearTimeout(streamTimeouts.get(n)),streamTimeouts.delete(n)),clearInterval(w),activeFileOperations.has(n)&&(activeFileOperations.delete(n),console.log(`üßπ Cleared file operations tracking for session ${n} on process close`));const t=Date.now()-$;if(console.log(`üëã [${n}] Claude process exited with code ${s}`),console.log(`üìä [${n}] STREAM SUMMARY:`),console.log(`   ‚îú‚îÄ Total duration: ${t}ms`),console.log(`   ‚îú‚îÄ Total bytes: ${f}`),console.log(`   ‚îú‚îÄ Messages: ${h}`),console.log(`   ‚îî‚îÄ Exit code: ${s}`),activeProcesses.delete(n),activeProcessStartTimes.delete(n),0===s){const e=sessions.get(n);e&&!e.wasInterrupted?(e.wasInterrupted=!1,console.log(`‚úÖ Marked session ${n} as completed normally`)):e&&e.wasInterrupted&&console.log(`‚ö†Ô∏è Session ${n} exited with code 0 but was interrupted - keeping wasInterrupted=true`)}else if(1===s){const e=sessions.get(n);e&&e.claudeSessionId&&(console.log("‚ö†Ô∏è Process exited with code 1 - likely resume failed, clearing session ID"),e.claudeSessionId=null,e.wasInterrupted=!1)}if(m.trim())try{I(m)}catch(e){console.error("Failed to process remaining buffer:",e)}const r=lastAssistantMessageIds.get(n);if(r){console.log(`üî¥ Forcing streaming=false for assistant message ${r} on process exit`);const s=sessions.get(n),o=s?.messages.find(e=>e.id===r);e.emit(`message:${n}`,{type:"assistant",id:r,message:o?.message||{content:""},streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(n),allAssistantMessageIds.delete(n)}e.emit(`message:${n}`,{type:"system",subtype:"stream_end",streaming:!1,timestamp:Date.now()}),null===s||-2===s||"SIGKILL"===s?(console.error(`‚ö†Ô∏è Claude process terminated unexpectedly (code: ${s})`),e.emit(`message:${n}`,{type:"error",error:"session terminated unexpectedly. you can resume by sending another message.",streaming:!1,timestamp:Date.now()})):0!==s&&(console.error(`Claude process failed with exit code ${s}`),e.emit(`message:${n}`,{type:"system",subtype:"info",message:`process completed with code ${s}`,timestamp:Date.now()}))}),p.on("error",s=>{streamHealthChecks.has(n)&&(clearInterval(streamHealthChecks.get(n)),streamHealthChecks.delete(n));const o=sessions.get(n);o?.pendingInterrupt&&(console.log(`üßπ [${n}] Cleaning up pending interrupt on process error`),o.interruptCallback&&o.interruptCallback({success:!1,error:"Process error occurred before interrupt could execute"}),o.pendingInterrupt=!1,o.interruptCallback=null),streamTimeouts.has(n)&&(clearTimeout(streamTimeouts.get(n)),streamTimeouts.delete(n)),clearInterval(w),console.error(`‚ùå [${n}] Failed to spawn claude:`,s),console.error(`‚ùå [${n}] Error details:`,{message:s.message,code:s.code,syscall:s.syscall,path:s.path});const r=lastAssistantMessageIds.get(n);if(r){console.log(`üî¥ Forcing streaming=false for assistant message ${r} on process error`);const s=sessions.get(n),o=s?.messages.find(e=>e.id===r);e.emit(`message:${n}`,{type:"assistant",id:r,message:o?.message||{content:""},streaming:!1,timestamp:Date.now()})}e.emit(`message:${n}`,{type:"error",error:`claude process error: ${s.message}. try sending your message again.`,claudeSessionId:o.claudeSessionId,streaming:!1}),activeProcesses.delete(n),activeProcessStartTimes.delete(n),lastAssistantMessageIds.delete(n),t&&t({success:!1,error:s.message})}),t&&t({success:!0})}catch(s){console.error("‚ùå Error in spawnRequest:",s),e.emit(`message:${n}`,{type:"error",error:s.message,claudeSessionId:a.claudeSessionId,streaming:!1}),t&&t({success:!1,error:s.message})}finally{s()}};processSpawnQueue.push(l),console.log(`üìã Added request to queue. Queue length: ${processSpawnQueue.length}`),1===processSpawnQueue.length&&s()}),e.on("interrupt",({sessionId:s},o)=>{console.log(`üõë INTERRUPT received for session ${s}`);const process=activeProcesses.get(s),t=sessions.get(s),n=lastAssistantMessageIds.has(s);if(process&&!n)return console.log(`‚è≥ [${s}] Claude hasn't started responding yet, queueing interrupt for when it does...`),void(t&&!t.pendingInterrupt?(t.pendingInterrupt=!0,t.interruptCallback=o,console.log(`üìå [${s}] Interrupt queued - will trigger when Claude starts responding`)):t||(console.log(`‚ö†Ô∏è [${s}] No session found, cannot queue interrupt`),o&&o({success:!1,error:"Session not found"})));const r=activeFileOperations.get(s);if(r&&r.size>0){console.log(`‚è≥ [${s}] Waiting for ${r.size} file operation(s) to complete before interrupting...`);const e=5e3,o=100;let t=0;const n=setInterval(()=>{t+=o;const r=activeFileOperations.get(s);(!r||0===r.size||t>=e)&&(clearInterval(n),t>=e?console.log(`‚ö†Ô∏è [${s}] Timeout waiting for file operations, interrupting anyway`):console.log(`‚úÖ [${s}] File operations completed, proceeding with interrupt`),i())},o);return}function i(){const n=processSpawnQueue.length;if(n>0&&(processSpawnQueue.length=0,console.log(`üßπ Cleared ${n} queued messages after interrupt`)),t&&(t.pendingInterrupt=!1,t.interruptCallback=null),process){if(console.log(`üõë Found active process for session ${s} (PID: ${process.pid})`),"win32"!==process.platform&&process.pid)try{process.kill(-process.pid,"SIGINT")}catch(e){process.kill("SIGINT")}else process.kill("SIGINT");activeProcesses.delete(s),activeProcessStartTimes.delete(s),t?(console.log(`üîÑ Marking session ${s} as interrupted (claudeSessionId: ${t.claudeSessionId})`),t.wasInterrupted=!0,console.log(`üîÑ Session ${s} interrupted - marked wasInterrupted=true for followup`)):console.log(`‚ö†Ô∏è No session found for ${s} during interrupt`);const n=lastAssistantMessageIds.get(s);n&&(e.emit(`message:${s}`,{type:"assistant",id:n,streaming:!1,timestamp:Date.now()}),lastAssistantMessageIds.delete(s)),e.emit(`message:${s}`,{type:"system",subtype:"interrupted",message:"task interrupted by user",timestamp:Date.now()}),o&&o({success:!0})}else console.log(`‚ö†Ô∏è No active process found for session ${s} during interrupt`),o&&o({success:!0});activeFileOperations.has(s)&&(activeFileOperations.delete(s),console.log(`üßπ Cleared file operations tracking for session ${s}`))}i()}),e.on("clearSession",({sessionId:s})=>{const o=sessions.get(s);if(!o)return void console.error(`Session not found: ${s}`);const process=activeProcesses.get(s);process&&(console.log(`üõë Killing process for cleared session ${s}`),process.kill("SIGINT"),activeProcesses.delete(s),activeProcessStartTimes.delete(s)),o.messages=[],o.claudeSessionId=null,o.hasGeneratedTitle=!1,o.wasInterrupted=!1,lastAssistantMessageIds.delete(s),console.log(`‚úÖ Session ${s} cleared - will start fresh Claude session on next message`),e.emit(`message:${s}`,{type:"system",subtype:"clear",message:"session cleared",timestamp:Date.now()});const t=`title:${s}`;console.log(`üè∑Ô∏è Emitting title reset for cleared session: ${t}`),e.emit(t,{title:"new session"})}),e.on("deleteSession",async(e,s)=>{const{sessionId:o}=e;sessions.delete(o),lastAssistantMessageIds.delete(o),s({success:!0})}),e.on("disconnect",()=>{console.log("üîå Client disconnected:",e.id);for(const[s,o]of sessions.entries())if(o.socketId===e.id){streamHealthChecks.has(s)&&(clearInterval(streamHealthChecks.get(s)),streamHealthChecks.delete(s)),streamTimeouts.has(s)&&(clearTimeout(streamTimeouts.get(s)),streamTimeouts.delete(s));const process=activeProcesses.get(s);process&&(console.log(`üßπ Cleaning up process for session ${s}`),process.kill("SIGINT"),activeProcesses.delete(s),activeProcessStartTimes.delete(s)),lastAssistantMessageIds.delete(s)}})}),httpServer.listen(PORT,()=>{writePidFile(),console.log(`üöÄ yurucode server running on port ${PORT}`),console.log(`üìÇ Working directory: ${process.cwd()}`),console.log(`üñ•Ô∏è Platform: ${platform()}`),console.log(`üè† Home directory: ${homedir()}`),console.log(`üìÅ Claude projects: ${join(homedir(),".claude","projects")}`);const e=join(homedir(),".claude","projects");if(existsSync(e)){console.log("‚úÖ Claude projects directory exists");try{const{readdirSync:s}=require("fs"),o=s(e);console.log(`üìä Found ${o.length} project directory(s)`),o.length>0&&"win32"===platform()&&(console.log("üîç Sample project paths (first 3):"),o.slice(0,3).forEach(e=>{if(console.log(`  - ${e}`),e.match(/^[A-Z]--/)){const s=e.replace(/^([A-Z])--/,"$1:/").replace(/-/g,"/");console.log(`    ‚Üí Would convert to: ${s}`)}}))}catch(e){console.log("‚ö†Ô∏è Could not list projects:",e.message)}}else console.log("‚ö†Ô∏è Claude projects directory not found at:",e);console.log(`‚úÖ Server configured for ${"win32"===platform()?"Windows":platform()}`),console.log("üî• Warming up bash execution...");const s=spawn("echo",["warmup"],{shell:!1,stdio:"pipe"});s.on("close",()=>{console.log("‚úÖ Bash warmup complete")}),s.on("error",e=>{console.warn("‚ö†Ô∏è Bash warmup failed:",e.message)})}),httpServer.on("error",e=>{if("EADDRINUSE"===e.code){console.error(`‚ùå Port ${PORT} is already in use`),console.log("Attempting to kill existing process and retry...");const{exec:e}=require("child_process");e(`lsof -ti :${PORT} | xargs kill -9`,e=>{e?(console.error("Failed to kill existing process. Please restart the app."),process.exit(1)):(console.log("Killed existing process, retrying in 1 second..."),setTimeout(()=>{httpServer.listen(PORT)},1e3))})}else console.error("Server error:",e),process.exit(1)});