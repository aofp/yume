<!DOCTYPE html>
<html>
<head>
    <title>License Key Validation Test</title>
    <style>
        body {
            font-family: monospace;
            background: #000;
            color: #0ff;
            padding: 20px;
        }
        input {
            background: #111;
            color: #0ff;
            border: 1px solid #0ff;
            padding: 10px;
            width: 300px;
            font-family: monospace;
        }
        button {
            background: #0ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-family: monospace;
        }
        .result {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #0ff;
        }
        .valid { color: #0f0; }
        .invalid { color: #f00; }
        .debug { color: #ff0; font-size: 12px; }
    </style>
</head>
<body>
    <h1>yurucode license validation test</h1>
    
    <div>
        <input type="text" id="keyInput" placeholder="XXXXX-XXXXX-XXXXX-XXXXX-XXXXX" />
        <button onclick="validateKey()">validate</button>
    </div>
    
    <div id="result" class="result"></div>
    
    <div style="margin-top: 30px;">
        <h3>generate test key:</h3>
        <button onclick="generateTestKey()">generate new key</button>
        <div id="generatedKey" style="margin-top: 10px;"></div>
    </div>

    <script>
        // Constants from keygen.py
        const CIPHER = 'yuru>code';
        const CUSTOM_ALPHABET = '23456789ABCDEFGHJKLMNPQRSTUVWXYZ';
        
        // Cipher transform function (matches Python)
        function cipherTransform(data, roundNum) {
            let result = 0;
            const cipherBytes = new TextEncoder().encode(CIPHER);
            
            for (let i = 0; i < data.length; i++) {
                const cipherByte = cipherBytes[i % cipherBytes.length];
                const transformed = (data[i] * (cipherByte + roundNum + 1)) ^ (cipherByte << (i % 8));
                result = (result + transformed) % 0xFFFFFF;
            }
            
            return result;
        }
        
        // Generate checksum for a segment (matches Python)
        function generateChecksum(segment, position) {
            let checksum = 0;
            const cipherBytes = new TextEncoder().encode(CIPHER);
            
            for (let i = 0; i < segment.length; i++) {
                const charValue = CUSTOM_ALPHABET.indexOf(segment[i]);
                const cipherValue = cipherBytes[(position + i) % cipherBytes.length];
                checksum = (checksum * 33 + charValue * cipherValue) % 0xFFFF;
            }
            
            return checksum;
        }
        
        // SHA-256 hash function
        async function sha256(message) {
            const encoder = new TextEncoder();
            const data = encoder.encode(message);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return new Uint8Array(hash);
        }
        
        // Validate license key (matches Python validate_key)
        async function validateLicenseKey(key) {
            try {
                // Check format
                if (!key || key.length !== 29) {
                    return { valid: false, reason: 'Invalid format' };
                }
                
                const parts = key.toUpperCase().split('-');
                if (parts.length !== 5 || parts.some(p => p.length !== 5)) {
                    return { valid: false, reason: 'Invalid segment lengths' };
                }
                
                // Check alphabet
                for (const part of parts) {
                    for (const char of part) {
                        if (!CUSTOM_ALPHABET.includes(char)) {
                            return { valid: false, reason: 'Invalid characters' };
                        }
                    }
                }
                
                const [seg1, seg2, seg3, seg4, seg5] = parts;
                
                // Generate checksums
                const check1 = generateChecksum(seg1, 0);
                const check2 = generateChecksum(seg2, 1);
                const check3 = generateChecksum(seg3, 2);
                const check4 = generateChecksum(seg4, 3);
                const check5 = generateChecksum(seg5, 4);
                
                const cipherSum = new TextEncoder().encode(CIPHER).reduce((a, b) => a + b, 0);
                
                // Validation checks
                const val1 = (check1 * cipherSum + check5) % 1000;
                const val2 = (check2 * cipherSum + check4) % 1000;
                const val3 = (check3 * cipherSum) % 1000;
                
                const validations = [
                    val1 % 17 <= 15,
                    val2 % 19 <= 17,
                    val3 % 23 <= 21,
                    (check1 + check2 + check3 + check4 + check5) % 100 !== 99,
                    new Set(key.replace(/-/g, '')).size >= 10
                ];
                
                // Check segment 5 validation
                const allSegs = seg1 + seg2 + seg3 + seg4;
                const finalCheck = await sha256(allSegs + CIPHER.repeat(3));
                
                // Convert first 8 bytes to number (big-endian)
                let finalValue = 0n;
                for (let i = 0; i < 8; i++) {
                    finalValue = (finalValue << 8n) | BigInt(finalCheck[i]);
                }
                
                const transformed = cipherTransform(finalCheck.slice(0, 8), 4);
                
                // Recreate segment 5
                let seg5Calculated = '';
                let tempValue = finalValue;
                
                for (let i = 0; i < 5; i++) {
                    const charVal = Number((tempValue + BigInt(transformed) + BigInt(i * cipherSum)) % BigInt(CUSTOM_ALPHABET.length));
                    seg5Calculated += CUSTOM_ALPHABET[charVal];
                    tempValue = (tempValue * 33n + BigInt(charVal)) % 0xFFFFFFFn;
                }
                
                // The last segment must match our calculation
                if (seg5 !== seg5Calculated) {
                    return { valid: false, reason: 'Segment 5 validation failed' };
                }
                
                // All validations must pass
                const allValid = validations.every(v => v);
                
                return {
                    valid: allValid,
                    checks: validations,
                    seg5Match: seg5 === seg5Calculated,
                    details: {
                        val1Check: `${val1 % 17} <= 15 = ${val1 % 17 <= 15}`,
                        val2Check: `${val2 % 19} <= 17 = ${val2 % 19 <= 17}`,
                        val3Check: `${val3 % 23} <= 21 = ${val3 % 23 <= 21}`,
                        sumCheck: `${(check1 + check2 + check3 + check4 + check5) % 100} != 99 = ${(check1 + check2 + check3 + check4 + check5) % 100 !== 99}`,
                        entropyCheck: `${new Set(key.replace(/-/g, '')).size} >= 10 = ${new Set(key.replace(/-/g, '')).size >= 10}`
                    }
                };
            } catch (e) {
                return { valid: false, reason: 'Validation error: ' + e.message };
            }
        }
        
        async function validateKey() {
            const key = document.getElementById('keyInput').value;
            const result = await validateLicenseKey(key);
            
            const resultDiv = document.getElementById('result');
            if (result.valid) {
                resultDiv.innerHTML = `
                    <div class="valid">✓ VALID KEY</div>
                    <div class="debug">All validation checks passed</div>
                `;
            } else {
                resultDiv.innerHTML = `
                    <div class="invalid">✗ INVALID KEY</div>
                    <div class="debug">${result.reason || 'Validation failed'}</div>
                    ${result.details ? `<div class="debug" style="margin-top: 10px;">
                        ${Object.entries(result.details).map(([k, v]) => `${k}: ${v}`).join('<br>')}
                    </div>` : ''}
                `;
            }
        }
        
        // Simple key generation for testing
        async function generateTestKey() {
            const genDiv = document.getElementById('generatedKey');
            genDiv.innerHTML = 'Note: Use keygen.py to generate valid keys. This is just for testing the validation.';
            
            // For actual key generation, you must use keygen.py
            // This HTML file is only for validation testing
        }
        
        function testKey(key) {
            document.getElementById('keyInput').value = key;
            validateKey();
        }
    </script>
</body>
</html>